# 高级图形 {#sec-advanced}

```{r}
#| echo: false

source("_common.R")
```

-  @sec-visualize-data-relation 探索、展示数据中隐含的相关信息，这种相关具有一般性，比如线性和非线性相关，位序关系、包含关系、依赖关系等，具体有散点图、气泡图、凹凸图、韦恩图、甘特图和网络图。
-  @sec-visualize-data-uncertainty 探索、展示数据中隐含的不确定性，统计中描述不确定性有很多概念，比如置信区间、假设检验中的 P 值，统计模型中的预测值及其预测区间，模型残差隐含的分布，模型参数分量的边际分布及其效应，贝叶斯视角下的模型参数的后验分布。
-  @sec-visualize-spatial-data 探索、展示空间数据中隐含的分布信息。对于空间区域数据，介绍地区分布图、比例符号图和扭曲变形图，而对于栅格数据，介绍地形轮廓图，包括二维的和三维的，静态的和交互的。


## 描述关系 {#sec-visualize-data-relation}


### 散点图 {#sec-scatter}

散点图用以描述变量之间的关系，展示原始的数据，点的形态、大小、颜色等都可以随更多变量变化。

中国国家统计局 2021 年发布的统计年鉴，2020 年 31 个省、直辖市、自治区的抚养比、文盲率、人口数的关系。

```{r}
#| label: tbl-china-raise-illiteracy-scatter
#| tbl-cap: "2020 年各省、直辖市、自治区，总抚养比和文盲率相关数据（部分）"
#| echo: false

china_raise_illiteracy <- readRDS(file = "data/china-raise-illiteracy-2020.rds")
knitr::kable(head(china_raise_illiteracy[order(china_raise_illiteracy$`人口数`, decreasing = TRUE), ]),
  col.names = c(
    "地区", "人口数", "15-64岁", "抚养比",
    "15岁及以上人口", "文盲人口", "文盲率"
  ),
  row.names = FALSE
)
```

其中，文盲人口是指15岁及以上不识字及识字很少人口，文盲率 = 文盲人口 / 15岁及以上人口，抚养比 = (0-14岁 + 65岁及以上) / 15-64岁人口数。

```{r}
#| label: fig-china-raise-illiteracy
#| fig-cap: "文盲率与抚养比的关系"
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true

library(ggplot2)
ggplot(data = china_raise_illiteracy) +
  geom_point(aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)) +
  theme_classic() +
  labs(x = "抚养比（%）", y = "文盲率（%）")
```


### 气泡图 {#sec-bubble}

气泡图在散点图的基础上，添加了散点大小的视觉维度，可以在图上多展示一列数据，下 @fig-china-raise-illiteracy-bubble 新增了人口数变量。此外，在气泡旁边添加地区名称，将气泡填充的颜色也映射给了人口数变量。


```{r}
#| label: fig-china-raise-illiteracy-bubble
#| fig-cap: "文盲率和抚养比数据"
#| fig-width: 6
#| fig-height: 4.5
#| fig-showtext: true

library(ggrepel)
library(scales)
ggplot(
  data = china_raise_illiteracy,
  aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)
) +
  geom_point(aes(size = `人口数`, color = `人口数`),
    alpha = 0.85, pch = 16,
    show.legend = c(color = FALSE, size = TRUE)
  ) +
  scale_size(labels = label_number(scale_cut = cut_short_scale())) +
  scale_color_viridis_c(option = "C") +
  geom_text_repel(
    aes(label = `地区`),
    size = 3, max.overlaps = 50,
    segment.colour = "gray", seed = 2022, show.legend = FALSE
  ) +
  coord_cartesian(xlim = c(30, 60), ylim = c(0, 10.5), expand = FALSE) +
  theme_classic() +
  labs(x = "抚养比（%）", y = "文盲率（%）")
```


### 凹凸图 {#sec-bump}

凹凸图描述位置排序关系随时间的变化，比如前年、去年和今年各省的 GDP 排序变化，春节各旅游景点的人流量变化。[**ggbump**](https://github.com/davidsjoberg/ggbump) 包专门用来绘制凹凸图，如 @fig-bump 所示，展示

```{r}
#| label: fig-bump
#| fig-cap: "凹凸图"
#| fig-width: 7
#| fig-height: 3.5
#| fig-showtext: true

library(ggbump)
# 位置排序变化
df <- data.frame(
  country = c(
    "印度", "印度", "印度", "瑞典",
    "瑞典", "瑞典", "德国", "德国",
    "德国", "芬兰", "芬兰", "芬兰"
  ),
  year = c(
    2018, 2019, 2020, 2018, 2019, 2020,
    2018, 2019, 2020, 2018, 2019, 2020
  ),
  value = c(
    492, 246, 246, 369, 123, 492,
    246, 369, 123, 123, 492, 369
  )
)

library(data.table)
df <- as.data.table(df)
df[, rank := rank(value, ties.method = "random"), by = "year"]

ggplot(df, aes(year, rank, color = country)) +
  geom_point(size = 7) +
  geom_text(data = df[df$year == min(df$year), ],
            aes(x = year - .1, label = country), size = 5, hjust = 1) +
  geom_text(data = df[df$year == max(df$year), ],
            aes(x = year + .1, label = country), size = 5, hjust = 0) +
  geom_bump(linewidth = 2, smooth = 8) +
  scale_x_continuous(limits = c(2017.6, 2020.4),
                     breaks = seq(2018, 2020, 1)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        panel.grid.major = element_blank()) +
  labs(x = NULL, y = "排名") +
  scale_y_reverse() +
  coord_fixed(ratio = 0.5)
```



### 韦恩图 {#sec-venn-diagram}

韦恩图描述集合、群体的交叉关系，整体和部分的包含关系，[**ggVennDiagram**](https://github.com/gaospecial/ggVennDiagram/) 包展示 A、B、C 三个集合的交叉关系，如 @fig-venn 所示

```{r}
#| label: fig-venn
#| fig-cap: "A、B、C 三个集合的交叉关系"
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

x <- list(A = 1:5, B = 2:7, C = 5:10)
ggVennDiagram::ggVennDiagram(x) +
  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")
```


### 甘特图 {#sec-gantt}


甘特图常用于项目、流程管理，描述节点之间的依赖关系，展示关键节点。
[**ganttrify**](https://github.com/giocomai/ganttrify) 包专门用来绘制甘特图，如 @fig-gant 所示。


```{r}
#| label: fig-gant
#| fig-cap: "项目和任务进展"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

library(ganttrify)
ganttrify(project = ganttrify::test_project,
          project_start_date = "2021-03",
          font_family = "sans")
```



### 网络图 {#sec-network}


[**tidygraph**](https://github.com/thomasp85/tidygraph)包 操作图数据，[**ggraph**](https://github.com/thomasp85/ggraph)包描述网络图中节点重要性及依赖关系。

```{r}
library(ggraph)
graph <- tidygraph::as_tbl_graph(highschool) |> 
    dplyr::mutate(Popularity = tidygraph::centrality_degree(mode = 'in'))

graph
```



```{r}
#| label: fig-graph
#| fig-cap: "学校关系"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

ggraph(graph, layout = "kk") +
  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) +
  geom_node_point(aes(size = Popularity)) +
  facet_edges(~year) +
  theme_graph(
    base_family = "sans",
    foreground = "steelblue",
    fg_text_colour = "white"
  )
```


## 描述不确定性 {#sec-visualize-data-uncertainty}


<!-- 
可视化不确定性，这属于高级篇内容，阐述一些常用、常见的统计概念
https://github.com/wilkelab/ungeviz
https://wilkelab.org/SDS375/schedule.html

Psychology of Data Visualization 2021 Michael Friendly
http://euclid.psych.yorku.ca/www/psy6135/

Visualizing the uncertainty of point estimates.
Uncertainty is expressed as standard error, confidence interval, or credible interval
https://wilkelab.org/SDS375/slides/visualizing-uncertainty.html#1

[ggdist](https://github.com/mjskay/ggdist) Visualizations of distributions and uncertainty [@ggdist2022]
-->



### 置信区间 {#sec-confidence-interval}

<!-- 
描述点估计的不确定性
二项分布参数 p 的点估计与区间估计，与后续覆盖概率联系起来
-->



| 0 | 1 | 2 | $\cdots$ | n |
|:--|:---|:---|:---|:---|
| $p_0$ | $p_1$ | $p_2$ | $\cdots$ | $p_n$ |

: 二项分布的分布列 {#tbl-binom}



二项分布 $\mathrm{Bin}(n,p)$ 的参数 $p$ 的精确区间估计如下：

$$
(B(\frac{\alpha}{2}; x, n-x+1), B(1-\frac{\alpha}{2}; x+1, n-x))
$$ {#eq-clopper-ci}

$x$ 是成功次数，$n$ 是实验次数，$B(p;v,w)$ 是形状参数为 v 和 w 的 Beta 分布的 p 分位数，p 的置信区间的上下限 $P_L,P_U$ 满足


\begin{align}
\frac{\Gamma(n+1)}{\Gamma(x)\Gamma(n-x+1)}\int_{0}^{P_L}t^{x-1}(1-t)^{n-x}\mathrm{dt} &= \frac{\alpha}{2} \\
\frac{\Gamma(n+1)}{\Gamma(x+1)\Gamma(n-x)}\int_{0}^{P_U}t^{x}(1-t)^{n-x-1}\mathrm{dt} &= 1-\frac{\alpha}{2}
\end{align}


$p_x$ 表示二项分布 $\mathrm{Bin}(n,p)$ 第 $x$ 项的概率，$x$ 的取值为 $0,1,\cdots,n$

$$p_x = \binom{n}{x}p^x(1-p)^{n-x}, \quad x = 0,1,\cdots,n$$

二项分布的累积分布函数和 $S_k$ 表示前 $k$ 项概率之和

$$S_k = \sum_{x=0}^{k} p_x$$

$S_k$ 服从形状参数为 $n-k,k+1$ 的贝塔分布 $I_x(a,b)$，对应于 R 函数 `pbeta(x,a,b)`。 $S_k$ 看作贝塔分布的随机变量 $X$

\begin{align}
B_x(a,b) &=\int_{0}^{x}t^{a-1}(1-t)^{b-1}\mathrm{dt} \\
I_x(a,b) &= \frac{B_x(a,b)}{B(a,b)}, \quad B(a,b) = B_1(a,b)
\end{align}

考虑二项总体的参数 $p=0.7$，重复模拟 50 次，每次模拟获得的比例 $\hat{p}$ 及其置信区间，如 @fig-clopper-pearson-ci 所示，置信区间覆盖真值的情况用不同颜色表示，覆盖用 TRUE 表示，没有覆盖用 FALSE 表示

```{r}
#| label: fig-clopper-pearson-ci
#| fig-cap: "Clopper-Pearson 置信区间"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true

library(ggplot2)
# Clopper and Pearson (1934)
# 与 binom.test() 计算结果一致
clopper_pearson <- function(p = 0.1, n = 10, nsim = 100) {
  set.seed(2022)
  nd <- rbinom(nsim, prob = p, size = n)
  ll <- qbeta(p = 0.05 / 2, shape1 = nd, shape2 = n - nd + 1)
  ul <- qbeta(p = 1 - 0.05 / 2, shape1 = nd + 1, shape2 = n - nd)
  data.frame(nd = nd, ll = ll, ul = ul, cover = ul > p & ll < p)
}
# 二项分布的参数 p = 0.7
dat <- clopper_pearson(p = 0.7, n = 10, nsim = 50)
# 二项分布的参数的置信区间覆盖真值的情况
ggplot(data = dat, aes(x = 1:50, y = nd / 10, colour = cover)) +
  geom_hline(yintercept = 0.7, lty = 2, linewidth = 1.2, color = "gray") +
  geom_pointrange(aes(ymin = ll, ymax = ul)) +
  theme_classic() +
  labs(x = "第几次模拟", y = "置信区间上下限", color = "覆盖")
```






### 假设检验 {#sec-hypothesis-tests}

<!-- 
描述检验统计假设的不确定性  P 值和功效
对一个统计假设，我有一套方法来检验其正确性，但结论具有不确定性（小概率原理，P 值和风险联系），同一个统计假设，同一组数据，不同的检验方法有不同的 P 值，是检验方法的功效不同。

[ggpubr](https://github.com/kassambara/ggpubr) 制作出版级统计图形，两样本均值的比较
-->

[**ggpval**](https://github.com/s6juncheng/ggpval) 在图上添加检验的 P 值结果，[**ggsignif**](https://github.com/const-ae/ggsignif) [@ggsignif2021] 在图上添加显著性注释。[**ggstatsplot**](https://github.com/IndrajeetPatil/ggstatsplot) [@Indrajeet2021] 可视化统计检验、模型的结果，描述功效变化。


```{r}
#| label: fig-plant-growth
#| echo: true
#| fig-cap: "植物生长"
#| fig-width: 5
#| fig-height: 3.5
#| fig-showtext: true

with(
  aggregate(
    data = PlantGrowth, weight ~ group,
    FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x))
  ),
  cbind.data.frame(weight, group)
) |>
  ggplot(aes(x = group, y = dist_mean)) +
  geom_col(
    position = position_dodge(0.4), width = 0.4, fill = "gray"
  ) +
  geom_errorbar(aes(
    ymin = dist_mean - dist_sd,
    ymax = dist_mean + dist_sd
  ),
  position = position_dodge(0.4), width = 0.2
  ) +
  theme_classic() +
  labs(x = "组别", y = "植物干重")
```

::: {.callout-note}
R 3.5.0 以后，函数 `aggregate()` 的参数 `drop` 默认值为 `TRUE`， 表示扔掉未用来分组的变量，聚合返回的是一个矩阵类型的数据对象。
:::


单因素方差分析

```{r}
oneway.test(data = PlantGrowth, weight ~ group)
```


@fig-signif 展示假设检验的结果

```{r}
#| label: fig-signif
#| fig-cap: "展示假设检验的结果"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggsignif)
ggplot(data = PlantGrowth, aes(x = group, y = weight)) +
  geom_boxplot(width = 0.25) +
  geom_jitter(width = 0.15) +
  geom_signif(comparisons = list(c("ctrl", "trt1"), c("trt1", "trt2")), 
              map_signif_level = function(p) sprintf("p = %.2g", p), 
              textsize = 6, test = "t.test") +
  theme_classic() +
  coord_cartesian(clip = "off")
```


### 模型预测 {#sec-model-predictions}

<!-- 
描述模型预测/曲线拟合的不确定性
趋势拟合和描述关系中添加回归线及置信带

rgl 广义可加模型可视化
https://menugget.blogspot.com/2016/02/visualizing-model-predictions-in-3d.html

[mgcViz](https://github.com/mfasiolo/mgcViz)

Scalable visualisation methods for modern Generalized Additive Models
https://arxiv.org/abs/1809.10632
-->

代码提交量的趋势拟合

```{r}
#| label: fig-smooth
#| fig-cap: "趋势拟合、预测和推断"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

svn_trunk_log <- readRDS(file = "data/svn-trunk-log-2022.rds")
svn_trunk_log$year <- as.integer(format(svn_trunk_log$stamp, "%Y"))
trunk_year <- aggregate(data = svn_trunk_log, revision ~ year, FUN = length)
ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(aes(color = "LOESS", fill = "LOESS"),
    method = "loess", formula = "y~x",
    method.args = list(
      span = 0.75, degree = 2, family = "symmetric",
      control = loess.control(surface = "direct", iterations = 4)
    ), data = subset(trunk_year, year != c(1997, 2022))
  ) +
  geom_smooth(aes(color = "GAM", fill = "GAM"),
    formula = y ~ s(x, k = 12),
    method = "gam", se = T,
    data = subset(trunk_year, year != c(1997, 2022))
  ) +
  geom_smooth(aes(color = "Cubic Spline", fill = "Cubic Spline"),
                method = "lm", formula = y ~ splines::bs(x, 3), se = T,
              data = subset(trunk_year, year != c(1997, 2022))) +
  scale_color_brewer(name = "模型", palette = "Set1") +
  scale_fill_brewer(name = "模型", palette = "Set1") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



### 模型诊断 {#sec-model-diagnostics}


> 所有模型都是错误的，但有些是有用的。
>
> --- 乔治·博克斯

<!-- 
描述模型拟合数据的不确定性，
Cook 距离、高杠杆值、模型诊断、影响测量
[ggPMX](https://github.com/ggPMXdevelopment/ggPMX) ggplot2 Based Tool to Facilitate Diagnostic Plots for NLME Models
-->

```{r}
#| label: fig-lm-diagnostics
#| fig-cap: "线性模型的诊断图"
#| fig-showtext: true
#| collapse: true
#| fig-width: 7
#| fig-height: 8

state_x77 <- data.frame(state.x77,
  state_name = rownames(state.x77),
  state_region = state.region,
  state_abb = state.abb,
  check.names = FALSE
)

# 模型诊断图
fit <- lm(`Life Exp` ~ Income + Murder, data = state_x77)
op <- par(mfrow = c(3, 2), mar = c(4, 4, 3, 1))
plot(fit,
  ask = FALSE, which = c(1, 2, 3, 4, 5, 6),
  caption = list(
    "残差和拟合值", "正态 Q-Q 图",
    "尺度-位置", "Cook 距离", "残差和杠杆值",
    expression("Cook 距离 vs 杠杆值" * h[ii] / (1 - h[ii]))
  )
)
par(op)
```



### 边际效应 {#sec-marginal-effects}

继续 state_x77 数据集，以预期寿命（1969-1971 年统计）为因变量，Income 人均收入（1974 年）和 Murder 谋杀和非过失杀人率（单位：十万分之一，1976 年统计）为自变量，建立线性模型如下：

$$
\text{Life Exp} = \alpha + \beta_1  \text{Income} + \beta_2 \text{Murder} + \epsilon
$$ {#eq-lm-state-x77}

在 R 语言中，可以用函数 `lm()` 拟合上述模型，

```{r}
fit <- lm(`Life Exp` ~ Income + Murder, data = state_x77)
```

模型拟合结果输出如下：

```{r}
summary(fit)
```

[ggeffects](https://github.com/strengejacke/ggeffects) 描述单个自变量的作用，人均收入对预期寿命的边际效应

```{r}
#| label: fig-marginal-effects
#| fig-cap: "边际效应"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggeffects)
income_pred <- ggpredict(fit, terms = "Income")
ggplot(income_pred, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.1) +
  theme_classic() +
  labs(x = "人均收入", y = "预期寿命")
```



### 后验分布 {#sec-posterior-distributions}

<!-- 
描述参数先验分布的不确定性
先验分布与后验分布
描述分布的不确定性 

先验分布 参数的分布
观测分布 给定参数的情况下，数据的分布
后验分布 给定数据的情况下，参数的分布

条件分布、累积分布 [pgog](https://github.com/MUCollective/pgog)
-->


```{r}
#| label: setup-cmdstan
#| echo: false
#| eval: false

# Github Action 已经设置
# Sys.setenv(CMDSTAN="/opt/cmdstan/cmdstan-2.31.0")
# Sys.setenv(CMDSTANR_NO_VER_CHECK=TRUE)
```

以一个最简单的贝叶斯线性模型为例，介绍贝叶斯统计中的后验分布。继续以 state_x77 数据为例，以贝叶斯线性模型拟合数据，获得参数的后验分布。

[Stan](https://github.com/stan-dev) 是一个统计建模和高性能统计计算的平台，广泛应用于社会、生物、物理、工程、商业等领域，提供统计建模、数据分析和预测能力[@Gelman2015]。它提供一套成熟的概率编程语言[@Carpenter2017]，Stan 语言编码的贝叶斯线性模型如下：

```{verbatim, file="code/state_x77.stan", lang="stan"}
```

这里采用汉密尔顿蒙特卡洛算法（HMC）做全贝叶斯推断，下面依次编译模型、准备数据、参数初值和迭代设置。Stan 的 R 语言接口 [**cmdstanr**](https://github.com/stan-dev/cmdstanr) 包可以让这一切在 R 语言环境里做起来比较顺畅。

```{r}
#| label: compile-stan-model
#| message: false
#| results: hide

library(cmdstanr)
# 编译模型
mod_state_x77 <- cmdstan_model(
  stan_file = "code/state_x77.stan",
  compile = TRUE,
  cpp_options = list(stan_threads = TRUE)
)
# 准备数据
state_x77_d <- list(
  N = nrow(state_x77), # 观测记录的条数
  K = 2, # 协变量个数
  x = state_x77[, c("Income", "Murder")], # N x 2 矩阵
  y = state_x77[, "Life Exp"] # N 向量
)
nchains <- 4 # 4 条迭代链
# 给每条链设置不同的参数初始值
inits_data <- lapply(1:nchains, function(i) {
  list(
    alpha = runif(1, 0, 1),
    beta = runif(2, 1, 10),
    sigma = runif(1, 1, 10)
  )
})
# 采样拟合模型
fit_state_x77 <- mod_state_x77$sample(
  data = state_x77_d, # 观测数据
  init = inits_data, # 迭代初值
  iter_warmup = 1000, # 每条链预处理迭代次数
  iter_sampling = 2000, # 每条链总迭代次数
  chains = nchains, # 马尔科夫链的数目
  parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个
  threads_per_chain = 1, # 每条链设置一个线程
  show_messages = FALSE, # 不显示迭代的中间过程
  refresh = 0, # 不显示采样的进度
  seed = 20190425 # 设置随机数种子，不要使用 set.seed() 函数
)
```

:::{.callout-tip}
Stan 还提供自动微分变分推断（ADVI）算法做近似贝叶斯推断获取参数的后验分布，以及拟牛顿法（L-BFGS）优化算法获取参数的惩罚极大似然估计。
:::

模型参数估计结果如下：

```{r}
#| label: tbl-state-x77-output
#| tbl-cap: "贝叶斯线性模型参数估计结果"
#| echo: false

fit_state_x77$summary(c("alpha", "beta[1]", "beta[2]", "sigma", "lp__")) |> 
  knitr::kable(digits = 3)
```

参数的 $\alpha,\beta_1,\beta_2$ 后验均值估计与普通线性模型的拟合结果非常一致。采样结果可以直接传递给 **bayesplot** 包[@Gabry2019]，绘制参数迭代的轨迹图和后验分布图。

```{r}
#| label: fig-post-dists
#| fig-cap: "参数的后验分布和迭代轨迹"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 8.5
#| message: false

library(bayesplot)
library(patchwork)
# 参数的后验分布
p1 <- mcmc_hist(fit_state_x77$draws(c("alpha", "beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed,
    strip.position = "top",
    ncol = 1
  )
) + theme_classic()
# 参数的迭代轨迹
p2 <- mcmc_trace(fit_state_x77$draws(c("alpha", "beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed,
    strip.position = "top",
    ncol = 1
  )
) + theme_classic() + theme(legend.title = element_blank())
# 绘图
p1 | p2
```

从参数的迭代轨迹可以看出四条马尔可夫链混合得很好，后验分布图主要用来描述参数的迭代结果，后验分布图可以是直方图或密度图的形式，可以和 @tbl-state-x77-output 一道检验模型的拟合情况。


