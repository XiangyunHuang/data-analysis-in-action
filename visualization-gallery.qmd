# 统计图形 {#sec-gallery}


```{r}
#| echo: false

knitr::knit_hooks$set(par = function(before, options, envir) {
  if (before && options$fig.show != "none") {
    par(
      mar = c(4, 4, .5, .5)
    )
  }
})

if (xfun::is_macos()) {
  # 准备 Noto 中英文字体
  sysfonts::font_paths(new = "~/Library/Fonts/")
  ## 宋体
  sysfonts::font_add(
    family = "Noto Serif CJK SC",
    regular = "NotoSerifCJKsc-Regular.otf",
    bold = "NotoSerifCJKsc-Bold.otf"
  )
  ## 黑体
  sysfonts::font_add(
    family = "Noto Sans CJK SC",
    regular = "NotoSansCJKsc-Regular.otf",
    bold = "NotoSansCJKsc-Bold.otf"
  )
} else { # Github Action Ubuntu
  sysfonts::font_paths(new = c(
    "/usr/share/fonts/opentype/noto/",
    "/usr/share/fonts/truetype/noto/"
  ))
  ## 宋体
  sysfonts::font_add(
    family = "Noto Serif CJK SC",
    regular = "NotoSerifCJK-Regular.ttc",
    bold = "NotoSerifCJK-Bold.ttc"
  )
  ## 黑体
  sysfonts::font_add(
    family = "Noto Sans CJK SC",
    regular = "NotoSansCJK-Regular.ttc",
    bold = "NotoSansCJK-Bold.ttc"
  )
}

## 衬线字体
sysfonts::font_add(
  family = "Noto Serif",
  regular = "NotoSerif-Regular.ttf",
  bold = "NotoSerif-Bold.ttf",
  italic = "NotoSerif-Italic.ttf",
  bolditalic = "NotoSerif-BoldItalic.ttf"
)
## 无衬线字体
sysfonts::font_add(
  family = "Noto Sans",
  regular = "NotoSans-Regular.ttf",
  bold = "NotoSans-Bold.ttf",
  italic = "NotoSans-Italic.ttf",
  bolditalic = "NotoSans-BoldItalic.ttf"
)
```


## 描述趋势 {#sec-visualize-data-trend}


<!--
写作模式：

1. 提出问题：引发兴趣，探案，讲故事。
2. 数据探索：数据预处理、分组计算等操作
3. 绘图说明：给出最终展示图，说明关键函数，技巧实现
4. 一般总结：图形的一般作用，目的是方便读者将其应用于其它场景，举一反三。
5. 本节小结：5-6 个不同图形探索的对比总结
-->


R 是一个自由的统计计算和统计绘图环境，最初由新西兰奥克兰大学统计系的 Ross Ihaka 和 Robert Gentleman 共同开发。1997 年之后，成立了一个 R Core Team（R 语言核心团队），他们在版本控制系统 [Apache Subversion](https://subversion.apache.org/)上一起协作开发至今。25 年，四分之一个世纪过去了，下面分析他们留下的一份开发日志，了解一段不轻易为人所知的故事。

首先，下载 1997 年至今，约 25 年的原始代码提交日志数据。下载数据的代码如下，它是一行 Shell 命令，可在 MacOS 或 Ubuntu 等 Linux 系统的终端里运行，借助 Apache Subversion 软件，将提交日志导出为 [XML 格式](https://www.w3.org/standards/xml/core) 的数据文件，保存在目录 `data-raw/` 下，文件名为 `svn_trunk_log_20220727.xml`，本书网页版随附。

```{bash}
#| eval: false

svn log --xml --verbose -r 6:82626 \
  https://svn.r-project.org/R/trunk > data-raw/svn_trunk_log_2022.xml
```

去掉没什么信息的前5次代码提交记录：初始化仓库，上传原始的 R 软件源码等。
从 Ross Ihaka 在 1997-09-18 提交第 1 次代码改动开始，下载所有的提交日志。截至写作时间，即 2022年7月27日，代码最新版本号为 82626，意味着代码仓库已存在 8 万多次提交。

下载数据后，借助 [**xml2**](https://github.com/r-lib/xml2/) 包预处理这份 XML 格式数据，提取最重要的信息，谁在什么时间做了什么改动。经过一番操作后，将清洗干净的数据，
保存到目录 `data/` 下，以 R 软件特有的文件格式保存为 `svn-trunk-log-2022.rds`，同样与书随附。这样下来，原 XML 格式保存的 35 M 文件减少为 1 M 多，极大地减少了存储空间，也极大地方便了后续的数据探索和可视化。下面是这份日志数据开头的两行：

```{r}
svn_trunk_log <- readRDS(file = "data/svn-trunk-log-2022.rds")
head(svn_trunk_log, 2)
```

一共是四个字段，分别是代码提交时记录的版本号 revision，提交代码的人 author，提交代码的时间 stamp 和提交代码时伴随的说明 msg。接下来，带着问题一起探索开源统计软件 R 过去 25 年波澜壮阔的历史！



### 折线图 {#sec-line}

<!-- 
折线图层 geom_line
-->


- 过去 25 年代码提交次数的变化情况

折线图的意义是什么？在表达趋势变化，趋势的解读很重要。

不再介绍每个函数、每个参数和每行代码的作用，而是重点阐述折线图的作用，以及如何解读数据，阐述解读的思路和方向，建立起数据分析的思维。将重点放在这些方面，有助于书籍存在的长远意义，又结合了最真实的背景和原始数据，相信对实际工作的帮助会更大。而对于使用到统计方法的函数，则详加介绍，展示背后的实现细节，而不是调用函数做调包侠。


先来了解一下总体趋势，即过去 25 年里代码提交次数的变化情况。


数据集 `svn_trunk_log` 没有年份字段，但时间字段 stamp 隐含了年份信息，因此，新生成一个字段 year 将年份信息从 stamp 提取出来。


```{r}
svn_trunk_log <- within(svn_trunk_log, {
  # 提取日期、月份、年份、星期、第几周、第几天等时间成分
  year <- as.integer(format(stamp, "%Y"))
  date <- format(stamp, format = "%Y-%m-%d", tz = "UTC")
  month <- format(stamp, format = "%m", tz = "UTC")
  hour <- format(stamp, format = "%H", tz = "UTC")
  week <- format(stamp, format = "%U", tz = "UTC")
  wday <- format(stamp, format = "%a", tz = "UTC")
  nday <- format(stamp, format = "%j", tz = "UTC")
})
```

接着，调用分组聚合函数 `aggregate()` 统计各年的代码提交量。

```{r}
trunk_year <- aggregate(data = svn_trunk_log, revision ~ year, FUN = length)
```

然后，将数据集 trunk_year 以折线图展示，如 @fig-trunk-year-line 所示。

```{r}
#| label: fig-trunk-year-line
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

library(ggplot2)
ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_line() +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



为什么呈现这样的变化趋势？我最初想到的是先逐步增加，然后下降一会儿，再趋于平稳。

> 小时趋势

上午高峰

```{r}
#| label: fig-trunk-hour-line
#| fig-cap: "提交代码的时段分布"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

aggregate(data = svn_trunk_log, revision ~ year + hour, length) |> 
  ggplot(aes(x = hour, y = revision, group = year)) +
  geom_line() +
  geom_line(data = function(x) subset(x, year < 2006),
            aes(color = as.character(year))) +
  theme_classic() +
  labs(x = "时段", y = "提交量", color = "年份")
```


> 月趋势

12月和次年1月、7-8 月份提交量迎来小高峰，应该是教授们放寒暑假。是否有新人加入？

```{r}
#| label: fig-trunk-month-line
#| fig-cap: "提交代码的月份分布"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

aggregate(data = svn_trunk_log, revision ~ year + month, length) |>
  transform(date = as.Date(paste(year, month, "01", sep = "-"))) |>
  ggplot(aes(x = date, y = revision)) +
  geom_point(aes(color = factor(year)), show.legend = F, size = 0.75) +
  geom_line(aes(color = factor(year)), show.legend = F) +
  scale_x_date(date_minor_breaks = "1 year") +
  theme_classic() +
  theme(panel.grid.minor.x = element_line()) +
  labs(x = "时间（月粒度）", y = "提交量")
```



### 瀑布图 {#sec-waterfall}


<!-- 
矩形图层 geom_rect
-->

相比于折线图，瀑布图将变化趋势和增减量都展示了，如 @fig-waterfall 所示，每年的提交量就好像瀑布上的水，图中当期相对于上一期的增减量

```{r}
#| label: fig-waterfall
#| fig-cap: "25 年代码逐年提交量的变化趋势"
#| fig-showtext: true

trunk_year <- trunk_year[order(trunk_year$year), ]

trunk_year_tmp <- data.frame(
  xmin = trunk_year$year[-length(trunk_year$year)],
  ymin = trunk_year$revision[-length(trunk_year$revision)],
  xmax = trunk_year$year[-1],
  ymax = trunk_year$revision[-1],
  fill = trunk_year$revision[-1] - trunk_year$revision[-length(trunk_year$revision)] > 0
)

ggplot() +
  geom_rect(
    data = trunk_year_tmp,
    aes(
      xmin = xmin, ymin = ymin,
      xmax = xmax, ymax = ymax, fill = fill
    ), show.legend = FALSE
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


瀑布图是以数据点作为对角点构造矩形，用对撞型的颜色表示增减，下 @fig-waterfall-point 在 @fig-waterfall 基础上添加了数据点，用以直观说明矩形图层 `geom_rect()` 构造瀑布图的方法。**ggTimeSeries** 包 [@ggTimeSeries2022] (<https://github.com/thecomeonman/ggTimeSeries>) 提供统计图层 `stat_waterfall()` 实现类似的瀑布图。

```{r}
#| label: fig-waterfall-point
#| fig-cap: "矩形图层构造瀑布图"
#| fig-showtext: true

ggplot() +
  geom_rect(
    data = trunk_year_tmp,
    aes(
      xmin = xmin, ymin = ymin,
      xmax = xmax, ymax = ymax, fill = fill
    ), show.legend = FALSE
  ) +
  geom_point(
    data = trunk_year,
    aes(x = year, y = revision), size = 0.75
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


```{r}
#| echo: false
#| eval: false

# ggTimeSeries 包也可制作瀑布图
library(ggTimeSeries)
ggplot(data = trunk_year, aes(x = year, y = revision)) +
  stat_waterfall() +
  scale_fill_brewer(palette = "Set2") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



### 曲线图 {#sec-smooth}

<!-- 
平滑图层 geom_smooth
-->

将散点以线段逐个连接起来，形成折线图，刻画原始的变化，而曲线图的目标是刻画潜在趋势。有两种画法，其一从代数的角度出发，做插值平滑，在相邻两点之间以一条平滑的曲线连接起来；其二从统计的角度出发，做趋势拟合，通过线性或非线性回归，获得变化趋势，以图呈现，使得散点之中隐藏的趋势更加清晰。


**ggplot2** [@Hadley2016] 包提供函数 `geom_smooth()` 拟合散点图中隐含的趋势，通过查看函数 `geom_smooth()` 的帮助文档，可以了解其内部调用的统计方法。默认情况下，采用局部多项式回归拟合方法，内部调用了函数 `loess()` 来拟合趋势，如 @fig-trunk-year-smooth 所示。


```{r}
#| label: fig-trunk-year-smooth
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(data = subset(trunk_year, year != c(1997,2022))) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

类似大家熟悉的线性回归拟合函数 `lm()`，函数 `loess()` 也是基于类似的使用语法。下面继续以此数据为例，了解该函数的使用，继而了解 ggplot2 绘制平滑曲线图背后的统计方法。1997 年是不完整的，不参与模型参数的估计。

```{r}
trunk_year_loess <- loess(revision ~ year,
  data = subset(trunk_year, year != c(1997,2022)),
  span = 0.75, degree = 2, method = "loess",
  family = "symmetric",
  control = loess.control(surface = "direct", iterations = 4)
)
```

下面通过设定函数 `geom_smooth()` 的参数，可以达到一样的效果，见下 @fig-trunk-year-loess 

```{r}
#| label: fig-trunk-year-loess
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(method = "loess", formula = "y~x",
    method.args = list(
      span = 0.75, degree = 2, family = "symmetric",
      control = loess.control(surface = "direct", iterations = 4)
    ), data = subset(trunk_year, year != c(1997,2022))) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

除了 `method = "loess"`，函数 `geom_smooth()` 支持的统计方法还有很多，比如非线性回归拟合 `nls()`

```{r}
trunk_year_nls <- nls(revision ~ a * (year - 1996)^2 + b,
  data = subset(trunk_year, year != c(1997,2022)),
  start = list(a = -0.1, b = 1000)
)
```

采用一元二次非线性回归拟合方法，效果如 @fig-trunk-year-nls 所示。

```{r}
#| label: fig-trunk-year-nls
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    method = "nls", 
    formula = "y ~ a * (x - 1996)^2 + b",
    method.args = list(
      start = list(a = -0.1, b = 1000)
    ), se = FALSE, 
    data = subset(trunk_year, year != c(1997,2022)),
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

::: {.callout-caution}
在函数 `geom_smooth()` 内调用非线性回归拟合方法时，暂不支持提供置信区间。
:::

即便在不清楚统计原理的情况下，也不难看出 @fig-trunk-year-loess 和 @fig-trunk-year-nls 的差异，局部多项式回归捕捉到了更多的信息，特别是起步阶段的上升趋势，以及 2000-2005 年的高峰特点。


```{r}
summary(trunk_year_loess)
```


```{r}
summary(trunk_year_nls)
```

非线性回归模型带有 2 个参数，一共 26 个观察值，因此，自由度为 26 - 2 = 24。
RSE 残差平方和的标准差为

```{r}
# 非线性回归的残差平方和的标准差
sqrt(sum(residuals(trunk_year_nls)^2)/24)
```

```{r}
#| eval: false
#| echo: false

trunk_year_fit <- within(trunk_year, {
  nls_fitted = fitted(trunk_year_nls)
  loess_fitted = fitted(trunk_year_loess)
})
```

以平滑曲线连接相邻的散点，可以构造一个插值方法给函数 `geom_smooth()`，如下示例基于样条插值函数 `spline()`。样条源于德国宝马工程师，车辆外壳弧线，那些拥有非常漂亮的弧线，越光滑，与空气的摩擦阻力越小，车辆的气动外形更加符合流体力学的要求，加工打磨更加困难，往往价值不菲。美感是相通的，即使不懂车标，通过气动外形，也能识别出车辆的档次。

```{r}
#| label: fig-trunk-year-xxspline
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

xxspline <- function(formula, data, ...) {
  dat <- model.frame(formula, data)
  res <- splinefun(dat[[2]], dat[[1]])
  class(res) <- "xxspline"
  res
}

predict.xxspline <- function(object, newdata, ...) {
  object(newdata[[1]])
}

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    formula = "y~x",
    method = xxspline, se = FALSE,
    data = subset(trunk_year, year != c(1997,2022))
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

借助 spline 插值获得平滑曲线，ggalt 包的函数 `geom_xspline` 也提供类似的功能。


ggplot2 当前支持的平滑方法，还有很多


```{r}
#| label: fig-trunk-year-smooth-sets
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    formula = y ~ s(x, k = 12),
    method = "gam", se = FALSE,
    data = subset(trunk_year, year != c(1997, 2022))
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


自由度为 3 的正交多项式拟合


```{r}
#| label: fig-trunk-year-poly
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    method = "lm", 
    formula = "y ~ poly((x - 1996), 3)",
    se = FALSE, 
    data = subset(trunk_year, year != c(1997,2022)),
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

数学公式表达的统计模型与 R 语言表达的计算公式的对应关系见下 @tbl-formula ，更多详情见帮助文档 `?formula`。

| 数学公式 | R 语言计算公式|
|:---------------- |:---------------- |
| $y = \beta_0$ | `y ~ 1` |
| $y = \beta_0 + \beta_1 x_1$ | `y ~ 1 + x1` 或 `y ~ x1` 或 `y ~ x1 + x1^2` |
| $y = \beta_1 x_1$ | `y ~ 0 + x1` 或 `y ~ -1 + x1` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2$ | `y ~ x1 + x2` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_1 x_2$ | `y ~ x1 * x2` |
| $y = \beta_0 + \beta_1 x_1 x_2$ | `y ~ x1:x2` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_1 x_2$ | `y ~ x1 + x2 + x1:x2` |
| $y = \beta_0 + \sum_{i=1}^{999}\beta_i x_i$ | `y ~ .` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^5$ | `y ~ x + I(x^5)` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^2$ | `y ~ x + I(x^2)` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^2$ | `y ~ poly(x, degree = 2, raw = TRUE)` |

: 数学公式与 R 语言表示的计算公式 {#tbl-formula}

自由度为 1 的正交多项式 `poly(x, 1)` 回归模型，
函数 `glm()` 的参数 `offset` 的含义，`weights` 的含义
广义可加模型 gam 中回归样条的方法 `s()`


### 曲面图 {#sec-wireframe}

ggplot2 暂不支持三维曲面图，而 lattice 包支持，也是非常有限的支持，lattice 和 ggplot2 都是基于图层的概念，层层叠加会出现覆盖。
用来绘制函数图像还是可以的。

真三维图形可以用[rayrender](https://github.com/tylermorganwall/rayrender) 和[rayshader](https://github.com/tylermorganwall/rayshader) 包绘制。交互式三维图形可以用 [rgl](https://github.com/dmurdoch/rgl) 或 [plotly](https://github.com/plotly/plotly.R) 包绘制。

@fig-trunk-year-wireframe 是用 **lattice** 包的 `wireframe()` 函数绘制三维曲面透视图，三维图形有时候并不能很好地表达数据，或者数据并不适合用三维图形表示。数据本身并没有那么明显的趋势规律，同样也会体现不出三维图形的表达能力。大部分情况下，我们应当避免使用静态的三维图形。函数型数据是适合用三维图形来表达的，比如 @fig-usa-mortality-wireframe 。

```{r}
#| label: fig-trunk-year-wireframe
#| fig-cap: "25 年代码提交量变化趋势图"
#| fig-width: 7
#| fig-height: 6
#| echo: true
#| fig-showtext: true

trunk_year_day <- aggregate(data = svn_trunk_log, revision ~ year + nday, FUN = length)
library(lattice)
wireframe(
  data = trunk_year_day, revision ~ year * as.integer(nday),
  shade = TRUE, drape = FALSE,
  xlab = "年份",
  ylab = "第几天",
  zlab = list("提交量", rot = 90),
  scales = list(
    arrows = FALSE, col = "black"
  ),
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -.6, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -.8, units = "inches"),
      top.padding = list(x = -1.0, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = -60, x = -70, y = 0)
)
```


### 热力图 {#sec-heatmap}

<!-- 
瓦片图层 geom_tile
-->


@fig-trunk-year-heatmap 提交量变化趋势

```{r}
#| label: fig-trunk-year-heatmap
#| fig-cap: "25 年代码提交量变化热力图"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true

ggplot(data = trunk_year_day, aes(x = as.integer(nday) , y = year, fill = revision)) +
  geom_tile(linewidth = 0.4) +
  scale_fill_viridis_c(option = "C") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  labs(x = "第几天", y = "年份", fill = "提交量")
```

图层 `scale_x_continuous()` 中设置 `expand = c(0, 0)` 可以去掉数据与 x 轴之间的空隙。
或者添加坐标参考系图层 `coord_cartesian()`，设置参数 `expand = FALSE` 同时去掉横纵轴与数据之间的空隙。

```{r}
#| label: fig-trunk-month-heatmap
#| fig-cap: "25 年代码提交量变化热力图"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ year + month, length) |>
  ggplot(aes(x = month, y = year, fill = revision)) +
  geom_tile(linewidth = 0.4) +
  scale_fill_viridis_c(option = "C") +
  coord_cartesian(expand = FALSE) +
  theme_classic() +
  labs(x = "月份", y = "年份", fill = "提交量")
```



### 日历图 {#sec-calendar}

<!-- 
瓦片图层 geom_tile
-->

更加直观地展示出节假日、休息工作日、寒暑假，比如描述学生学习规律、需求的季节性变化、周期性变化。

```{r}
# 星期、月份缩写
week.abb <- c(
  "Sun", "Mon", "Tue", "Wed",
  "Thu", "Fri", "Sat"
)
month.abb <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
# 按年、星期、第几周聚合统计提交量数据
svn_trunk_year <- aggregate(
  revision ~ year + wday + week,
  FUN = length,
  data = svn_trunk_log, 
  subset = year %in% 2018:2022
)
# 第几周转为整型数据
# 周几转为因子型数据
svn_trunk_year <- within(svn_trunk_year, {
   week = as.integer(week)
   wday = factor(wday, labels = week.abb)
})
```

```{r}
#| label: fig-calendar
#| fig-cap: "最近 5 年休息和工作日打码活跃度"
#| fig-width: 8
#| fig-height: 7
#| fig-showtext: true

ggplot(data = svn_trunk_year, aes(
  x = week, y = wday,
  fill = cut(revision, breaks = 5 * 0:5)
)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_brewer(palette = "Greens") +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(1, 52, length = 12),
    labels = month.abb
  ) +
  facet_wrap(~year, ncol = 1) +
  theme_minimal() +
  labs(x = "月份", y = "星期", fill = "提交量")
```

经过了解 svn_trunk_year 2018 - 2022 年每天提交量的范围是 0 次到 21 次，0 次表示当天没有提交代码，SVN 上也不会有日志记录。因此，将提交量划分为 5 档



### 棋盘图 {#sec-chess}

<!-- 
标签图层 geom_label
-->

棋盘图一般可以放所有时间节点的聚合信息，格点处为落的子


```{r}
#| echo: false
#| label: rversion-raw-data

rversion <- readRDS(file = "data/rversion-2022.rds")
```

该数据集的存储结构很简单，是一个两列的数据框，它的一些属性如下：

```{r}
str(rversion)
```

做一点数据处理，将 date 字段转为日期类型，并从日期中提取年、月信息。

```{r}
rversion$date <- as.Date(rversion$date, format = "%Y-%m-%d", tz = "UTC")
rversion$year <- format(rversion$date, "%Y")
rversion$month <- format(rversion$date, "%m")
```


统计过去 25 年里每月的发版次数，如图 @fig-rversion-chess

```{r}
#| label: fig-rversion-chess
#| fig-cap: "25 年 R 软件发版情况"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 8

aggregate(data = rversion, version ~ year + month, length) |>
  ggplot(aes(x = month, y = year)) +
  geom_label(aes(label = version, fill = version),
    show.legend = F, color = "white"
  ) +
  scale_fill_viridis_c(option = "D", begin = 0.2, end = 0.8) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray95")) +
  labs(x = "月份", y = "年份")
```


### 时间线图 {#sec-timeline}

<!-- 
线段图层 geom_segment
-->

时间线图非常适合回顾过去，展望未来，讲故事

时间线图展示信息的层次和密度一般由时间跨度决定。时间跨度大时，展示重点节点信息，时间跨度小时，重点和次重点信息都可以放。从更加宏观的视角，厘清发展脉络，比如近两年的 R 软件发版情况。


本节用到一个数据集 rversion，记录了历次 R 软件发版时间及版本号，见 @tbl-rversion

```{r}
#| echo: false
#| label: tbl-rversion
#| tbl-cap: "R 软件发版数据集（部分）"

knitr::kable(head(rversion), col.names = c("版本号", "发版日期", "发版年份", "发版月份"))
```



```{r}
rversion_tl <- within(rversion, {
  # 版本号为 x.0.0 为重大版本 big
  # 版本号为 x.1.0 x.12.0 x.20.0 为主要版本 major
  # 版本号为 x.0.1 为次要版本 minor
  status <- ifelse(grepl(pattern = "*\\.0\\.0", x = version), "big", version)
  status <- ifelse(grepl(pattern = "*\\.[1-9]{1,2}\\.0$", x = status), "major", status)
  status <- ifelse(!status %in% c("big", "major"), "minor", status)
})
positions <- c(0.5, -0.5, 1.0, -1.0, 1.5, -1.5)
directions <- c(1, -1)
# 位置
rversion_pos <- data.frame(
  # 只要不是同一天发布的版本，方向相对
  date = unique(rversion_tl$date),
  position = rep_len(positions, length.out = length(unique(rversion_tl$date))),
  direction = rep_len(directions, length.out = length(unique(rversion_tl$date)))
)
# 原始数据上添加方向和位置信息
rversion_df <- merge(x = rversion_tl, y = rversion_pos, by = "date", all = TRUE)
# 最重要的状态放在最后绘制到图上
rversion_df <- rversion_df[with(rversion_df, order(date, status)), ]
```

选取一小段时间内的发版情况，比如最近的三年 --- 2020 - 2022 年 


```{r}
# 选取 2020 - 2022 年的数据
sub_rversion_df<- rversion_df[rversion_df$year %in% 2020:2022, ]
# 月份注释
month_dat <- data.frame(
  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = "3 month")
)
month_dat <- within(month_dat, {
  month = format(date, "%b")
})
# 年份注释
year_dat <- data.frame(
  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = "1 year")
)
year_dat <- within(year_dat, {
  year = format(date, "%Y")
})
```


@fig-rversion-timeline 展示 2020-2022 年 R 软件发版情况


```{r}
#| label: fig-rversion-timeline
#| fig-cap: "2020-2022 年 R 软件发版情况"
#| fig-width: 8
#| fig-height: 4
#| fig-showtext: true

ggplot(data = sub_rversion_df) +
  geom_segment(aes(x = date, y = 0, xend = date, yend = position)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 1) +
  geom_label(
    aes(x = date, y = position, label = version, color = status),
    show.legend = FALSE
  ) +
  geom_point(aes(x = date, y = 0, color = status),
    size = 3, show.legend = FALSE
  ) +
  geom_text(
    data = month_dat,
    aes(x = date, y = 0, label = month), vjust = 1.5
  ) +
  geom_text(
    data = year_dat,
    aes(x = date, y = 0, label = year), vjust = -0.5
  ) +
  theme_void()
```

图中红色标注的是里程碑式的重大版本，绿色标注的是主要版本，蓝色标注的次要版本，小修小补，小版本更新。


当时间跨度非常大时，比如过去 25 年，那就只能放重大版本和主要版本信息了，时间上月份信息就不能用名称简写，而用数字更加合适。而且还得竖着放，同时添加那个版本最有影响力的改动。相比于，棋盘图，这是时间线图的优势。


```{r}
#| label: fig-rversion-major
#| fig-cap: "25 年里 R 软件重大及主要版本发布情况"
#| fig-width: 6
#| fig-height: 8
#| fig-showtext: true

sub_rversion_df2 <- rversion_df[rversion_df$status %in% c("big", "major"), ]
ggplot(data = sub_rversion_df2) +
  geom_segment(aes(x = 0, y = date, xend = position, yend = date, color = status),
    show.legend = F
  ) +
  geom_vline(xintercept = 0, color = "black", linewidth = 1) +
  geom_label(
    aes(x = position, y = date, label = version, color = status),
    show.legend = FALSE
  ) +
  geom_point(aes(x = 0, y = date, color = status), size = 3, show.legend = FALSE) +
  geom_text(
    aes(x = 0, y = as.Date(format(date, "%Y-01-01")), label = year),
    hjust = -0.1
  ) +
  theme_void()
```

在 R 语言诞生的前 5 年里，每年发布 3 个主要版本，这 5 年是 R 软件活跃开发的时期。而 2003-2012 年的这 10 年，基本上每年发布 2 个主要版本。2013-2022 年的这 10 年，基本上每年发布 1 个主要版本。


[timevis](https://github.com/daattali/timevis) 包基于 JavaScript 库 [Vis](https://visjs.org/) 的 [vis-timeline](https://github.com/visjs/vis-timeline) 模块，可以 创建交互式的时间线图，支持与 Shiny 应用集成。


## 描述分布 {#sec-visualize-data-distribution}

数据来自中国国家统计局发布的2021年统计年鉴，各省、直辖市和自治区分区域的性别比数据（部分）情况见 @tbl-province-sex-ratio 。

```{r}
#| label: tbl-province-sex-ratio
#| tbl-cap: "各省、直辖市和自治区分区域的性别比数据（部分）"
#| echo: false

province_sex_ratio <- readRDS(file = "data/china-sex-ratio-2020.rds")
knitr::kable(head(province_sex_ratio))
```



### 箱线图 {#sec-boxplot}



```{r}
#| label: fig-boxplot-gg
#| fig-cap: "箱线图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_boxplot() +
  theme_classic()
```

@fig-boxplot-lv 是箱线图的变体 [@Tukey1978]

```{r}
#| label: fig-boxplot-lv
#| fig-cap: "箱线图的变体"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

library(lvplot)
ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_lv() +
  theme_classic()
```




箱线图的历史有 50 多年了，它的变体也有很多。

```{r}
#| label: fig-boxplot-base
#| fig-cap: "箱线图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true
#| par: true

boxplot(`性别比（女=100）` ~ `区域` , data = province_sex_ratio)
```




### 提琴图 {#sec-violin}


```{r}
#| label: fig-violin-gg
#| fig-cap: "提琴图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin(fill = "lightgray", draw_quantiles = c(0.25, 0.5, 0.75)) +
  theme_classic()
```



```{r}
#| label: fig-violin-vioplot
#| fig-cap: "提琴图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true
#| par: true

vioplot::vioplot(`性别比（女=100）` ~ `区域`,
  data = province_sex_ratio, col = "lightgray"
)
```

beanplot 的名字是根据图形的外观取的，豌豆，rug 用须线表示数据


```{r}
#| label: fig-violin-beanplot
#| fig-cap: "提琴图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true
#| par: true

beanplot::beanplot(`性别比（女=100）` ~ `区域`,
  data = province_sex_ratio, col = "lightgray", log = "",
  xlab = "区域", ylab = "性别比（女=100）"
)
```



### 直方图 {#sec-histogram}


```{r}
#| label: fig-histogram
#| fig-cap: "直方图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, fill = `区域`)) +
  geom_histogram(binwidth = 5, color = "white", position = "stack") +
  theme_classic()
```


```{r}
#| label: fig-freqpoly
#| fig-cap: "直方图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, color = `区域`)) +
  geom_freqpoly(binwidth = 5, stat = "bin") +
  theme_classic()
```


### 密度图 {#sec-density}

@fig-density 展示分组密度曲线图

```{r}
#| label: fig-density
#| fig-cap: "密度图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`)) +
  geom_density(aes(fill = `区域`), alpha = 0.5) +
  theme_classic()
```


@fig-density-stack 丢失边际密度

```{r}
#| label: fig-density-stack
#| fig-cap: "堆积密度图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = after_stat(density))) +
  geom_density(aes(fill = `区域`), position = "stack", alpha = 0.5) +
  theme_classic()
```

:::{.callout-caution}
Stacked density plots: if you want to create a stacked density plot, you probably want to 'count' (density * n) variable instead of the default density
:::


@fig-density-count 保护边际密度

```{r}
#| label: fig-density-count
#| fig-cap: "累积分布密度图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = after_stat(density * n))) +
  geom_density(aes(fill = `区域`), position = "stack", alpha = 0.5) +
  theme_classic()
```

什么原因导致 @fig-density-count 和 @fig-density-stack 看起来没什么差别呢？而换一组数据，就可以看出明显的差别，条件密度曲线 @fig-density-count


```{r}
#| label: fig-density-diamonds
#| fig-cap: "堆积密度图"
#| fig-width: 6
#| fig-height: 7.5
#| fig-showtext: true

p1 <- ggplot(diamonds, aes(x = carat, y = after_stat(density), fill = cut)) +
  geom_density(position = "stack") +
  theme_classic()

p2 <- ggplot(diamonds, aes(x = carat, y = after_stat(density * n), fill = cut)) +
  geom_density(position = "stack") +
  theme_classic()

p3 <- ggplot(diamonds, aes(x = carat, y = after_stat(count), fill = cut)) +
  geom_density(position = "stack") +
  theme_classic()

library(patchwork)
p1 / p2 / p3
```

联合密度曲线

```{r}
#| label: fig-density-2d
#| fig-cap: "二维密度图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

state_x77 <- data.frame(state.x77,
  state_name = rownames(state.x77),
  state_region = state.region,
  check.names = FALSE
)
p1 <- ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point() +
  geom_density_2d(aes(
    color = after_stat(level),
    alpha = after_stat(level)
  ),
  show.legend = F
  ) +
  scale_color_viridis_c(option = "inferno") +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局"
  ) +
  theme_classic() +
  theme(
    panel.grid = element_line(colour = "gray92"),
    panel.grid.major = element_line(linewidth = rel(1.0)),
    panel.grid.minor = element_line(linewidth = rel(0.5))
  )
p1
```

**ggExtra** 包[@ggExtra2022] 添加边际密度曲线和边际直方图

```{r}
#| label: fig-margins
#| fig-cap: "描述边际分布"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggExtra)
ggMarginal(p1, type = "density")
ggMarginal(p1, type = "histogram")
```

**ggplot2** 包提供二维密度图层 `geom_density_2d_filled()` 绘制热力图， [**ggdist**](https://github.com/mjskay/ggdist) [@ggdist2022] 进行了一些扩展。

```{r}
#| label: fig-density-2d-filled
#| fig-cap: "二维密度图"
#| fig-width: 5.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_density_2d_filled() +
  theme_classic() +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局"
  )
```

相比于 **ggplot2** 内置的二维核密度估计，[**ggdensity**](https://github.com/jamesotto852/ggdensity/) [@ggdensity2022] 有一些优势，根据数据密度将目标区域划分，更加突出层次和边界。[gghdr](https://github.com/Sayani07/gghdr) 与 ggdensity 类似，展示 highest density regions (HDR)


```{r}
#| label: fig-density-hdr
#| fig-cap: "二维密度图"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggdensity)
ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point() +
  geom_hdr() +
  theme_classic() +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局"
  )
```


### 岭线图 {#sec-ridge-line}

叠嶂图，还有些其它名字，如峰峦图、岭线图等，详情参考统计之都主站[《叠嶂图的前世今生》](https://cosx.org/2018/04/ridgeline-story/)，主要用来描述数据的分布情况，在展示分布的对比上效果非常好。


@fig-ridge-line 设置窗宽为 1.5 个百分点

```{r}
#| label: fig-ridge-line
#| fig-cap: "描述数据分布"
#| fig-subcap: 
#|   - 岭线图
#|   - 岭线图和抖动图组合
#|   - 岭线图和轴须图组合
#| fig-ncol: 2
#| fig-width: 4.5
#| fig-height: 3.5
#| echo: false
#| fig-showtext: true


library(ggridges)

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(bandwidth = 1.5, alpha = 0.7) +
  theme_classic()

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(bandwidth = 1.5, jittered_points = TRUE, alpha = 0.7) +
  theme_classic()

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(
    bandwidth = 1.5,
    jittered_points = TRUE,
    position = position_points_jitter(height = 0),
    point_shape = "|", point_size = 3,
    point_alpha = 1, alpha = 0.7
  ) +
  theme_classic()
```

:::{.callout-tip}
除了中国国家统计年鉴，各省、自治区、直辖市及各级统计局每年都会发布一些统计年鉴、公告等数据，读者可以在此基础上继续收集更多数据，来分析诸多有意思的问题：

1. 城市、镇和乡村男女性别比呈现差异化分布的成因。
1. 城市、镇和乡村男女年龄构成。
1. 将上述问题从省级下钻到市、县级来分析。
:::




### 抖动图 {#sec-jitter}

散点图展示原始数据


```{r}
#| label: fig-point
#| fig-cap: "散点图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_point() +
  theme_classic()
```

:::{.callout-tip}
Base R 函数 `stripchart()` 可以实现类似 @fig-point 的效果。

```{r}
#| label: fig-point-stripchart
#| fig-cap: "散点图"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true
#| par: true

stripchart(`性别比（女=100）` ~ `区域`,
  vertical = TRUE, pch = 1,
  data = province_sex_ratio,
  xlab = "区域"
)
```
:::


抖动图展示原始数据

```{r}
#| label: fig-jitter
#| fig-cap: "抖动图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_jitter(width = 0.25) +
  theme_classic()
```

@SinaPlot2018 提出一种新的方式描述数据的分布，集合抖动图和小提琴图的功能，在给定的分布界限内抖动

```{r}
#| label: fig-sina
#| fig-cap: "加强版的抖动图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

library(ggforce)
ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_sina() +
  theme_classic()
```

数据点受 violin 的曲线限制

```{r}
#| label: fig-sina-violin
#| fig-cap: "加强版的抖动图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin() +
  geom_sina() +
  theme_classic()
```

蜂群图也是某种形式的抖动图

```{r}
#| label: fig-beeswarm
#| fig-cap: "加强版的抖动图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

library(ggbeeswarm)
ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_quasirandom() +
  theme_classic()
```

添加 violin 作为参考边界，与 sina 是非常类似的

```{r}
#| label: fig-beeswarm-violin
#| fig-cap: "加强版的抖动图"
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin() +
  geom_quasirandom() +
  theme_classic()
```

函数 `geom_beeswarm()` 提供了另一种散点的组织方式，按一定的规则，而不是近似随机的方式组织

```{r}
#| eval: false

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin() +
  geom_beeswarm() +
  theme_classic()
```


## 描述对比 {#sec-visualize-data-comparisons}

数据来自中国国家统计局发布的2021年统计年鉴，

```{r}
#| label: tbl-china-age-sex
#| tbl-cap: "中国各年龄段的性别比数据（部分）"
#| echo: false

china_age_sex = readRDS(file = "data/china-age-sex-2020.rds")
knitr::kable(head(china_age_sex))
```

对比的是什么？城市、镇和乡村的性别分布，是否失衡？在哪个年龄段表现很失衡？


### 柱形图 {#sec-column}


分年龄段比较城市、镇和乡村的性别比数据


```{r}
#| label: fig-column
#| fig-cap: "分年龄段比较城市、镇和乡村的性别比数据"
#| fig-width: 7.5
#| fig-height: 4.5
#| fig-showtext: true

ggplot(data = china_age_sex, aes(x = `年龄`, y = `性别比（女=100）`, fill = `区域`)) +
  geom_hline(yintercept = 100, color = "gray", lty = 2, linewidth = 1) +
  geom_col(position = "dodge2", width = 0.75) +
  theme_bw()
```

考虑到数据本身的含义，一般来说，性别比不可能从 0 开始，除非现实中出现了《西游记》里的女儿国。因此，将纵轴的范围，稍加限制，从 性别比为 70 开始，目的是突出城市、镇和乡村的差异。

```{r}
#| label: fig-column-better
#| fig-cap: "分年龄段比较城市、镇和乡村的性别比数据"
#| fig-width: 7.5
#| fig-height: 4.5
#| fig-showtext: true

ggplot(data = china_age_sex, aes(x = `年龄`, y = `性别比（女=100）`, fill = `区域`)) +
  geom_hline(yintercept = 100, color = "gray", lty = 2, linewidth = 1) +
  geom_col(position = "dodge2", width = 0.75) +
  coord_cartesian(ylim = c(70, 130)) +
  theme_bw()
```



### 条形图 {#sec-barchart}

将柱形图横过来即可得到条形图，横过来的好处主要体现在分类很多的时候，留足空间给年龄分组的分类标签，从左到右，从上往下也十分符合大众的阅读习惯

```{r}
#| label: fig-barchart
#| fig-cap: "分年龄段比较城市、镇和乡村的性别比数据"
#| fig-width: 6
#| fig-height: 5.5
#| fig-showtext: true

ggplot(data = china_age_sex, aes(x = `性别比（女=100）`, y = `年龄`, fill = `区域`)) +
  geom_vline(xintercept = 100, color = "gray", lty = 2, linewidth = 1) +
  geom_col(position = "dodge2", width = 0.75) +
  coord_cartesian(xlim = c(70, 130)) +
  theme_bw()
```






### 点线图 {#sec-cleveland}

<!-- 克利夫兰点图 dotchart 在条形图的基础上，省略了条形图的宽度，可以容纳更多的数据点。 -->

```{r}
#| label: fig-dotchart
#| fig-cap: "分年龄段比较城市、镇和乡村的性别比数据"
#| fig-width: 5.5
#| fig-height: 5.5
#| fig-showtext: true

ggplot(data = china_age_sex, aes(x = `性别比（女=100）`, y = `年龄`, color = `区域`)) +
  geom_vline(xintercept = 100, color = "lightgray", lty = 2, linewidth = 1) +
  geom_point() +
  theme_bw()
```


### 雷达图 {#sec-radar}

<!-- 多元数据，30多个省份多个指标的对比，观察潜力 -->

[ggradar](https://github.com/ricardo-bion/ggradar) 包绘制雷达图对比美国三个州的数据，根据人口密度，从 state.x77 选择康涅狄格州 Connecticut， 马塞诸塞州 Massachusetts， 新泽西州 New Jersey，比较它们的人均收入 Income，文盲率 Illiteracy， 预期寿命 Life Exp，谋杀率 Murder 和高中毕业率 HS Grad。 函数 `ggradar()` 要求数据集各个比较的变量归一化到 0-1 区间。

```{r}
#| label: fig-state-x77-comp
#| fig-cap: "康涅狄格州、马塞诸塞州、新泽西州的比较"
#| fig-width: 7.5
#| fig-height: 4
#| fig-showtext: true
#| warning: false

state_x77 <- data.frame(state.x77,
  state_name = rownames(state.x77),
  state_region = state.region,
  check.names = FALSE
)
state_x77_sub <- state_x77[
  c("Connecticut", "Massachusetts", "New Jersey"),
  c("Income", "Illiteracy", "Life Exp", "Murder", "HS Grad")
]
state_x77_scale <- apply(state_x77_sub, 2, scales::rescale)
state_x77_comp <- data.frame(state = rownames(state_x77_scale), state_x77_scale)

library(ggradar)
ggradar(plot.data = state_x77_comp, base.size = 13, legend.position = "right")
```




### 词云图 {#sec-wordcloud}


<!-- 
根据代码提交的说明制作词云图。根据各位开发者提交的代码量制作
-->


词云图帮助我们从众多的因素中展现出影响力比较大的主题。目前，R 语言社区官方发布的 R 包超过 18000 个，这些 R 包都是干什么的呢？热门的方向是什么呢？根据 R 包的标题内容分词，统计词频就可以帮助我们初步了解一些信息。



[ggwordcloud](https://github.com/lepennec/ggwordcloud) 包提供词云图层 `geom_text_wordcloud()`



```{r}
#| label: fig-wordcloud
#| fig-cap: "词云图"
#| fig-width: 7
#| fig-showtext: true
#| fig-asp: 0.618
#| fig-dpi: 96

library(ggwordcloud)

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |> 
  ggplot(aes(label = author, size = revision)) +
  geom_text_wordcloud(seed = 2022, grid_size = 1, max_grid_size = 24) +
  scale_size_area(max_size = 20) +
  theme_minimal()
```


词云图也可以是条形图或柱形图的一种替代，词云图不用担心数目多少，而条形图不适合太多的分类情形。


```{r}
#| label: fig-trunk-author
#| fig-cap: "开发者提交量排行榜"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |>
  subset(subset = revision >= 100) |> 
  ggplot(aes(x = revision, y = reorder(author, revision))) +
  geom_col() +
  theme_classic() +
  coord_cartesian(expand = FALSE) +
  labs(x = "提交量", y = "维护者")
```



## 描述占比 {#sec-visualize-data-proportion}


### 简单饼图 {#sec-naive-pie}




```{r}
#| label: fig-pie
#| fig-cap: "维护者提交量占比"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |>
  transform(author2 = ifelse(revision < 2000, "Others", author)) |>
  aggregate(revision ~ author2, FUN = sum) |>
  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, "%")) |>
  ggplot(aes(x = 1, fill = reorder(author2, revision), y = revision)) +
  geom_col(position = "fill", show.legend = FALSE, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  coord_polar(theta = "y") +
  geom_text(aes(x = 1.2, label = author2),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  geom_text(aes(x = 1.65, label = label),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  theme_void() +
  labs(x = NULL, y = NULL)
```

在分类很多的情况下，占比小的，显得十分拥挤

```{r}
#| label: fig-pie-bad
#| fig-cap: "维护者提交量占比"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |> 
  transform(author2 = ifelse(revision < 1000, "Others", author)) |> 
  aggregate(revision ~ author2, FUN = sum) |> 
  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, "%")) |> 
  ggplot(aes(x = 1, fill = reorder(author2, revision)  , y = revision)) +
  geom_col(position = "fill", show.legend = FALSE, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  coord_polar(theta = "y") +
  geom_text(aes(x = 1.2, label = author2),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  geom_text(aes(x = 1.6, label = label),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  theme_void() +
  labs(x = NULL, y = NULL)
```

一种缓解办法是添加注释 

```{r}
#| label: fig-pie-repel
#| fig-cap: "维护者提交量占比"
#| fig-width: 6.5
#| fig-height: 5
#| fig-showtext: true

library(ggrepel)
dat1 <- aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |>
  transform(author2 = ifelse(revision < 1000, "Others", author)) |>
  aggregate(revision ~ author2, FUN = sum)

dat2 <- within(dat1, {
  value <- 100 * revision / sum(revision)
  csum <- rev(cumsum(rev(value)))
  pos <- value / 1.5 + c(csum[-1], NA)
  pos <- ifelse(is.na(pos), value / 2, pos)
  label <- paste(author2, paste0(round(value, 2), "%"), sep = "\n")
})

ggplot(data = dat2, aes(x = 1, fill = author2, y = value)) +
  geom_col(show.legend = FALSE, color = "white") +
  coord_polar(theta = "y") +
  geom_label_repel(aes(y = pos, label = label), 
    size = 4.5, nudge_x = 0.75, show.legend = FALSE
  ) +
  theme_void() +
  labs(x = NULL, y = NULL)
```


但是数量很多的情况下，也是无能为力的，当然，是否需要显示那么多，是否可以合并占比小的部分，也是值得考虑的问题。





### 环形饼图 {#sec-ring-pie}

中间空了一块


```{r}
#| label: fig-ring-pie
#| fig-cap: "维护者提交量占比"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |> 
  transform(author2 = ifelse(revision < 2000, "Others", author)) |> 
  aggregate(revision ~ author2, FUN = sum) |> 
  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, "%")) |> 
  ggplot(aes(x = 1, fill = author2, y = revision)) +
  geom_col(position = "fill", show.legend = FALSE, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  coord_polar(theta = "y") +
  geom_text(aes(x = 1.2, label = author2),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  geom_text(aes(x = 1.7, label = label),
    position = position_fill(vjust = 0.5), color = "black"
  ) +
  theme_void() +
  labs(x = NULL, y = NULL) +
  xlim(c(0.2, 1.7))
```


### 扇形饼图 {#sec-sector-pie}

扇形饼图又叫风玫瑰图或南丁格尔图

```{r}
#| label: fig-wind-rose
#| fig-cap: "维护者提交量分布"
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |> 
  transform(author2 = ifelse(revision < 2000, "Others", author)) |> 
  aggregate(revision ~ author2, FUN = sum) |> 
  ggplot(aes(x = reorder(author2, revision), y = revision)) +
  geom_col(aes(fill = author2), show.legend = FALSE) +
  coord_polar() +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +
  labs(x = NULL, y = NULL)
```




### 帕累托图 {#sec-pareto}

<!-- 
https://en.wikipedia.org/wiki/Vilfredo_Pareto
描述各个部分的占比，特别是关键要素的占比
收入服从帕累托分布，这是一个幂率分布
80% 的财富集中在 20% 的人的手中
构造几何统计图层 geom_pareto
多边形、点线、双轴
-->

开发者们的贡献量

```{r}
#| label: fig-pareto-stack
#| fig-cap: "代码提交量的比例趋势"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

aggregate(data = svn_trunk_log, revision ~ year + author, FUN = length) |> 
  ggplot(aes(x = year, y = revision, fill = author)) +
  geom_col() +
  theme_classic() +
  coord_cartesian(expand = FALSE) +
  labs(x = "年份", y = "提交量", fill = "开发者")
```

比例趋势图

```{r}
#| label: fig-pareto-fill
#| fig-cap: "代码提交量的比例趋势"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

aggregate(data = svn_trunk_log, revision ~ year + author, FUN = length) |> 
  ggplot(aes(x = year, y = revision, fill = author)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  theme_classic() +
  coord_cartesian(expand = FALSE) +
  labs(x = "年份", y = "提交量", fill = "开发者")
```

帕累托图

```{r}
#| label: fig-pareto
#| fig-cap: "代码提交量的比例分布"
#| fig-showtext: true

dat <- aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |>
  transform(author = ifelse(revision < 1000, "Others", author)) |>
  aggregate(revision ~ author, FUN = sum)
dat <- dat[order(-dat$revision), ]

ggplot(data = dat, aes(
  x = reorder(author, revision, decreasing = T),
  y = revision
)) +
  geom_col(width = 0.75) +
  geom_line(aes(y = cumsum(revision), group = 1)) +
  geom_point(aes(y = cumsum(revision))) +
  theme_classic() +
  labs(x = "维护者", y = "累计提交量")
```




### 马赛克图 {#sec-mosic}

<!-- 多个分类变量 -->

```{r}
#| label: fig-mosaic
#| fig-cap: "加州伯克利分校院系录取情况"
#| fig-width: 7
#| fig-height: 5
#| fig-showtext: true
#| warning: false

library(ggmosaic)
ggplot(data = as.data.frame(UCBAdmissions)) +
  geom_mosaic(aes(
    x = product(Dept, Gender),
    weight = Freq, fill = Admit
  )) +
  theme_minimal()
```


:::{.callout-tip}
Base R 提供函数 `plot()` 和 `mosaicplot()` 对 `table` 表格类型的数据可视化，提供一套公式绘图语法，可以绘制类似的马赛克图。

```{r}
#| label: fig-mosaic-base
#| fig-width: 7
#| fig-height: 5
#| fig-cap: "加州伯克利分校院系录取情况"
#| fig-showtext: true
#| echo: true
#| par: true
#| eval: false

mosaicplot(~ Gender + Dept + Admit,
  data = UCBAdmissions, color = TRUE,
  main = "", xlab = "性别", ylab = "院系"
)
```

对于多维列联表数据，Base R 提供函数 `loglin()` 拟合对数线性模型，以获取更加定量的结果。更进一步，**MASS** 包在函数 `loglin()` 的基础上，打包了另一个函数 `loglm()` ，它提供与函数 `lm()` 和 `glm()` 相一致的公式语法，使用起来更加方便。当然，函数 `glm()` 本身也是可以拟合对数线性模型的，毕竟它也是一种特殊的广义线性模型。
:::

### 矩阵树图 {#sec-treemap}

<!-- 
有层次的占比
-->

```{r}
#| eval: true
#| echo: false
#| label: tbl-g20
#| tbl-cap: "G20 国家经济水平：GDP 总量、人类发展指数等"

library(treemapify)
data("G20")
knitr::kable(head(G20), col.names = c(
  "区域", "国家", "GDP",
  "人类发展指数", "经济水平", "所属半球"
))
```


```{r}
#| label: fig-treemap
#| fig-cap: "G20 主要经济体"
#| fig-width: 7
#| fig-height: 6
#| fig-showtext: true

library(treemapify)
ggplot(G20, aes(
  area = gdp_mil_usd, fill = region,
  label = country, subgroup = region
)) +
  geom_treemap() +
  geom_treemap_text(grow = T, reflow = T, colour = "black") +
  facet_wrap(~hemisphere) +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom") +
  labs(title = "G20 主要经济体", fill = "区域")
```

每个瓦片的大小代表国家的 GDP 在所属半球里的比重。



## 描述关系 {#sec-visualize-data-relation}




### 散点图 {#sec-scatter}


<!-- 
在介绍 ggplot2 的基础知识时，已经介绍过绘制过程，本节是否还有必要介绍，如果介绍应该怎么介绍？

散点图的历史，主要作用
展示原始的数据，关系

点的形态、大小、颜色等都可以变化
-->

中国国家统计局 2021 年发布的统计年鉴，2020 年 31 个省、直辖市、自治区，抚养比、文盲率、人口数的关系

```{r}
#| label: tbl-china-raise-illiteracy
#| tbl-cap: "2020 年各省、直辖市、自治区，总抚养比和文盲率相关数据（部分）"
#| echo: false

china_raise_illiteracy <- readRDS(file = "data/china-raise-illiteracy-2020.rds")
knitr::kable(head(china_raise_illiteracy[order(china_raise_illiteracy$`人口数`, decreasing = TRUE), ]),
  col.names = c(
    "地区", "人口数", "15-64岁", "抚养比",
    "15岁及以上人口", "文盲人口", "文盲率"
  ),
  row.names = FALSE
)
```

其中，文盲人口是指15岁及以上不识字及识字很少人口，文盲率 = 文盲人口 / 15岁及以上人口，抚养比 = (0-14岁 + 65岁及以上) / 15-64岁人口数。

```{r}
#| label: fig-china-raise-illiteracy
#| fig-cap: "文盲率与抚养比的关系"
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true

ggplot(data = china_raise_illiteracy) +
  geom_point(aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)) +
  theme_classic() +
  labs(x = "抚养比（%）", y = "文盲率（%）")
```


### 气泡图 {#sec-bubble}

<!-- 
散点图的历史，主要作用
-->


```{r}
#| label: fig-china-raise-illiteracy-bubble
#| fig-cap: "文盲率和抚养比数据"
#| fig-width: 6
#| fig-height: 4.5
#| fig-showtext: true

library(ggrepel)
library(scales)
ggplot(
  data = china_raise_illiteracy,
  aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)
) +
  geom_point(aes(size = `人口数`, color = `人口数`),
    alpha = 0.85, pch = 16,
    show.legend = c(color = FALSE, size = TRUE)
  ) +
  scale_size(labels = label_number(scale_cut = cut_short_scale())) +
  scale_color_viridis_c(option = "C") +
  geom_text_repel(
    aes(label = `地区`),
    size = 3, max.overlaps = 50,
    segment.colour = "gray", seed = 2022, show.legend = FALSE
  ) +
  coord_cartesian(xlim = c(30, 60), ylim = c(0, 10.5), expand = FALSE) +
  theme_classic() +
  labs(x = "抚养比（%）", y = "文盲率（%）")
```


### 凹凸图 {#sec-bump}

<!-- 
凹凸图描述的是一种转化、变化关系，排序的变化

待议是否适合放在描述关系一节

排序位置变化，一段时间到另一段时间，比如话题热度的转变，比如今年国庆与去年国庆
空间移动，路径移动，强调位置的移动
-->

[ggbump](https://github.com/davidsjoberg/ggbump)

```{r}
#| label: fig-bump
#| fig-cap: "凹凸图"
#| fig-width: 7
#| fig-height: 3.5
#| fig-showtext: true
#| warning: false

library(ggbump)

df <- data.frame(
  country = c(
    "India", "India", "India", "Sweden",
    "Sweden", "Sweden", "Germany", "Germany",
    "Germany", "Finland", "Finland", "Finland"
  ),
  year = c(
    2011, 2012, 2013, 2011,
    2012, 2013, 2011, 2012,
    2013, 2011, 2012, 2013
  ),
  value = c(
    492, 246, 246, 369,
    123, 492, 246, 369,
    123, 123, 492, 369
  )
)

library(data.table)
df <- as.data.table(df)
df[, rank := rank(value, ties.method = "random"), by = "year"]

ggplot(df, aes(year, rank, color = country)) +
  geom_point(size = 7) +
  geom_text(data = df[df$year == min(df$year), ],
            aes(x = year - .1, label = country), size = 5, hjust = 1) +
  geom_text(data = df[df$year == max(df$year), ],
            aes(x = year + .1, label = country), size = 5, hjust = 0) +
  geom_bump(linewidth = 2, smooth = 8) +
  scale_x_continuous(limits = c(2010.6, 2013.4),
                     breaks = seq(2011, 2013, 1)) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        panel.grid.major = element_blank()) +
  labs(y = "RANK", x = NULL) +
  scale_y_reverse()
```



### 韦恩图 {#sec-venn-diagram}

<!-- 
描述交叉关系
部分和整体的关系
https://r-charts.com/part-whole/ggvenndiagram/
-->

[ggVennDiagram](https://github.com/gaospecial/ggVennDiagram/)

A、B、C 三个集合的交叉关系

```{r}
#| label: fig-venn
#| fig-cap: "A、B、C 三个集合的交叉关系"
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

x <- list(A = 1:5, B = 2:7, C = 5:10)
ggVennDiagram::ggVennDiagram(x) +
  scale_fill_gradient(low = "#F4FAFE", high = "#4981BF")
```


### 甘特图 {#sec-gantt}

<!-- 
描述依赖关系 

项目管理也是数据分析应有的内容，与之相关的图形，了解和应用好也是重要的
项目依赖关系 
-->


[ganttrify](https://github.com/giocomai/ganttrify)


```{r}
#| label: fig-gant
#| fig-cap: "项目和任务进展"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

library(ganttrify)
ganttrify(project = ganttrify::test_project,
          project_start_date = "2021-03",
          font_family = "sans")
```



### 网络图 {#sec-network}

[ggraph](https://github.com/thomasp85/ggraph)
[tidygraph](https://github.com/thomasp85/tidygraph) 描述依赖关系

```{r}
library(ggraph)
graph <- tidygraph::as_tbl_graph(highschool) |> 
    dplyr::mutate(Popularity = tidygraph::centrality_degree(mode = 'in'))

graph
```

<!-- ggplot2 升级 3.4.0 导致问题 -->

```{r}
#| label: fig-graph
#| fig-cap: "学校关系"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

ggraph(graph, layout = "kk") +
  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) +
  geom_node_point(aes(size = Popularity)) +
  facet_edges(~year) +
  theme_graph(
    base_family = "sans",
    foreground = "steelblue",
    fg_text_colour = "white"
  )
```





## 描述不确定性 {#sec-visualize-data-uncertainty}


<!-- 
可视化不确定性，这属于高级篇内容，阐述一些常用、常见的统计概念
https://github.com/wilkelab/ungeviz
https://wilkelab.org/SDS375/schedule.html

Psychology of Data Visualization 2021 Michael Friendly
http://euclid.psych.yorku.ca/www/psy6135/

Visualizing the uncertainty of point estimates.
Uncertainty is expressed as standard error, confidence interval, or credible interval
https://wilkelab.org/SDS375/slides/visualizing-uncertainty.html#1

[ggdist](https://github.com/mjskay/ggdist) Visualizations of distributions and uncertainty [@ggdist2022]
-->



### 置信区间 {#sec-confidence-interval}

<!-- 
描述点估计的不确定性
二项分布参数 p 的点估计与区间估计，与后续覆盖概率联系起来
-->



| 0 | 1 | 2 | $\cdots$ | n |
|:--|:---|:---|:---|:---|
| $p_0$ | $p_1$ | $p_2$ | $\cdots$ | $p_n$ |

: 二项分布的分布列 {#tbl-binom}



二项分布 $\mathrm{Bin}(n,p)$ 的参数 $p$ 的精确区间估计如下：

$$
(B(\frac{\alpha}{2}; x, n-x+1), B(1-\frac{\alpha}{2}; x+1, n-x))
$$ {#eq-clopper-ci}

$x$ 是成功次数，$n$ 是实验次数，$B(p;v,w)$ 是形状参数为 v 和 w 的 Beta 分布的 p 分位数，p 的置信区间的上下限 $P_L,P_U$ 满足


\begin{align}
\frac{\Gamma(n+1)}{\Gamma(x)\Gamma(n-x+1)}\int_{0}^{P_L}t^{x-1}(1-t)^{n-x}\mathrm{dt} &= \frac{\alpha}{2} \\
\frac{\Gamma(n+1)}{\Gamma(x+1)\Gamma(n-x)}\int_{0}^{P_U}t^{x}(1-t)^{n-x-1}\mathrm{dt} &= 1-\frac{\alpha}{2}
\end{align}


$p_x$ 表示二项分布 $\mathrm{Bin}(n,p)$ 第 $x$ 项的概率，$x$ 的取值为 $0,1,\cdots,n$

$$p_x = \binom{n}{x}p^x(1-p)^{n-x}, \quad x = 0,1,\cdots,n$$

二项分布的累积分布函数和 $S_k$ 表示前 $k$ 项概率之和

$$S_k = \sum_{x=0}^{k} p_x$$

$S_k$ 服从形状参数为 $n-k,k+1$ 的贝塔分布 $I_x(a,b)$，对应于 R 函数 `pbeta(x,a,b)`。 $S_k$ 看作贝塔分布的随机变量 $X$

\begin{align}
B_x(a,b) &=\int_{0}^{x}t^{a-1}(1-t)^{b-1}\mathrm{dt} \\
I_x(a,b) &= \frac{B_x(a,b)}{B(a,b)}, \quad B(a,b) = B_1(a,b)
\end{align}

考虑二项总体的参数 $p=0.7$，重复模拟 50 次，每次模拟获得的比例 $\hat{p}$ 及其置信区间，如 @fig-clopper-pearson-ci 所示，置信区间覆盖真值的情况用不同颜色表示，覆盖用 TRUE 表示，没有覆盖用 FALSE 表示

```{r}
#| label: fig-clopper-pearson-ci
#| fig-cap: "Clopper-Pearson 置信区间"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
# Clopper and Pearson (1934)
# 与 binom.test() 计算结果一致
clopper_pearson <- function(p = 0.1, n = 10, nsim = 100) {
  set.seed(2022)
  nd <- rbinom(nsim, prob = p, size = n)
  ll <- qbeta(p = 0.05 / 2, shape1 = nd, shape2 = n - nd + 1)
  ul <- qbeta(p = 1 - 0.05 / 2, shape1 = nd + 1, shape2 = n - nd)
  data.frame(nd = nd, ll = ll, ul = ul, cover = ul > p & ll < p)
}
# 二项分布的参数 p = 0.7
dat <- clopper_pearson(p = 0.7, n = 10, nsim = 50)
# 二项分布的参数的置信区间覆盖真值的情况
ggplot(data = dat, aes(x = 1:50, y = nd / 10, colour = cover)) +
  geom_hline(yintercept = 0.7, lty = 2, linewidth = 1.2, color = "gray") +
  geom_pointrange(aes(ymin = ll, ymax = ul)) +
  theme_classic() +
  labs(x = "第几次模拟", y = "置信区间上下限", color = "覆盖")
```






### 假设检验 {#sec-hypothesis-tests}

<!-- 
描述检验统计假设的不确定性  P 值和功效
对一个统计假设，我有一套方法来检验其正确性，但结论具有不确定性（小概率原理，P 值和风险联系），同一个统计假设，同一组数据，不同的检验方法有不同的 P 值，是检验方法的功效不同。

[ggpubr](https://github.com/kassambara/ggpubr) 制作出版级统计图形，两样本均值的比较
-->

[**ggpval**](https://github.com/s6juncheng/ggpval) 在图上添加检验的 P 值结果，[**ggsignif**](https://github.com/const-ae/ggsignif) [@ggsignif2021] 在图上添加显著性注释。[**ggstatsplot**](https://github.com/IndrajeetPatil/ggstatsplot) [@Indrajeet2021] 可视化统计检验、模型的结果，描述功效变化。


```{r}
#| label: fig-plant-growth
#| echo: true
#| fig-cap: "植物生长"
#| fig-width: 5
#| fig-height: 3.5
#| fig-showtext: true

with(
  aggregate(
    data = PlantGrowth, weight ~ group,
    FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x))
  ),
  cbind.data.frame(weight, group)
) |>
  ggplot(aes(x = group, y = dist_mean)) +
  geom_col(
    position = position_dodge(0.4), width = 0.4, fill = "gray"
  ) +
  geom_errorbar(aes(
    ymin = dist_mean - dist_sd,
    ymax = dist_mean + dist_sd
  ),
  position = position_dodge(0.4), width = 0.2
  ) +
  theme_classic() +
  labs(x = "组别", y = "植物干重")
```

::: {.callout-note}
R 3.5.0 以后，函数 `aggregate()` 的参数 `drop` 默认值为 `TRUE`， 表示扔掉未用来分组的变量，聚合返回的是一个矩阵类型的数据对象。
:::


单因素方差分析

```{r}
oneway.test(data = PlantGrowth, weight ~ group)
```


@fig-signif 展示假设检验的结果

```{r}
#| label: fig-signif
#| fig-cap: "展示假设检验的结果"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggsignif)
ggplot(data = PlantGrowth, aes(x = group, y = weight)) +
  geom_boxplot(width = 0.25) +
  geom_jitter(width = 0.15) +
  geom_signif(comparisons = list(c("ctrl", "trt1"), c("trt1", "trt2")), 
              map_signif_level = function(p) sprintf("p = %.2g", p), 
              textsize = 6, test = "t.test") +
  theme_classic() +
  coord_cartesian(clip = "off")
```


### 模型预测 {#sec-model-predictions}

<!-- 
描述模型预测/曲线拟合的不确定性
趋势拟合和描述关系中添加回归线及置信带

rgl 广义可加模型可视化
https://menugget.blogspot.com/2016/02/visualizing-model-predictions-in-3d.html

[mgcViz](https://github.com/mfasiolo/mgcViz)

Scalable visualisation methods for modern Generalized Additive Models
https://arxiv.org/abs/1809.10632
-->

代码提交量的趋势拟合

```{r}
#| label: fig-smooth
#| fig-cap: "趋势拟合、预测和推断"
#| fig-width: 7
#| fig-height: 4.5
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(aes(color = "LOESS", fill = "LOESS"),
    method = "loess", formula = "y~x",
    method.args = list(
      span = 0.75, degree = 2, family = "symmetric",
      control = loess.control(surface = "direct", iterations = 4)
    ), data = subset(trunk_year, year != c(1997, 2022))
  ) +
  geom_smooth(aes(color = "GAM", fill = "GAM"),
    formula = y ~ s(x, k = 12),
    method = "gam", se = T,
    data = subset(trunk_year, year != c(1997, 2022))
  ) +
  geom_smooth(aes(color = "Cubic Spline", fill = "Cubic Spline"),
                method = "lm", formula = y ~ splines::bs(x, 3), se = T,
              data = subset(trunk_year, year != c(1997, 2022))) +
  scale_color_brewer(name = "模型", palette = "Set1") +
  scale_fill_brewer(name = "模型", palette = "Set1") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



### 模型诊断 {#sec-model-diagnostics}


> 所有模型都是错误的，但有些是有用的。
>
> --- 乔治·博克斯

<!-- 
描述模型拟合数据的不确定性，
Cook 距离、高杠杆值、模型诊断、影响测量
[ggPMX](https://github.com/ggPMXdevelopment/ggPMX) ggplot2 Based Tool to Facilitate Diagnostic Plots for NLME Models
-->

```{r}
#| label: fig-lm-diagnostics
#| fig-cap: "线性模型的诊断图"
#| fig-showtext: true
#| collapse: true
#| fig-width: 7
#| fig-height: 8

state_x77 <- data.frame(state.x77,
  state_name = rownames(state.x77),
  state_region = state.region,
  check.names = FALSE
)
# 模型诊断图
fit <- lm(`Life Exp` ~ Income + Murder, data = state_x77)
op <- par(mfrow = c(3, 2), mar = c(4, 4, 3, 1))
plot(fit,
  ask = FALSE, which = c(1, 2, 3, 4, 5, 6),
  caption = list(
    "残差和拟合值", "正态 Q-Q 图",
    "尺度-位置", "Cook 距离", "残差和杠杆值",
    expression("Cook 距离 vs 杠杆值" * h[ii] / (1 - h[ii]))
  )
)
par(op)
```



### 边际效应 {#sec-marginal-effects}

继续 state_x77 数据集，以预期寿命（1969-1971 年统计）为因变量，Income 人均收入（1974 年）和 Murder 谋杀和非过失杀人率（单位：十万分之一，1976 年统计）为自变量，建立线性模型如下：

$$
\text{Life Exp} = \alpha + \beta_1  \text{Income} + \beta_2 \text{Murder} + \epsilon
$$ {#eq-lm-state-x77}

在 R 语言中，可以用函数 `lm()` 拟合上述模型，

```{r}
fit <- lm(`Life Exp` ~ Income + Murder, data = state_x77)
```

模型拟合结果输出如下：

```{r}
summary(fit)
```

[ggeffects](https://github.com/strengejacke/ggeffects) 描述单个自变量的作用，人均收入对预期寿命的边际效应

```{r}
#| label: fig-marginal-effects
#| fig-cap: "边际效应"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(ggeffects)
income_pred <- ggpredict(fit, terms = "Income")
ggplot(income_pred, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.1) +
  theme_classic() +
  labs(x = "人均收入", y = "预期寿命")
```



### 后验分布 {#sec-posterior-distributions}

<!-- 
描述参数先验分布的不确定性
先验分布与后验分布
描述分布的不确定性 

先验分布 参数的分布
观测分布 给定参数的情况下，数据的分布
后验分布 给定数据的情况下，参数的分布

条件分布、累积分布 [pgog](https://github.com/MUCollective/pgog)
-->


```{r}
#| label: setup-cmdstan
#| echo: false
#| eval: false

# Github Action 已经设置
# Sys.setenv(CMDSTAN="/opt/cmdstan-2.29.2")
# Sys.setenv(CMDSTANR_NO_VER_CHECK=TRUE)
```

以一个最简单的贝叶斯线性模型为例，介绍贝叶斯统计中的后验分布。继续以 state_x77 数据为例，以贝叶斯线性模型拟合数据，获得参数的后验分布。

[Stan](https://github.com/stan-dev) 是一个统计建模和高性能统计计算的平台，广泛应用于社会、生物、物理、工程、商业等领域，提供统计建模、数据分析和预测能力[@Gelman2015]。它提供一套成熟的概率编程语言[@Carpenter2017]，Stan 语言编码的贝叶斯线性模型如下：

```{verbatim, file="code/state_x77.stan", lang="stan"}
```

这里采用汉密尔顿蒙特卡洛算法（HMC）做全贝叶斯推断，下面依次编译模型、准备数据、参数初值和迭代设置。Stan 的 R 语言接口 [**cmdstanr**](https://github.com/stan-dev/cmdstanr) 包可以让这一切在 R 语言环境里做起来比较顺畅。

```{r}
#| label: compile-stan-model
#| message: false
#| results: hide

library(cmdstanr)
# 编译模型
mod_state_x77 <- cmdstan_model(
  stan_file = "code/state_x77.stan",
  compile = TRUE,
  cpp_options = list(stan_threads = TRUE)
)
# 准备数据
state_x77_d <- list(
  N = nrow(state_x77), # 观测记录的条数
  K = 2, # 协变量个数
  x = state_x77[, c("Income", "Murder")], # N x 2 矩阵
  y = state_x77[, "Life Exp"] # N 向量
)
nchains <- 4 # 4 条迭代链
# 给每条链设置不同的参数初始值
inits_data <- lapply(1:nchains, function(i) {
  list(
    alpha = runif(1, 0, 1),
    beta = runif(2, 1, 10),
    sigma = runif(1, 1, 10)
  )
})
# 采样拟合模型
fit_state_x77 <- mod_state_x77$sample(
  data = state_x77_d, # 观测数据
  init = inits_data, # 迭代初值
  iter_warmup = 1000, # 每条链预处理迭代次数
  iter_sampling = 2000, # 每条链总迭代次数
  chains = nchains, # 马尔科夫链的数目
  parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个
  threads_per_chain = 1, # 每条链设置一个线程
  show_messages = FALSE, # 不显示迭代的中间过程
  refresh = 0, # 不显示采样的进度
  seed = 20190425 # 设置随机数种子，不要使用 set.seed() 函数
)
```

:::{.callout-tip}
Stan 还提供自动微分变分推断（ADVI）算法做近似贝叶斯推断获取参数的后验分布，以及拟牛顿法（L-BFGS）优化算法获取参数的惩罚极大似然估计。
:::

模型参数估计结果如下：

```{r}
#| label: tbl-state-x77-output
#| tbl-cap: "贝叶斯线性模型参数估计结果"
#| echo: false

fit_state_x77$summary(c("alpha", "beta[1]", "beta[2]", "sigma", "lp__")) |> 
  knitr::kable(digits = 3)
```

参数的 $\alpha,\beta_1,\beta_2$ 后验均值估计与普通线性模型的拟合结果非常一致。采样结果可以直接传递给 **bayesplot** 包[@Gabry2019]，绘制参数迭代的轨迹图和后验分布图。

```{r}
#| label: fig-post-dists
#| fig-cap: "参数的后验分布和迭代轨迹"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 8.5
#| message: false

library(bayesplot)
# 参数的后验分布
p1 <- mcmc_hist(fit_state_x77$draws(c("alpha", "beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed,
    strip.position = "top",
    ncol = 1
  )
) + theme_classic()
# 参数的迭代轨迹
p2 <- mcmc_trace(fit_state_x77$draws(c("alpha", "beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed,
    strip.position = "top",
    ncol = 1
  )
) + theme_classic() + theme(legend.title = element_blank())
# 绘图
p1 | p2
```

从参数的迭代轨迹可以看出四条马尔可夫链混合得很好，后验分布图主要用来描述参数的迭代结果，后验分布图可以是直方图或密度图的形式，可以和 @tbl-state-x77-output 一道检验模型的拟合情况。


## 描述空间分布 {#sec-visualize-spatial-data}

描述数据的空间分布也是很常见的任务，用于展示区域数据的图形有地区分布图、比例符号图和变形地图等。

空间区域数据 Areal data
:  区域上的聚合，如行政区划、调查区域上的人口计数或男女比率等。

空间点过程数据 Point pattern data
:  空间位置是随机的，如出租车的出行轨迹，其空间位置是随机出现的。

空间点数据/地统计数据 Point-referenced data
:  空间位置是固定的，比如乡村、小区污染物浓度分布，疫苗接种率分布。

下面以 R 软件内置的数据集 state.x77 为例展示 1975 年美国**各州**人口密度 --- 每平方英里的人口数。state.x77 数据集的 Population 列代表州人口数，数据来自 1977 年美国人口调查局发布的统计数据，单位是 1000 人，统计的是 1975 年的人口数据，原始数据可以从官网发布的年度报告[Statistical Abstract of the United States: 1977](https://www.census.gov/library/publications/1977/compendia/statab/98ed.html)获取。


```{r}
library(sf)
# 美国州级多边形边界地图
us_states_map <- readRDS(file = "data/us-states-shifted.rds")
# 将观测数据与地图数据合并
us_states_df <- merge(us_states_map, state_x77,
  by.x = "NAME", by.y = "state_name", all.x = TRUE
)
# 计算人口密度
us_states_df <- within(us_states_df, {
  den <- 1000 * Population / Area
})
```


### 地区分布图 {#sec-choropleth-map}

基于 **sf** 包，**ggplot2** 包提供图层 `geom_sf()` 专门用于绘制空间矢量数据，可以展示空间点、多边形和线等三类常见几何数据。如图 @fig-choropleth-map 所示，展示 1975 年美国各州人口密度（单位：每平方英里人口数）。


```{r}
#| label: fig-choropleth-map
#| fig-cap: "1975 年美国各州人口密度"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
#| echo: true

ggplot() +
  geom_sf(
    data = us_states_df, aes(fill = den),
    color = "gray80", lwd = 0.25
  ) +
  scale_fill_viridis_c(
    trans = "log10", option = "plasma",
    na.value = "white"
  ) +
  labs(
    fill = "人口密度", title = "1975 年美国各州人口密度",
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```

<!-- 
二维地区分布图，预期寿命和人均收入的关系
寿命的长短、收入的高低，用地图展示
-->


### 比例符号图 {#sec-proportional-symbols-map}

1975 年美国各州人口密度，单位为每平方英里人口数，人口密度映射为气泡的面积，美国划分为东北部、南方、西部、中北部四个区域，如 @fig-region-map 所示。

```{r}
#| label: fig-region-map
#| fig-cap: "美国各州的区域划分"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
#| echo: true

ggplot() +
  geom_sf(
    data = us_states_df, fill = NA, aes(color = state_region)
  ) +
  labs(title = "美国各州的区域划分", color = "区域划分", 
       caption = "数据源：美国人口调查局") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```

在 @fig-region-map 的基础上，添加各州州名的缩写，比如 New York 缩写为 NY，这非常类似于我国对各省的简称，比如湖南省简称为湘。

```{r}
#| label: fig-label-map
#| fig-cap: "美国各州的区域划分"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
#| echo: true

ggplot() +
  geom_sf(
    data = us_states_df, fill = NA, aes(color = state_region)
  ) +
  geom_sf_label(data = us_states_df, aes(label = STUSPS), size = 3) +
  labs(
    title = "美国各州的区域划分", color = "区域划分", 
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```

对了解美国地图的人来说，在已有各州边界及区域划分的信息下，在图上添加各州名称就会显得多余，而对缺乏了解的人来说，则是有用的。绘图区域是有限的，信息自然可以越堆越多，关键是这个图形想要传递什么信息，应该优先保障重点突出。此例是以比例符号图展示美国各州人口密度的分布，重点便是展示人口密度数据，如 @fig-proportional-symbols-map 所示。

```{r}
#| label: fig-proportional-symbols-map
#| fig-cap: "1975 年美国各州人口密度"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
#| echo: true

us_states_df <- within(us_states_df, {
  geometry_center <- st_centroid(geometry)
})

library(ggnewscale)
ggplot() +
  geom_sf(
    data = us_states_df, fill = NA, aes(color = state_region)
  ) +
  labs(color = "区域划分") +
  new_scale_color() +
  geom_sf(
    data = us_states_df, 
    aes(geometry = geometry_center, color = den, size = den),
    show.legend = c(color = FALSE, size = TRUE), na.rm = TRUE
  ) +
  scale_color_viridis_c(
    trans = "log10", option = "plasma", na.value = "white"
  ) +
  labs(
    title = "1975 年美国各州人口密度", size = "人口密度", 
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```

在州名数量有限的情况下，特别是用一页纸可以完全展示的情况，还可以考虑用分组条形图替代地区分布图或比例符号图，好处是人口密度的对比更加突出，也避免美国东北部各州因面积小、人口密度大导致的气泡相互重叠的问题。

```{r}
#| label: fig-column-map
#| fig-cap: "1975 年美国各州人口密度"
#| fig-width: 6
#| fig-height: 7
#| fig-showtext: true
#| echo: true
#| warning: false

# 按区域分组后按人口密度排序
us_states_df <- us_states_df[with(us_states_df, order(state_region, -den)), ]
# 添加新列记录排序后的序号
us_states_df$rowid <- 1:nrow(us_states_df)
# 绘图
ggplot(
  data = us_states_df,
  aes(x = den, y = reorder(NAME, rowid, FUN = function(x) 1 / (1 + x)))
) +
  geom_col(aes(fill = state_region)) +
  theme_classic() +
  labs(
    x = "人口密度", y = "州名", fill = "区域划分",
    title = "1975 年美国各州人口密度",
    caption = "数据源：美国人口调查局"
  )
```


### 变形地图 {#sec-cartogram}

变形地图中变形的是多边形地理边界，从而将数据映射到地理区域的面积上。[**cartogram**](https://github.com/sjewo/cartogram) 包提供变形算法构造变形地图，如 @fig-cartogram-map 所示，根据各州的多边形边界地图数据和人口密度数据构造新的多边形边界地图。

```{r}
#| label: fig-cartogram-map
#| fig-cap: "1974 年美国各州人口密度分布"
#| fig-width: 7
#| fig-height: 4
#| fig-showtext: true
#| echo: true
#| message: false
#| warning: false

library(cartogram)
# 构造变形地图
us_states_carto <- cartogram_cont(us_states_df, weight = "den", itermax = 5)
# 绘制变形地图
ggplot(us_states_carto) +
  geom_sf(aes(fill = den), color = "gray80", lwd = 0.25) +
  scale_fill_viridis_c(
    trans = "log10", option = "plasma",
    na.value = "white"
  ) +
  labs(
    fill = "人口密度", title = "1975 年美国各州人口密度",
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```

根据 1974 年各州的人均收入，将收入划分为低收入（低于3500）、中低收入（3500-4500）、中高收入 （4500-5500）、高收入（5500 以上）四档。

```{r}
# 将连续型的收入分段
state_x77$Income_break <- cut(state_x77$Income,
  breaks = 4,
  labels = c("低收入", "中低收入", "中高收入", "高收入")
)
```

[**statebins**](https://github.com/hrbrmstr/statebins) 包以小方块表示美国各州，小方块的位置根据各州的相对位置摆放，各州的边界和面积不再有意义，而小方块的填充色表示数值的大小，如 @fig-state-bins 所示，展示 1974 年美国各州人均收入的空间分布。


```{r}
#| label: fig-state-bins
#| fig-cap: "1974 年美国各州人均收入分布"
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true
#| echo: true

library(statebins)
# 绘制变形地图
ggplot(data = state_x77, aes(state = state_name, fill = Income_break)) +
  geom_statebins() +
  scale_fill_brewer(palette = "RdPu") +
  theme_statebins() +
  labs(title = "1974年美国各州人均收入分布", fill = "收入水平") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.margin = margin(10, 10, 10, 10))
```


### 地形图 {#sec-raster}


地形图用于描述地形地势，则无论山洼、山谷，还是高山、高原，抑或是断崖、峡谷、平原，都一目了然。如 @fig-volcano-lattice 所示，奥克兰 Maunga Whau 火山地形图，图中火山划分为 87 行 61 列的小格子，小格子的长宽都是 10 米，记录格子所处位置的高度，收集整理后形成 volcano 数据集，此所谓的栅格数据。Base R 内置的 volcano 数据集是一个 matrix 类型数据对象。

```{r}
#| label: fig-volcano-lattice
#| fig-cap: "奥克兰火山地形图"
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true
#| echo: true

library(lattice)
levelplot(volcano,
  col.regions = hcl.colors,
  at = 80 + 10 * 0:12,
  scales = list(
    draw = TRUE,
    # 去掉图形上边、右边多余的刻度线
    x = list(alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ),
  xlab = "东西方向",
  ylab = "南北方向"
)
```


**ggplot2** 包提供瓦片图层函数 `geom_tile()` 来可视化栅格数据，而函数 `geom_contour()` 可以根据海拔绘制等高线，如 @fig-volcano-ggplot2 所示，而 [**rayshader**](https://github.com/tylermorganwall/rayshader) 包提供函数 `plot_gg()` 可以将 ggplot2 绘图对象转化为 3D 对象，更多详情见 <https://www.rayshader.com/>。

```{r}
#| label: fig-volcano-ggplot2
#| fig-cap: "奥克兰火山地形图"
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true
#| echo: true

volcano_df <- expand.grid(x = 1:87, y = 1:61)
volcano_df$z <- as.vector(volcano)

ggplot(volcano_df) +
  geom_tile(aes(x = x, y = y, fill = z)) +
  geom_contour(aes(x = x, y = y, z = z), color = "gray20") +
  scale_fill_viridis_c() +
  coord_fixed(expand = FALSE) +
  theme_classic() +
  labs(x = "东西方向", y = "南北方向", fill = "海拔")
```

三维透视图亦可展示地形图，如 @fig-volcano-lattice 所示，用 **lattice** 包绘制火山地形图。

```{r}
#| label: fig-volcano-lattice
#| fig-cap: "lattice 包绘制地形图"
#| fig-width: 6
#| fig-height: 5.5
#| fig-showtext: true

wireframe(volcano,
  drape = TRUE, colorkey = FALSE, shade = TRUE,
  xlab = list("东西方向", rot = 20),
  ylab = list("南北方向", rot = -50),
  zlab = list("高度", rot = 90),
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -.6, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -.8, units = "inches"),
      top.padding = list(x = -1.0, units = "inches")
    )
  ),
  # 设置坐标轴字体大小
  par.settings = list(
    axis.line = list(col = "transparent"),
    fontsize = list(text = 15, points = 10)
  ),
  # z 轴标签旋转 90 度
  scales = list(
    arrows = FALSE, col = "black",
    z = list(rot = 90)
  ), 
  screen = list(z = 30, x = -65, y = 0)
)
```

**plotly** 包可以绘制交互的三维透视图来展示地形。

```{css}
#| label: plotly-modebar
#| echo: false

.modebar {
  display: none !important;
}
```
```{r}
#| label: fig-volcano-plotly
#| fig-cap: "plotly 绘制地形图"
#| eval: !expr knitr::is_html_output(excludes = 'epub')
#| echo: true

plotly::plot_ly(z = ~volcano) |> 
  plotly::add_surface()
```

**rgl** 包绘制的三维散点图亦可展示数据的空间分布。

```{r}
#| label: fig-volcano-rgl
#| fig-cap: "rgl 绘制地形图"
#| eval: !expr knitr::is_html_output(excludes = 'epub')
#| echo: true

# 设置 WebGL 渲染
options(rgl.useNULL = TRUE)
options(rgl.printRglwidget = TRUE)
library(rgl)
# 设置视角 
rgl.viewpoint(
  theta = 30, phi = 45, fov = 30,
  zoom = 1, interactive = TRUE
)
# 将连续型数据向量转化为颜色向量
colorize_numeric <- function(x) {
  scales::col_numeric(palette = "viridis", domain = range(x))(x)
}
# 在数据集 quakes 上添加新的数据 color
volcano_df <- within(volcano_df, {
  color <- colorize_numeric(z)
})
# 绘制图形
with(volcano_df, {
  plot3d(x = x, y = y, z = z, col = color)
})
```

[GDAL](https://github.com/OSGeo/gdal) 支持大量的栅格和矢量空间数据格式，内建的 [EEDAI （Google Earth Engine Data API Image）](https://gdal.org/drivers/raster/eedai.html)驱动通过 Google Earth Engine REST API 获取谷歌地球图像。[**terra**](https://github.com/rspatial/terra) 包的函数 `rast()`和 [**stars**](https://github.com/r-spatial/stars) 包的函数 `read_stars()` 封装了 GDAL 的驱动接口，更多详情见 <https://rspatial.org/terra/>。申请谷歌应用的访问令牌，保存授权文件到本地，设置环境变量 `GOOGLE_APPLICATION_CREDENTIALS` 指向授权文件所在路径。

```{r}
#| eval: false
#| echo: true

# 设置访问令牌
Sys.setenv(GOOGLE_APPLICATION_CREDENTIALS="/home/rstudio/google/ardent-disk-214911-e2616707dd80.json")
# 加载 R 包
library(stars)
# 设置采样参数
rasterio <- list(
  nXOff = 6, nYOff = 6, nXSize = 183, nYSize = 183,
  nBufXSize = 100, nBufYSize = 100, bands = 3
)
# 获取数据
google_earth <- read_stars(
  file.path(
    "EEDAI:projects", "earthengine-public", 
    "assets", "COPERNICUS", "S2",
    "20170430T190351_20170430T190351_T10SEG"
  ),
  proxy = TRUE, # 对于大型 TIFF 数据非常有效
  # sub = 3, # 或 2,3,4
  RasterIO = rasterio # 采样 183x183
)
# 绘图
plot(google_earth)
```

