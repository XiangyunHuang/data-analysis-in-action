# 数值优化 {#sec-numerical-optimization}

```{r}
#| echo: false

source("_common.R")
# 加载 ROI 时不要自动加载插件
Sys.setenv(ROI_LOAD_PLUGINS = FALSE)
```

::: hidden
$$
 \def\bm#1{{\boldsymbol #1}}
$$
:::

本章介绍四类典型的优化问题及 R 语言求解过程。除了 R 软件内置一些数值优化求解器，R 语言社区有大量的运筹优化方面的函数和 R 包。本文将重点介绍 **ROI** 包，它通过插件包对 20 多个 R 包提供统一的调用方式，相当于一个运筹优化方面的基础设施平台，极大地方便学习和使用。本文不能一一概括，仅详述其中两个，求解线性优化（linear optimization）与混合整数优化（mixed integer linear optimization）的 **Rglpk** 包，求解二次优化（quadratic optimization）和非线性优化（nonlinear optimization）的 **nloptr** 包，相信读者之后可以举一反三。

```{mermaid}
%%| label: fig-roi-plugin
%%| fig-width: 6.5
%%| fig-cap: ROI 包、插件包和数值优化 R 包的关系

flowchart TB
  Rglpk --> ROI_Rglpk(ROI.plugin.glpk)
  ROI_Rglpk --> ROI(ROI)
  nloptr --> ROI_nloptr(ROI.plugin.nloptr)
  ROI_nloptr --> ROI(ROI)
  scs --> ROI_lpsolve(ROI.plugin.scs)
  ROI_lpsolve --> ROI(ROI)
  quadprog --> ROI_quadprog(ROI.plugin.quadprog)
  ROI_quadprog --> ROI(ROI)
```

**Rglpk** 包可以求解大规模线性优化，整数优化和混合整数优化，**ROI** 包通过插件包 **ROI.plugin.glpk** 与之连接调用。**nloptr** 包可以求解二次优化和非线性优化，**ROI** 包通过插件包 **ROI.plugin.nloptr** 与之连接调用。**ROI** 包通过插件包来实际调用第三方做数值优化的 R 包。

```{r}
#| message: false

library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.nloptr)
library(ROI.plugin.scs)
library(ROI.plugin.quadprog)
library(lattice)
# 自定义调色板
custom_palette <- function(irr, ref, height, saturation = 0.9) {
  hsv(
    h = height, s = 1 - saturation * (1 - (1 - ref)^0.5),
    v = irr
  )
}
```

## 线性优化 {#sec-linear-optimization}

线性优化是指目标函数和约束条件都是线性的优化问题。

$$
\begin{array}{l}
  \min_x \quad -6x_1 -5x_2 \\
    \text{s.t.} \left\{ 
    \begin{array}{l}
    x_1  + 4x_2 \leq 16\\
    6x_1 + 4x_2 \leq 28\\
    2x_1 - 5x_2 \leq 6
    \end{array} \right.
\end{array}
$$

写成矩阵形式

$$
\begin{array}{l}
\min_x \quad
  \begin{bmatrix}
  -6  \\
  -5
  \end{bmatrix}
  ^{\top} \bm{x} \\
\text{s.t.}\left\{ 
 \begin{array}{l}
  \begin{bmatrix}
  1 & 4  \\
  6 & 4  \\
  2 & -5 
  \end{bmatrix}
  \bm{x} \leq
  \begin{bmatrix}
   16 \\
   28 \\
   6
  \end{bmatrix}
 \end{array} \right.
\end{array} 
$$

```{r}
# 定义优化问题
op <- OP(
  objective = L_objective(c(-6, -5)),
  constraints = L_constraint(
    L = matrix(c(
      1, 4,
      6, 4, 
      2, -5
    ), ncol = 2, byrow = TRUE),
    dir = c("<=", "<=", "<="),
    rhs = c(16, 28, 6)
  ),
  types = c("C", "C"),
  maximum = FALSE
)
# 优化问题描述
op
# 求解优化问题
res <- ROI_solve(op, solver = "glpk")
# 可行解
res$solution
# 目标函数值
res$objval
```

函数 `OP()` 定义一个优化问题，参数如下：

-   `objective` ：线性目标函数的系数，数值型向量。
-   `constraints` ：约束矩阵 $A$ ，约束分量的方向 `>=` 、`<=` 或 `=` ，右手边的向量 $b$ 。
-   `types` ：变量的类型，如 `"B"` 表示 0-1 变量，字母 B 是 binary 的意思，`"I"` 表示整型变量，字母 I 是 integer 的意思，`"C"` 表示数值型变量，字母 C 是 continuous 的意思。本例中，两个变量都是连续型的，`types = c("C", "C")` 。
-   `maximum` ：目标函数需要求极大还是极小，默认求极小，取值为逻辑值 `TRUE` 或 `FALSE`。

## 整数优化 {#sec-integer-linear-optimization}

整数优化分变量取值为 0 或 1 的 0-1 整数优化和带有整数约束的混合整数优化。

### 0-1 整数优化

变量要么是 0 要么是 1

### 混合整数优化 {#sec-mixed-integer-linear-optimization}

一部分变量要求是整数

$$
\begin{array}{l}
  \max_x \quad 3x_1 + 7x_2 - 12x_3 \\
    \text{s.t.}\left\{ 
    \begin{array}{l}
    5x_1 + 7x_2 + 2x_3 \leq 61\\
    3x_1 + 2x_2 - 9x_3 \leq 35\\
    x_1 + 3x_2 + x_3 \leq 31\\
    x_1,x_2 \geq 0, \quad x_2, x_3 \in \mathbb{Z}, \quad x_3 \in [-10, 10]
    \end{array} \right.
\end{array}
$$

矩阵形式如下

$$
\begin{array}{l}
\max_{x} \quad
  \begin{bmatrix}
  3  \\
  7  \\
  -12
  \end{bmatrix}
  ^{\top} \bm{x} \\
\text{s.t.}\left\{ 
 \begin{array}{l}
  \begin{bmatrix}
  5 & 7 & 2 \\
  3 & 2 & -9\\
  1 & 3 & 1
  \end{bmatrix}
  \bm{x} \leq
  \begin{bmatrix}
   61 \\
   35 \\
   31
  \end{bmatrix}
 \end{array} \right.
\end{array} 
$$

第1个变量是连续值，第2、3个变量是整数，第3个变量的下、上界分别是 -10 和 10。

```{r}
op <- OP(
  objective = L_objective(c(3, 7, -12)),
  types = c("C", "I", "I"),
  constraints = L_constraint(
    L = matrix(c(
      5, 7, 2,
      3, 2, -9,
      1, 3, 1
    ), ncol = 3, byrow = TRUE),
    dir = c("<=", "<=", "<="),
    rhs = c(61, 35, 31)
  ),
  # 添加约束
  bounds = V_bound(li = 3, ui = 3, lb = -10, ub = 10, nobj = 3),
  maximum = TRUE
)
op
# 求解
res <- ROI_solve(op, solver = "glpk")
# 最优解
res$solution
res$objval
```

## 凸二次优化 {#sec-quadratic-optimization}

二次优化分严格凸二次和非严格凸二次优化问题，严格凸要求矩阵对称正定，非严格凸要求矩阵对称半正定。对于矩阵负定的情况，不是凸优化问题，暂不考虑。

### 严格凸二次优化

二次优化的一般形式如下：

$$
\begin{aligned}
\min_{\bm{x}} \quad & \frac{1}{2}\bm{x}^{\top}D\bm{x} + \bm{d}^{\top}\bm{x} \\
\text{s.t.} \quad & A\bm{x} \leq \bm{b}
\end{aligned}
$$

二次优化不都是凸优化，当且仅当矩阵 $D$ 半正定时，上述二次规划是凸二次优化，当矩阵 $D$ 正定时，上述二次规划是严格凸二次优化。下面举个严格凸二次规划的具体例子，令

$$
D = \begin{bmatrix}
2 & -1\\
-1 & 2
\end{bmatrix}, \quad
\bm{d} =  
\begin{bmatrix}
3 \\
-2
\end{bmatrix}, \quad
A = \begin{bmatrix}
-1 & -1  \\
1 & -1 \\
0  & 1
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
-2 \\
2 \\
3
\end{bmatrix}
$$

即目标函数

$$
Q(x_1,x_2) = x_1^2 + x_2^2 - x_1 x_2 + 3x_1- 2x_2
$$

二次规划中的数据矩阵和向量 $D,\bm{d},A,\bm{b}$ 依次用 `Dmat`、`dvec`、`Amat`、`bvec` 表示出来。

```{r}
Dmat <- matrix(c(2, -1, -1, 2), nrow = 2, byrow = TRUE)
dvec <- c(3, -2)
Amat <- matrix(c(-1, -1, 1, -1, 0, 1), ncol = 2, byrow = TRUE)
bvec <- c(-2, 2, 3)
```

同样，也是在函数 `OP()`中传递目标函数，约束条件。在函数 `Q_objective()` 中定义二次规划的目标函数，字母 Q 是 Quadratic 的意思，表示二次部分，字母 L 是 Linear 的意思，表示线性部分。函数 `L_constraint()` 的使用同线性优化，不再赘述。根据 **ROI** 包的使用接口定义的参数，定义目标规划。

```{r}
op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(L = Amat, dir = rep("<=", 3), rhs = bvec),
  maximum = FALSE
)
op
```

**nloptr** 包有许多优化求解器，可用于求解二次规划的也有好几个。对于一个目标规划，函数 `ROI_applicable_solvers()` 可以找到能够求解此优化问题的求解器。

```{r}
ROI_applicable_solvers(op)
```

下面使用其中的 `nloptr.slsqp` 来求解。

```{r}
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 2))
nlp$objval
nlp$solution
```

作为对比，移除线性不等式约束，求解无约束优化问题。目标函数仍然是二次型，但是已经没有线性约束条件，所以不是二次规划问题，再用求解器 `nloptr.slsqp` 求解的结果已不是无约束优化的解。

```{r}
op2 <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  maximum = FALSE
)
op2
nlp2 <- ROI_solve(op2, solver = "nloptr.slsqp", start = c(1, 2))
nlp2$objval
nlp2$solution
```

在可行域上画出等高线，标记目标解的位置， @fig-quadprog 展示无约束和有约束条件下的解。图中红点表示无约束下求解器 `nloptr.slsqp` 获得的解 $(0,1)$ ，真正的无约束解是蓝点所在位置为 $(-4/3,1/3)$ ，黄点表示线性约束下求解器 `nloptr.slsqp` 获得的解 $(1/6,11/6)$ 。所以，不能用二次规划的求解器去求解无约束的二次规划问题。

```{r}
#| label: fig-quadprog
#| fig-cap: "对比无约束和有约束条件下的解"
#| fig-width: 5
#| fig-height: 3.33
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

# 约束解
qp_sol <- nlp$solution
# 无约束解
uc_sol <- nlp2$solution
x1 <- seq(-2, 5.5, length.out = 50)
x2 <- seq(-1, 3.5, length.out = 50)
dat <- expand.grid(x1 = x1, x2 = x2)
# 二次规划的目标函数
dat$fn <- with(dat, x1^2 + x2^2 - x1 * x2 + 3 * x1 - 2 * x2)
levelplot(fn ~ x1 * x2, data = dat, aspect = .7,
  xlab = expression(x[1]), ylab = expression(x[2]),
  xlim = c(-2.2, 5.7), ylim = c(-1.1, 3.6),
  panel = function(...) {
    panel.levelplot(...)
    panel.polygon(x = c(2, 5, -1), y = c(0, 3, 3),
      border = TRUE, lwd = 2, col = "transparent"
    )
    panel.points(
      x = c(uc_sol[1], qp_sol[1], -4/3),
      y = c(uc_sol[2], qp_sol[2], 1/3),
      lwd = 5, col = c("red", "yellow", "blue"), pch = 19
    )
  },
  # 减少图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = 0, units = "inches"),
      right.padding = list(x = 0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  scales = list(
    x = list(alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ), contour = TRUE, colorkey = TRUE,
  col.regions = terrain.colors
)
```

蓝色的点是无约束情况下，目标函数的最小值，而求解器 `nloptr.slsqp` 给出的最优解是红点，令人疑惑。不过，**quadprog** 包在求解约束条件下的严格凸二次规划问题时，同时给出无约束条件下的解。这个包自定义了一套二次规划问题的符号，查看求解函数 `solve.QP()` 的说明，略作对应后，求解上述规划问题的代码如下。

```{r}
library(quadprog)
sol <- solve.QP(
  Dmat = Dmat, dvec = -dvec, Amat = t(-Amat), bvec = -bvec
)
sol
```

其中，返回值的 `unconstrained.solution` 表示无约束下的解，与预期的解一致，这就没有疑惑了。可见，约束二次规划问题和无约束二次规划问题的求解器不同。

### 混合整数二次优化

对变量添加整型约束，原二次规划即变成混合整数二次规划 （Mixed Integer Quadratic Programming，简称 MIQP）。目前，ROI 支持的开源求解器都不能处理 MIQP 问题，只有 **CVXR** 包和 [**rmpk**](https://github.com/r-opt/rmpk) 包能解 MIQP 问题，更多关于 **CVXR** 包的介绍见[示例库](https://cvxr.rbind.io/examples/)。

```{r}
#| eval: false

op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(Amat, rep("<=", 3), bvec),
  types = c("I", "C"),
  maximum = FALSE # 求最小
)
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 2))
nlp$objval
nlp$solution
```

**ECOSolveR** 包可以求解一些锥规划，且变量可以包含整数。将凸二次规划转为锥规划问题，再调 `ecos` 求解器。连接 **ECOSolveR** 包提供 `ecos` 求解器。

```{r}
#| eval: false

op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(Amat, rep("<=", 3), bvec),
  types = c("I", "C"),
  maximum = FALSE # 默认求最小
)
library(ROI.plugin.ecos)
nlp <- ROI_solve(op, solver = "ecos", start = c(1, 2))
nlp$objval
nlp$solution
```

```{r}
#| eval: false
#| code-fold: true
#| echo: !expr knitr::is_html_output()

library(CVXR)
# Variables minimized over
x1 <- Variable(1, integer = TRUE)
x2 <- Variable(1)

# Problem definition
objective <- Minimize(x1^2 + x2^2 - x1 * x2 + 3 * x1 - 2 * x2)
constraints <- list(-x1 - x2 <= -2, x1 - x2 <= 2, x2 <= 3)
prob <- Problem(objective, constraints)

# Problem solution
solution <- psolve(prob, solver = "ECOS")
solution$status
solution$value
solution$getValue(x)
solution$getValue(y)
```

### 非严格凸二次优化

**kernlab** 包[@kernlab2004] 当矩阵 $D$ 为半正定时。

## 凸锥优化 {#sec-cone-optimization}

### 锥与凸锥

二维平面上，以原点为圆心的圆和以原点为顶点的扇面是凸锥。三维空间中，以原点为球心的球和以原点为顶点的圆锥是凸锥，如 @fig-convex-cone 所示。

```{r}
#| label: fig-convex-cone
#| fig-cap: 常见的凸锥
#| echo: false
#| out-width: 65%

knitr::include_graphics(path = "images/cone.png")
```

锥定义在对称的矩阵上，凸锥要求矩阵正定。一个 2 阶对称矩阵 $A$ 是正定的

$$
A = \begin{bmatrix}
  a_{11} & a_{12}  \\
  a_{21} & a_{22}  
  \end{bmatrix}
$$

意味着 $a_{11} > 0, a_{22} > 0, a_{12} = a_{21}, a_{11}a_{22} - a_{12}a_{21} > 0$ 。一般地，将 $n$ 阶半正定的对称矩阵 $A$ 构成的集合记为 $\mathcal{K}_{+}^n$ 。

$$
\mathcal{K}_{+}^n = \{A \in \mathbb{R}^{n \times n}|\bm{x}^{\top}A\bm{x} \geq 0, ~ \forall \bm{x} \in \mathbb{R}^n\}
$$

目标函数为线性的凸锥优化的一般形式如下：

$$
\begin{aligned}
\min \quad &\bm{d}^{\top}\bm{x} \\
\text{s.t.} \quad & A\bm{x} + \bm{k} = \bm{b} \\
& \bm{k} \in \mathcal{K}.
\end{aligned}
$$

其中，集合 $\mathcal{K}$ 是一个非空的封闭凸锥。在一个凸锥里，寻求一个线性目标函数的最小值。专门求解此类问题的 **scs** 包 [@scs2016] 也在 **ROI** 包的支持范围内，可以求解的锥优化包括零锥、线性锥、二阶锥、指数锥、幂锥和半正定锥。

下面举个例子说明凸锥，含参对称矩阵 $A(m_1,m_2,m_3)$ 如下：

$$
A(m_1,m_2,m_3) = \begin{bmatrix}
  1 & m_1 & m_2  \\
  m_1 & 1 & m_3  \\
  m_2 & m_3 & 1 
  \end{bmatrix}.
$$

而 $\bm{k} = \bm{b} - A\bm{x}$ 是非空封闭凸锥集合 $\mathcal{K}$ 中的元素。半正定矩阵 $A$ 生成的集合（凸锥） $K$ 如下：

$$
K = \{ (m_1,m_2,m_3) \in \mathbb{R}^3 \mid A(m_1,m_2,m_3) \in \mathcal{K}_{+}^3 \},
$$

集合 $K$ 是有界半正定的，要求含参矩阵 $A$ 的行列式大于等于 0。 矩阵 $A$ 的行列式如下：

$$
\det(A(m_1,m_2,m_3)) = - (m_1^2 + m_2^2 + m_3^2 -2m_1 m_2 m_3 -1) 
$$

集合 $K$ 的边界可表示为如下方程的解：

$$
m_1^2 + m_2^2 + m_3^2 -2m_1 m_2 m_3 = 1
$$

或等价地表示为如下矩阵形式：

$$
\begin{split}\left[
\begin{array}{c}
m_1\\m_2
\end{array}\right]^{\top}
\left[\begin{array}{rr}
1 & -m_3\\-m_3 &1
\end{array}\right]
\left[\begin{array}{c}
m_1\\m_2
\end{array}\right] = 1 - m_3^2.
\end{split}
$$

当 $m_3 = 0$ 时，集合 $K$ 的边界表示平面上的一个单位圆，当 $m_3 \in [-1, 1]$ ，集合 $K$ 的边界表示一个椭圆。为了获得一个直观的印象，将集合 $K$ 的边界绘制出来，如 @fig-convex-cone 所示，边界是一个三维曲面，曲面及其内部构成一个凸锥。

```{r}
#| label: fig-cone
#| fig-cap: 锥
#| echo: false
#| out-width: 35%

knitr::include_graphics(path = "images/ellipse-cone.png")
```

### 零锥

零锥的定义如下：

$$
\mathcal{K}_{zero} = \{0\}
$$

常用于表示线性等式约束。

### 线性锥

线性锥（Linear Cone）的定义如下：

$$
\mathcal{K}_{lin} = \{x \in \mathbb{R}|x \geq 0\}
$$

常用于表示线性不等式约束。

### 二阶锥

二阶锥（Second-order Cone）的定义如下：

$$
\mathcal{K}_{soc}^{n} = \{(t,x) \in \mathbb{R}^n|x \in \mathbb{R}^{n-1}, t\in\mathbb{R},\| x \|_2 \leq t\}
$$

常用于凸二次优化问题。

### 指数锥

指数锥（Exponential Cone）的定义如下：

$$
\mathcal{K}_{\text{expp}} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_2 > 0,x_2\exp\big(\frac{x_1}{x_2}\big) \leq x_3\} \cup \{(x_1, 0, x_3) \in \mathbb{R}^3 | x_1 \leq 0, x_3 \geq 0 \}
$$

它的对偶如下：

$$
\mathcal{K}_{\text{expd}} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1 < 0, - x_1\exp\big(\frac{x_2}{x_1}\big) \leq \exp(1)x_3\} \cup \{(0, x_2, x_3) \in \mathbb{R}^3 | x_2 , x_3 \geq 0 \}
$$

考虑一个锥优化问题

$$
\begin{aligned}
\max_{(\bm{x}, \bm{t})} \quad & x_1 + 2 x_2 \\
\text{s.t.} \quad & \exp(7 + 3x_1 + 5 x_2) \leq 9 + 11 t_1 + 12t_2 \\
\quad & x_1,x_2 \in (-\infty,20], ~ t_1,t_2 \in (-\infty, 50]
\end{aligned}
$$

约束条件 $\exp(7 + 3x_1 + 5 x_2) \leq 9 + 11 t_1 + 12t_2$ 可以用指数锥来表示

$$
\begin{aligned}
u &= 7 + 3y_1 + 5y_2 \\
v &= 1 \\
w &= 9 + 11t_1 + 12t_2
\end{aligned}
$$

记 $\bm{x} = (y_1,y_2,t_1,t_2)^{\top}$ ，则线性约束矩阵 $A$ 和约束向量 $\bm{b}$ 如下：

$$
A = \begin{bmatrix}
-3 & -5 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & -11 & -12
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
7 \\
1 \\
9
\end{bmatrix}
$$

指数锥用函数 `K_expp()` 表示，锥优化问题的代码如下：

```{r}
# 锥约束
cexpp <- C_constraint(L = rbind(
  c(-3, -5, 0, 0), 
  c(0, 0, 0, 0),
  c(0, 0, -11, -12)
), cone = K_expp(1), rhs = c(7, 1, 9))
# 目标规划
expp <- OP(objective = c(1, 2, 0, 0), constraints = cexpp,
  bounds = V_bound(ld = -Inf, ub = c(20, 20, 50, 50)), 
  maximum = TRUE
)
expp
```

对于锥优化，可以调用 **scs** 包来求解。

```{r}
# 调用 scs 包
library(ROI.plugin.scs)
expp_sol <- ROI_solve(expp, solver = "scs")
# 最优解
expp_sol$solution
# 目标函数值
expp_sol$objval
```

### 幂锥

一个三维幂锥（Power Cone）的定义如下：

$$
\mathcal{K}_{\text{powp}}^{\alpha} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1,x_2 \geq 0,x_1^{\alpha}x_2^{1-\alpha} \geq |x_3| \}, \alpha \in [0,1]
$$

它的对偶形式如下：

$$
\mathcal{K}_{\text{powp}}^{\alpha} = \Big\{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1,x_2 \geq 0,\big(\frac{x_1}{\alpha}\big)^{\alpha}\big(\frac{x_2}{1 - \alpha}\big)^{1-\alpha} \geq |x_3| \Big\}, \alpha \in [0,1]
$$

考虑如下锥优化问题

$$
\begin{aligned}
\min_{\bm{x}} \quad & 3x_1 + 5 x_2 \\
\text{s.t.} \quad & 5 + x_1 \leq (2 + x_2)^4 \\
\quad & x_1 \geq 0, ~ x_2 \geq 2
\end{aligned}
$$

约束条件 $5 + x_1 \leq (2 + x_2)^4$ 可以重新表示为幂锥

$$
\begin{aligned}
u &= 5 + y_1\\
v &= 1 \\
w &= 2 + y_2 \\
\alpha &= 1/4
\end{aligned}
$$

记 $\bm{x} = (y_1,y_2)^{\top}$ ，约束矩阵和约束向量如下

$$
A = \begin{bmatrix}
-1  & 0 \\
0   & 0 \\
0   & -1
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
5 \\
1 \\
2
\end{bmatrix}
$$

幂锥用函数 `K_powp()` 表示，锥优化问题的代码如下：

```{r}
A <- rbind(c(-1, 0), c(0, 0), c(0, -1))
cpowp <- C_constraint(L = A, cones = K_powp(1 / 4), rhs = c(5, 1, 2))
op <- OP(
  objective = c(3, 5),
  constraints = cpowp,
  bounds = V_bound(lb = c(0, 2))
)
op
```

```{r}
op_sol <- ROI_solve(op, solver = "scs", max_iter = 1e6)
op_sol$solution
op_sol$objval
```

### 半正定锥

如果矩阵 $A$ 是半正定的，记为 $A \succeq 0$ ，如果矩阵 $A$ 是正定的，记为 $A \succ 0$ 。记 $n$ 阶实对称矩阵的集合为 $\mathcal{S}^{n}$ 。半正定锥（Positive Semidefinite Cone）的定义如下：

$$
\mathcal{K}_{\text{psd}}^{n} = \{A | A \in \mathcal{S}^{n}, \bm{x}^{\top}A\bm{x} \geq 0, \forall \bm{x} \in \mathbb{R}^n \}
$$

考虑如下锥规划问题

$$
\begin{aligned}
\min_{\bm{x}} \quad & x_1 + x_2 - x_3 \\
\text{s.t.} \quad & 
x_1 \begin{bmatrix}
10  & 3 \\
3   & 10
\end{bmatrix} + 
x_2 \begin{bmatrix}
6  & -4 \\
-4   & 10
\end{bmatrix} + 
x_3 \begin{bmatrix}
8  & 1 \\
1  & 6
\end{bmatrix} \preceq 
\begin{bmatrix}
16  & -13 \\
-13  & 60
\end{bmatrix}
\\
\quad & x_1,x_2,x_3 \geq 0
\end{aligned}
$$

函数 `K_psd()` 表示半正定锥，函数 `vech()` 将对称矩阵的上三角部分拉成一个向量。

```{r}
(A <- toeplitz(x = 3:1))
vech(A)
```

锥规划的表示如下

```{r}
F1 <- rbind(c(10, 3), c(3, 10))
F2 <- rbind(c(6, -4), c(-4, 10))
F3 <- rbind(c(8, 1), c(1, 6))
F0 <- rbind(c(16, -13), c(-13, 60))
# 目标规划
op <- OP(
  objective = L_objective(c(1, 1, -1)),
  constraints = C_constraint(
    L = vech(F1, F2, F3),
    cones = K_psd(3),
    rhs = vech(F0)
  )
)
op
```

仍然调用 **scs** 求解器

```{r}
op_sol <- ROI_solve(op, solver = "scs")
op_sol$solution
op_sol$objval
```

## 非线性优化 {#sec-nonlinear-optimization}

非线性优化按是否带有约束，以及约束是线性还是非线性。

R 自带的函数 `nlminb()` 可求解无约束、箱式约束优化问题，`constrOptim()` 还可求解线性不等式约束优化，其中包括带线性约束的二次规划。`optim()` 提供一大类优化算法，且包含随机优化算法---模拟退火算法，可求解无约束、箱式约束优化问题。

### 无约束优化

#### 示例 1

Rastrigin 函数是多模态函数，有许多局部极小值。

$$
f(\bm{x})= \sum_{i=1}^{n}\big(x_i^2 - 10 \cos(2\pi x_i) + 10\big)
$$

计算函数值的 R 代码

```{r}
fn <- function(x) {
  sum(x^2 - 10 * cos(2 * pi * x) + 10)
}
```

二维 Rastrigin 函数图像

```{r}
#| label: fig-rastrigin
#| fig-cap: 二维 Rastrigin 函数图像
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(-4, 4, length.out = 151),
  y = seq(-4, 4, length.out = 151)
)

df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

设置 10 维的优化

```{r}
op <- OP(
  objective = F_objective(fn, n = 10L),
  bounds = V_bound(ld = -50, ud = 50, nobj = 10L)
)
```

调全局优化器求解非凸优化问题

```{r}
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$solution
nlp$objval
```

#### 示例 2

有如下复杂的目标函数

$$
\begin{aligned}
  & \min_x ~ \cos(x_1)\cos(x_2) - \sum_{i=1}^{5}\Big( (-1)^i \cdot i \cdot 2 \cdot \exp\big(-500 \cdot ( (x_1 - i \cdot 2)^2 + (x_2 - i\cdot 2)^2 ) \big) \Big) \\
  & \text{s.t.} ~ -50 \leq x_1, x_2 \leq 50
\end{aligned}
$$

```{r}
subfun <- function(i, m) {
  (-1)^i * i * 2 * exp(-500 * ((m[1] - i * 2)^2 + (m[2] - i * 2)^2))
}

fn <- function(x) {
  cos(x[1]) * cos(x[2]) -
    sum(mapply(FUN = subfun, i = 1:5, MoreArgs = list(m = x)))
}
```

目标函数的图像见 @fig-super-function ，搜索区域 $[-50, 50] \times [-50, 50]$ 内几乎没有变化的梯度，给寻优过程带来很大困难。

```{r}
#| label: fig-super-function
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-cap: 函数图像
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(-50, 50, length.out = 101),
  y = seq(-50, 50, length.out = 101)
)
df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

将区域 $[0, 12] \times [0, 12]$ 上的三维图像绘制出来，可见，有不少局部陷阱，且分布在 $x_2 = x_1$ 的直线上。

```{r}
#| label: fig-zoom-super-function
#| fig-cap: 局部放大的函数图像
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(0, 12, length.out = 151),
  y = seq(0, 12, length.out = 151)
)

df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90), alpha = 0.75, 
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

最优解在 $(7.999982, 7.999982)$ 取得，目标函数值为 -7.978832。

```{r}
fn(x = c(7.999982, 7.999982))
```

面对如此复杂的函数，调用全局优化器寻优。

```{r}
op <- OP(
  objective = F_objective(fn, n = 2L),
  bounds = V_bound(ld = -50, ud = 50, nobj = 2L)
)
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$solution
nlp$objval
```

实际上，还是陷入局部最优解。运筹优化方面的商业软件，著名的有 Lingo 和 Matlab，下面采用 Lingo 20 求解，Lingo 代码如下：

```         
SETS:
P/1..5/;
Endsets
Min=@cos(x1) * @cos(x2) - @Sum(P(j): (-1)^j * j * 2 * @exp(-500 * ((x1 - j * 2)^2 + (x2 - j * 2)^2)));
@Bnd(-50, x1, 50);
@Bnd(-50, x2, 50);
```

启用全局优化求解器后，在 $(x_1 = 7.999982, x_2 = 7.999982)$ 取得最小值 -7.978832。而默认未启用全局优化求解器的情况下，在 $(x_1 = 18.84956, x_2 = -40.84070)$ 取得局部极小值 -1.000000。

在这种情况下，数值优化算法遇到瓶颈，可以采用一些全局随机优化算法，比如 **GA** 包 [@GA2013] 实现的遗传算法。经过对参数的一些调优，可以获得与商业软件几乎一样的结果。

```{r}
nlp <- GA::ga(
  type = "real-valued",
  fitness = function(x) -fn(x),
  lower = c(0, 0), upper = c(12, 12),
  popSize = 500, maxiter = 100, 
  monitor = FALSE, seed = 20232023
)
# 最优解
nlp@solution
# 目标函数值
nlp@fitnessValue
```

其中，参数 `type` 指定决策变量的类型，`type = "real-valued"` 表示目标函数中的决策变量是实值连续的，参数 `fitness` 是目标函数，函数 `ga()` 对目标函数求极大，所以，对当前优化问题，添加了一个负号。 参数 `popSize` 控制种群大小，值越大，运行时间越长，搜索范围越广，获得的全局优化解越好。对于复杂的优化问题，可以不断增加种群大小来寻优，直至增加种群大小也不能获得更好的解。参数 `maxiter` 控制种群进化的次数，值越大，搜索次数可以越多，获得的解越好。参数 `popSize` 的影响大于参数 `maxiter` ，减少陷入局部最优解（陷阱）的可能。根据已知条件尽可能缩小可行域，以减少种群数量，进而缩短算法迭代时间。

### 箱式约束优化

有如下箱式约束优化问题，示例来自函数 `nlminb()` 的帮助文档，目标函数和[香蕉函数](https://en.wikipedia.org/wiki/Rosenbrock_function)有些相似。

$$
\begin{array}{l}
  \min_x \quad  (x_1 - 1)^2 + 4\sum_{i =1}^{n -1}(x_{i+1} -x_i^2)^2  \\
  \text{s.t.} \quad 2 \leq x_1,x_2,\cdots,x_n \leq 4
\end{array}
$$

R 语言编码的函数代码如下：

```{r}
fn <- function(x) {
  n <- length(x)
  sum(c(1, rep(4, n - 1)) * (x - c(1, x[-n])^2)^2)
}
```

考虑二维的情形，绘制三维曲面图像，见 @fig-valley-persp 。如果没有约束，全局极小值点在 $(1,1)$ 处取得。

```{r}
#| label: fig-valley-persp
#| fig-cap: 类香蕉函数的曲面图
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

dat <- expand.grid(
  x1 = seq(from = 0, to = 4, length.out = 41),
  x2 = seq(from = 0, to = 4, length.out = 41)
)
dat$fn <- apply(dat, 1, fn)

wireframe(
  data = dat, fn ~ x1 * x2,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]), ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

$n$ 维目标函数是非线性的，给定初值 $(3, 3, \cdots, 3)$，下面求解 25 维的箱式约束，

```{r}
nlminb(
  start = rep(3, 25), objective = fn,
  lower = rep(2, 25), upper = rep(4, 25)
)
```

`nlminb()` 出于历史兼容性的原因尚且存在，最优解的第24个分量没有在可行域的边界上。使用 `constrOptim()` 函数求解，默认求极小，需将箱式或线性不等式约束写成矩阵形式，即 $Ax \geq b$ 的形式，参数 ui 是 $k \times n$ 的约束矩阵 $A$，ci 是右侧 $k$ 维约束向量 $b$。以上面的优化问题为例，将箱式约束 $2 \leq x_1,x_2 \leq 4$ 转化为矩阵形式，约束矩阵和向量分别为：

$$
A = \begin{bmatrix}
1  & 0  \\
0  & 1 \\
-1 & 0 \\
0  & -1
\end{bmatrix}, \quad
b = \begin{bmatrix}
2 \\
2 \\
-4 \\ 
-4
\end{bmatrix}
$$

```{r}
constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  method = "Nelder-Mead", # 没有提供梯度，则必须用 Nelder-Mead 方法
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

从求解的结果来看，`convergence = 1` 意味着迭代次数到达默认的极限 `maxit = 500`，结合 `nlminb()` 函数的求解结果来看，实际上还没有收敛。如果没有提供梯度，则必须用 Nelder-Mead 方法，下面增加迭代次数到 1000。

```{r}
constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  method = "Nelder-Mead", 
  control = list(maxit = 1000),
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

还是没有收敛，可见 Nelder-Mead 方法在这个优化问题上收敛速度比较慢。下面考虑调用基于梯度的优化算法 --- BFGS 方法。

```{r}
# 输入 n 维向量，输出 n 维向量
gr <- function(x) {
  n <- length(x)
  c(2 * (x[1] - 2), rep(0, n - 1))
  +8 * c(0, x[-1] - x[-n]^2)
  -16 * c(x[-n], 0) * c(x[-1] - x[-n]^2, 0)
}

constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  grad = gr,
  method = "BFGS", 
  control = list(maxit = 1000),
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

相比于 Nelder-Mead 方法，目标值 373 更大，可见已陷入局部最优解，下面通过 ROI 包，分别调用求解器 `nloptr.lbfgs` 和 `nloptr.directL` ，发现前者同样陷入局部最优解，而后者可以获得与 `nlminb()` 函数一致的结果。

```{r}
# 调用改进的 BFGS 算法
op <- OP(
  objective = F_objective(fn, n = 25L, G = gr),
  bounds = V_bound(ld = 2, ud = 4, nobj = 25L)
)
nlp <- ROI_solve(op, solver = "nloptr.lbfgs", start = rep(3, 25))
nlp$objval
nlp$solution
```

```{r}
# 调全局优化算法
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$objval
nlp$solution
```

下面再与函数 `optim()` 提供的 `L-BFGS-B` 算法比较。

```{r}
optim(
  par = rep(3, 25), fn = fn, gr = NULL, method = "L-BFGS-B",
  lower = rep(2, 25), upper = rep(4, 25)
)
```

值得注意的是，当提供梯度信息的时候，虽然求解速度提升了，但是最优解变差了。

```{r}
optim(
  par = rep(3, 25), fn = fn, gr = gr, method = "L-BFGS-B",
  lower = rep(2, 25), upper = rep(4, 25)
)
```

### 非线性约束优化

**nloptr** 包的非线性优化能力覆盖开源优化软件 [Octave](https://www.octave.org/) 和 [Ipopt](https://github.com/coin-or/Ipopt) 。

#### 示例 1

-   非线性等式约束

示例来自 Octave 的[非线性优化帮助文档](https://octave.org/doc/v8.2.0/Nonlinear-Programming.html)，Octave 函数 `sqp()` 使用序列二次规划求解器（successive quadratic programming solver）解非线性规划问题，示例中该优化问题包含多个非线性等式约束。

$$
\begin{array}{l}
\min_x \quad \mathrm{e}^{\prod_{i=1}^{5} x_i} - \frac{1}{2}(x_1^3 + x_2^3 + 1)^2 \\
\text{s.t.} \left\{ 
  \begin{array}{l}
   \sum_{i=1}^{5}x_i^2 - 10 = 0 \\
   x_2 x_3 - 5x_4 x_5 = 0 \\
   x_1^3 + x_2^3 + 1 = 0
  \end{array} \right.
\end{array}
$$

目标函数是非线性的，包含 5 个变量，约束条件是非线性的，有 3 个等式约束。先手动计算目标函数的梯度，等式约束的雅可比矩阵。

```{r}
# 目标函数
fn <- function(x) {
  exp(prod(x)) - 0.5 * (x[1]^3 + x[2]^3 + 1)^2
}
# 目标函数的梯度
gr <- function(x) {
  c(
    exp(prod(x))*prod(x[-1]) - 3*(x[1]^3 + x[2]^3 + 1)*x[1]^2,
    exp(prod(x))*prod(x[-2]) - 3*(x[1]^3 + x[2]^3 + 1)*x[2]^2,
    exp(prod(x))*prod(x[-3]), 
    exp(prod(x))*prod(x[-4]),
    exp(prod(x))*prod(x[-5])
  )
}
# 等式约束
heq <- function(x) {
  c(
    sum(x^2) - 10,
    x[2] * x[3] - 5 * x[4] * x[5],
    x[1]^3 + x[2]^3 + 1
  )
}
# 等式约束的雅可比矩阵
heq.jac <- function(x) {
  matrix(c(2 * x[1], 2 * x[2], 2 * x[3], 2 * x[4], 2 * x[5],
    0, x[3], x[2], -5 * x[5], -5 * x[4],
    3 * x[1]^2, 3 * x[2]^2, 0, 0, 0),
    ncol = 5, byrow = TRUE
  )
}
```

在 `OP()` 函数里定义目标规划的各个成分。

```{r}
# 定义目标规划
op <- OP(
  # 5 个目标变量
  objective = F_objective(F = fn, n = 5L, G = gr), 
  constraints = F_constraint(
    F = list(heq = heq),
    dir = "==",
    rhs = 0,
    # 等式约束的雅可比矩阵
    J = list(heq.jac = heq.jac)
  ),
  bounds = V_bound(ld = -Inf, ud = Inf, nobj = 5L),
  maximum = FALSE # 求最小
)
op
```

调用 SQP（序列二次规划） 求解器

```{r}
nlp <- ROI_solve(op,
  solver = "nloptr.slsqp",
  start = c(-1.8, 1.7, 1.9, -0.8, -0.8)
)
nlp$solution
nlp$objval
```

计算结果和 Octave 的示例一致。

#### 示例 2

-   非线性等式约束
-   非线性不等式约束，不等式约束包含等号
-   箱式约束

此优化问题来源于 **Ipopt** 官网的[帮助文档](https://coin-or.github.io/Ipopt/INTERFACES.html)，约束条件比较复杂。提供的初始值为 $x_0 = (1,5,5,1)$，最优解为 $x_{\star} = (1.00000000,4.74299963,3.82114998,1.37940829)$。优化问题的具体内容如下：

$$
\begin{array}{l}
  \min_x \quad x_1 x_4 (x_1 + x_2 + x_3) + x_3 \\
    \text{s.t.} \left\{ 
    \begin{array}{l}
     x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40 \\
     x_1 x_2 x_3 x_4 \geq 25 \\
     1 \leq x_1, x_2, x_3, x_4 \leq 5
    \end{array} \right.
\end{array}
$$

下面用 **ROI** 调 **nloptr** 包求解，看结果是否和例子一致，**nloptr** 支持箱式约束且支持不等式约束包含等号。

```{r}
# 一个 4 维的目标函数
fn <- function(x) {
  x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3]
}
# 目标函数的梯度
gr <- function(x) {
  c(
    x[4] * (2 * x[1] + x[2] + x[3]), x[1] * x[4],
    x[1] * x[4] + 1, x[1] * (x[1] + x[2] + x[3])
  )
}
# 等式约束
heq <- function(x) {
  sum(x^2)
}
# 等式约束的雅可比
heq.jac <- function(x) {
  2 * c(x[1], x[2], x[3], x[4])
}
# 不等式约束
hin <- function(x) {
  prod(x)
}
# 不等式约束的雅可比
hin.jac <- function(x) {
  c(prod(x[-1]), prod(x[-2]), prod(x[-3]), prod(x[-4]))
}
# 定义目标规划
op <- OP(
  objective = F_objective(F = fn, n = 4L, G = gr), # 4 个目标变量
  constraints = F_constraint(
    F = list(heq = heq, hin = hin),
    dir = c("==", ">="),
    rhs = c(40, 25),
    # 等式和不等式约束的雅可比
    J = list(heq.jac = heq.jac, hin.jac = hin.jac)
  ),
  bounds = V_bound(ld = 1, ud = 5, nobj = 4L),
  maximum = FALSE # 求最小
)
```

作为对比参考，先计算目标函数的初始值和最优值。

```{r}
# 目标函数初始值
fn(c(1, 5, 5, 1))
# 目标函数最优值
fn(c(1.00000000, 4.74299963, 3.82114998, 1.37940829))
```

求解一般的非线性约束问题。

-   求解器 `nloptr.mma` / `nloptr.cobyla` 仅支持非线性不等式约束，不支持等式约束。
-   函数 `nlminb()` 只支持等式约束。

因此，下面分别调用 `nloptr.auglag`、`nloptr.slsqp` 和 `nloptr.isres` 来求解上述优化问题。

```{r}
nlp <- ROI_solve(op, solver = "nloptr.auglag", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

```{r}
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

```{r}
nlp <- ROI_solve(op, solver = "nloptr.isres", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

可以看出，**nloptr** 提供的优化能力可以覆盖 [Ipopt 求解器](https://github.com/coin-or/Ipopt)，从以上求解的情况来看，推荐使用 `nloptr.slsqp` 求解器，这也是 Octave 的选择。

## 应用 {#sec-optimization-applications}

### 旅行商问题 {#sec-traveling-salesman-problem}

旅行商问题 The Traveling Salesman Problem 是一个混合整数线性规划问题，**TSP** 包 [@TSP2007] 是求解此问题的最佳工具包。一般地，旅行商问题作如下定义。已知 $n$ 个城市之间的距离，以矩阵 $D$ 表示各个城市之间的距离，其元素 $d_{ij}$ 表示城市 $i$ 到城市 $j$ 之间的距离，其对角元素 $d_{ii} = 0$，其中 $i,j = 1,2,\cdots, n$ 。一个旅行路线可以用 $\{1,2,\ldots,n\}$ 的循环排列 $\pi$ 表示，$\pi(i)$ 表示在旅行线路中跟在城市 $i$ 之后的城市。旅行商问题就是找一个排列 $\pi$ 使得如下旅行线路最短。

$$
\sum_{i=1}^{n} d_{i\pi(i)}
$$

每个城市必须走到，且只能走一次。等价于如下整数规划问题，也是一个指派问题。\
$$
\begin{aligned}
\min ~ & \sum_{i=1}^{n}\sum_{j=1}^{n} d_{ij}x_{ij} \\
\text{s.t.} ~& \sum_{i=1}^{n}x_{ij} = 1, ~j = 1,2,\ldots,n, \\
~& \sum_{j=1}^{n}x_{ij} = 1, ~ i = 1,2,\ldots,n, \\
~& x_{ij} = 0 ~\text{or} ~ 1
\end{aligned}
$$

某人要去美国 10 个城市旅行，分别是亚特兰大 Atlanta、芝加哥 Chicago、丹佛 Denver 、休斯顿 Houston、洛杉矶 Los Angeles、迈阿密 Miami、纽约 New York、旧金山 San Francisco、 西雅图 Seattle、华盛顿特区 Washington DC。10 个城市的分布如 @fig-tsp-problem 所示。从洛杉矶出发，最后回到洛杉矶，如何规划旅行线路使得总行程最短？行程最短的路径是什么？

```{r}
#| label: fig-tsp-problem
#| fig-width: 6
#| fig-height: 3.8
#| fig-showtext: true
#| fig-cap: "10 个城市的分布图"
#| code-fold: true
#| echo: !expr knitr::is_html_output()
#| message: false

# 10 个城市的经纬度数据来自 maps 包的 us.cities 数据集
us_city_latlong <- read.table(file = textConnection("
City, Latitude, Longitude
Atlanta, 33.76, -84.42
Chicago, 41.84, -87.68
Denver, 39.77, -104.87
Houston, 29.77, -95.39
Los Angeles, 34.11, -118.41
Miami, 25.78, -80.21
New York, 40.67, -73.94
San Francisco, 37.77, -122.45
Seattle, 47.62, -122.35
Washington DC, 38.91, -77.01
"), header = TRUE, sep = ",")

library(sf)
us_city_latlong <- st_as_sf(us_city_latlong,
  coords = c("Longitude", "Latitude"), crs = 4326
)
library(ggplot2)
ggplot() +
  geom_sf_label(
    data = us_city_latlong, aes(label = City),
    fun.geometry = sf::st_centroid
  ) +
  geom_sf(data = us_city_latlong, color = "red") +
  coord_sf(crs = "ESRI:102003") +
  theme_bw() +
  labs(x = "经度", y = "纬度")
```

简单起见，这 10 个城市之间的距离以直线距离代替，R 内置的数据集 `UScitiesD` 已经记录了这 10 个城市之间的直线距离。 `UScitiesD` 是一个 dist 类型的数据，可以用函数 `as.matrix()` 将其转化为矩阵类型。

```{r}
data(UScitiesD)
D <- as.matrix(UScitiesD)
library(TSP)
D_tsp <- as.TSP(D)
# 出发城市洛杉矶
tour_sol <- solve_TSP(x = D_tsp, method = "nearest_insertion", start = 5)
tour_sol
```

途经 10 个城市的最短路程为 7373 。因采用启发式的随机优化算法，每次求解的结果可能会有所不同，建议运行多次，比较结果，选择最优的方法。

```{r}
# 旅行最短路程
tour_length(tour_sol)
# 旅行线路方案
as.integer(tour_sol)
labels(D_tsp)[as.integer(tour_sol)]
```

求解结果对应的旅行方案，如 @fig-tsp-solution 所示，依次走过的城市是：洛杉矶、旧金山、西雅图、丹佛、芝加哥、纽约、华盛顿特区、亚特兰大、迈阿密、休斯顿。

```{r}
#| label: fig-tsp-solution
#| fig-width: 6
#| fig-height: 3.8
#| fig-showtext: true
#| fig-cap: "10 个城市的路线图"
#| code-fold: true
#| echo: !expr knitr::is_html_output()
#| message: false

us_city_tour <- st_cast(st_combine(st_geometry(us_city_latlong[as.integer(tour_sol),])), "POLYGON")
ggplot() +
  geom_sf_label(
    data = us_city_latlong, aes(label = City),
    fun.geometry = sf::st_centroid
  ) +
  geom_sf(data = us_city_latlong, color = "red") +
  geom_sf(data = us_city_tour, fill = NA, color = "black") +
  coord_sf(crs = "ESRI:102003") +
  theme_bw() +
  labs(x = "经度", y = "纬度")
```

### 投资组合问题 {#sec-markowitz-portfolio-optimization}

作为一个理性的投资者，希望回报最大而风险最小，给定投资和回报的约束条件下，选择风险最小的组合。一个简单的马科维茨投资组合优化问题如下：

$$
\begin{aligned}
\min_{\bm{w}} \quad & \bm{w}^{\top}\hat{\Sigma}\bm{w} \\
\text{s.t.} \quad & A\bm{w}^{\top} \leq \bm{b}
\end{aligned}
$$

其中，$\bm{w}$ 是权重向量，每个分量代表对投资对象的投资比例，$\hat{\Sigma}$ 是关于投资对象的协方差矩阵，约束条件中包含两个部分，一个是权重之和为 1，一个是投资组合的收益率达到预期值。下面基于 12个科技公司公开的股价数据介绍此组合优化问题。

首先利用 **quantmod** 包获取微软、谷歌、亚马逊、惠普、甲骨文、英特尔、威瑞森、eBay、AT&T、Apple、Adobe 和 IBM 等 12 支股票的历史股价数据。根据 2022-11-01 至 2022-12-01 期间的股票调整价，计算各支股票天粒度的收益率。收益率可以看作一个随机变量，收益率的波动变化，即随机变量的方差，可以看作风险。

```{r}
# 12 支股票的收益率
tech_stock_return <- readRDS(file = "data/tech_stock_return.rds")
DD <- 100 * tech_stock_return
# 平均收益率
r <- mean(DD)
r
# 目标函数
foo <- Q_objective(Q = cov(DD), L = rep(0, ncol(DD)))
# 投资约束
full_invest <- L_constraint(rep(1, ncol(DD)), "==", 1)
# 回报约束
target_return <- L_constraint(apply(DD, 2, mean), "==", r)
# 目标规划
op <- OP(objective = foo, constraints = rbind(full_invest, target_return))
op
```

求解器 `nloptr.slsqp` 需要给初值和等式约束的梯度，而求解器 `quadprog` 不需要给初值。下面使用 `quadprog` 来求解组合优化问题。

```{r}
library(ROI.plugin.quadprog)
sol <- ROI_solve(op, solver = "quadprog")
# 最优解：投资组合
w <- sol$solution
# 保留 4 位小数
round(w, 4)
# 目标函数值：投资风险
sqrt(t(w) %*% cov(DD) %*% w)
```

求解出来的投资组合是甲骨文、 AT&T 和 IBM，投资比例分别是 33.58% 、37.40% 和 29.02% 。以上 12 支股票都属于科技公司，收益率具有非常高的相关性，因此，最终选出来 3 支。

与给定预期回报而风险最小的组合优化问题相对应的是另一个问题：给定风险的约束条件下，获得预期回报最大的组合。即求解如下组合优化问题：

$$
\begin{aligned}
\max_{\bm{w}} \quad & \bm{w}^{\top}\hat{\bm{\mu}} \\
\text{s.t.} \quad & A\bm{w} \leq \bm{b} \\
\quad & \bm{w}^{\top}\hat{\Sigma}\bm{w} \leq \sigma
\end{aligned}
$$

其中，目标函数中 $\hat{\bm{\mu}}$ 表示根据历史数据获得的投资对象的收益率，约束条件中 $\sigma$ 表示投资者可以接受的投资风险，其他符号的含义同前。在给定风险约束 $\sigma$ 下，求取回报最大的组合。线性约束也可以用函数 `Q_constraint()` 来表示，这样线性约束和二次约束可以整合在一起，代码如下：

```{r}
# 风险阈值
sigma <- sqrt(t(w) %*% cov(DD) %*% w)
sigma
# 12 阶的全 0 矩阵
zero_mat <- diag(x = rep(0, ncol(DD)))
# 目标函数
foo <- Q_objective(Q = zero_mat, L = colMeans(DD))
# 线性和二次约束
maxret_constr <- Q_constraint(
  Q = list(cov(DD), NULL),
  L = rbind(
    rep(0, ncol(DD)),
    rep(1, ncol(DD))
  ),
 dir = c("<=", "=="), rhs = c(1/2 * sigma^2, 1)
)
# 目标规划
op <- OP(objective = foo, constraints = maxret_constr, maximum = TRUE)
op
```

函数 `ROI_applicable_solvers()` 识别规划问题类型，给出可求解此规划问题的求解器。

```{r}
ROI_applicable_solvers(op)
```

`quadprog` 求解器不能求解该问题，尝试求解器 `nloptr.slsqp` ，12 支股票同等看待，所以，权重的初始值都设置为 $\frac{1}{12}$ 。

```{r}
# 求解规划问题
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = rep(1/12, 12))
# 投资组合
w <- nlp$solution
# 保留 4 位小数
round(w, 4)
# 投资组合的预期收益
w %*% colMeans(DD)
```

结果显示，投资组合是甲骨文、 AT&T 和 IBM，投资比例分别是 33.58% 、37.40% 和 29.02% 。

值得注意，当约束条件比较复杂，比如包含一些非线性的等式或不等式约束，可以用函数 `F_constraint()` 来表示，这更加的灵活，但需要传递（非）线性约束的雅可比向量或矩阵。用函数 `F_constraint()` 表示的代码如下，求解结果是一样的。

```{r}
# x 是一个表示权重的列向量 
# 等式约束
# 权重之和为 1 的约束
heq <- function(x) {
  sum(x)
}
# 等式约束的雅可比
heq.jac <- function(x) {
  rep(1, length(x))
}
# 不等式约束
# 二次的风险约束
hin <- function(x){
  1/2 * t(x) %*% cov(DD) %*% x
}
# 不等式约束的雅可比
hin.jac <- function(x){
  cov(DD) %*% x
}
# 目标规划
op <- OP(
  objective = L_objective(L = colMeans(DD)), # 12 个目标变量
  constraints = F_constraint(
    # 等式和不等式约束
    F = list(heq = heq, hin = hin),
    dir = c("==", "<="),
    rhs = c(1, 1/2 * sigma^2),
    # 等式和不等式约束的雅可比
    J = list(heq.jac = heq.jac, hin.jac = hin.jac)
  ),
  # 目标变量的取值范围
  bounds = V_bound(ld = 0, ud = 1, nobj = 12L),
  maximum = TRUE # 最大回报
)
op
# 求解规划问题
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = rep(1/12, 12))
# 投资组合
w <- nlp$solution
round(w, 4)
# 投资组合的预期收益
w %*% colMeans(DD)
```

### 高斯过程回归 {#sec-gaussian-process-regression}

高斯过程回归模型如下：

$$
\bm{y}(x) = D\bm{\beta} + S(x)
$$

其中，$\bm{\beta}$ 是一个 $p\times 1$ 维列向量，随机过程 $S(x)$ 是均值为零，协方差为 $V_{\bm{\theta}}$ 的平稳高斯过程，协方差矩阵 $V_{\bm{\theta}}$ 的元素如下：

$$
\mathsf{Cov}\{S(x_i), S(x_j)\} = \sigma^2 \exp(-\|x_i - x_j\| / \phi)
$$

其中， $\bm{\theta} = (\sigma^2,\phi)$ 表示与协方差矩阵相关的参数，随机过程 $S(x)$ 的一个实现服从多元正态分布 $\mathrm{MVN}(\bm{0},V_{\bm{\theta}})$ ，则 $\bm{y}(x)$ 也服从多元正态分布 $\mathrm{MVN}(D\bm{\beta},V_{\bm{\theta}})$ 。参数 $\bm{\beta}$ 的广义最小二乘估计为 $\hat{\bm{\beta}}(\bm{\theta}) = (D^{\top}V_{\bm{\theta}}^{-1}D)^{-1} D^{\top}V_{\bm{\theta}}^{-1}\bm{y}$ ，关于参数 $\bm{\theta}$ 的剖面对数似然函数如下：

$$
\log \mathcal{L}(\bm{\theta}) = -\frac{n}{2}\log (2\pi) - \frac{1}{2}\log (\det V_{\bm{\theta}}) -\frac{1}{2}\bm{y}^{\top}V_{\bm{\theta}}^{-1}\big(I - D(D^{\top}V_{\bm{\theta}}^{-1}D)^{-1}D^{\top}V_{\bm{\theta}}^{-1}\big)\bm{y}
$$

下面考虑一个来自 **MASS** 包真实数据 `topo`。topo 数据集最初来自 John C. Davis （1973年）所著的书《Statistics and Data Analysis in Geology》。后来， J. J. Warnes 和 B. D. Ripley （1987年）以该数据集为例指出空间高斯过程的协方差函数的似然估计中存在的问题[@Ripley1987]，并将其作为数据集 `topo` 放在 **MASS** 包里。Paulo J. Ribeiro Jr 和 Peter J. Diggle （2001年）将该数据集打包成自定义的 `geodata` 数据类型，放在 **geoR** 包里，并在他俩合著的书《Model-based Geostatistics》中多次出现。`topo` 是空间地形数据集，包含有 52 行 3 列，数据点是 310 平方英尺范围内的海拔高度数据，`x` 坐标每单位 50 英尺，`y` 坐标单位同 `x` 坐标，海拔高度 `z` 单位是英尺。

```{r}
library(MASS)
data(topo)
str(topo)
```

根据 `topo` 数据集， $D = \bm{1}$ 是一个 $52 \times 1$ 的列向量，$\bm{\beta} = \beta$ 是一个截距项。设置参数初值 $(\sigma,\phi) = (65,2)$ 。为了与 Ripley 的论文中的图比较，下面扔掉了对数似然函数中常数项，用 R 语言编码的似然函数如下：

```{r}
log_lik <- function(x) {
  n <- nrow(topo)
  D <- t(t(rep(1, n)))
  Sigma <- x[1]^2 * exp(-as.matrix(dist(topo[, c("x", "y")])) / x[2])
  inv_Sigma <- solve(Sigma)
  P <- diag(1, n) - D %*% solve(t(D) %*% solve(Sigma, D), t(D)) %*% inv_Sigma
  as.vector(-1 / 2 * log(det(Sigma)) - 1 / 2 * t(topo[, "z"]) %*% inv_Sigma %*% P %*% topo[, "z"])
}
log_lik(x = c(65, 2))
```

关于参数的偏导计算复杂，就不计算梯度了，下面调用 R 软件内置的 `nlminb` 优化器。发现，对不同的初始值，收敛到不同的位置，目标函数值非常接近。

```{r}
op <- OP(
  objective = F_objective(log_lik, n = 2L),
  bounds = V_bound(lb = c(55, 5), ub = c(75, 8)),
  maximum = TRUE
)
nlp <- ROI_solve(op, solver = "nlminb", start = c(65, 2))
nlp$solution
nlp$objval
```

如果初始值靠近局部极值点，则就近收敛到该极值点，比如初值 $(65, 7)$ ， $(70, 7.5)$ 。

```{r}
nlp <- ROI_solve(op, solver = "nlminb", start = c(65, 7))
nlp$solution
nlp$objval
nlp <- ROI_solve(op, solver = "nlminb", start = c(70, 7.5))
nlp$solution
nlp$objval
```

尝试调用来自 **nloptr** 包的全局优化求解器 `nloptr.directL` ，大大小小的坑都跳过去了，结果还是比较满意的。

```{r}
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$solution
nlp$objval
```

目标区域网格化，计算格点处的似然函数值，然后绘制似然函数图像。

```{r}
dat <- expand.grid(
  sigma = seq(from = 55, to = 75, length.out = 41),
  phi = seq(from = 5, to = 8, length.out = 31)
)
dat$fn <- apply(dat, 1, log_lik)
```

似然函数关于参数 $(\sigma,\phi)$ 的三维曲面见 @fig-topo-loglik-persp 。

```{r}
#| label: fig-topo-loglik-persp
#| fig-cap: 对数似然函数的曲面图
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

wireframe(
  data = dat, fn ~ sigma * phi,
  shade = TRUE, drape = FALSE,
  xlab = expression(sigma), ylab = expression(phi),
  zlab = list(expression(
    italic(log-lik) ~ group("(", list(sigma, phi), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

等高线图呈现一道非常长且平滑的山岭 long flat ridge，山岭上布满许多局部极大值，普通的数值优化求解器常常陷入其中，只有全局优化求解器才可能找到全局极大值点。高斯过程回归模型的对数似然函数是非凸的，多模态的。

```{r}
#| label: fig-topo-loglik-contour
#| fig-cap: 对数似然函数的等高线图
#| fig-width: 4.5
#| fig-height: 3.7
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

levelplot(fn ~ sigma * phi,
  data = dat, aspect = 1,
  xlim = c(54.5, 75.5), ylim = c(4.9, 8.1),
  xlab = expression(sigma), ylab = expression(phi),
  col.regions = cm.colors, contour = TRUE,
  scales = list(
    x = list(alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ),
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = 0, units = "inches"),
      right.padding = list(x = 0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -.5, units = "inches"),
      top.padding = list(x = -.5, units = "inches")
    )
  )
)
```

上图中没有看到许多局部极小值，与作者论文中的图 1 似乎不符。原因是什么？似然函数中涉及到的矩阵运算不精确，应该设计精度更高的运算方式？**lattice** 包绘图引擎无法展示更加细微的差异？还有一种解释，上图是对的，算法迭代时，对不同的初值，常常收敛到不同的结果，而这些不同的结果都位于岭上不同位置，对应的对数似然值却又几乎一样。

作为验证，下面调用 **nlme** 包的 `gls()` 函数拟合数据，参数的极大似然估计结果与全局优化求解器的结果比较一致。参数估计结果 $(\sigma, \phi)= (63.93429, 6.121352)$ ，对数似然函数值为 -244.6006 ，自编的似然函数 `log_lik()` 在最优解处的值为 -196.8158，再加上之前扔掉的常数项 `-52 / 2 * log(2 * pi)` ，就是 -244.6006 ，丝毫不差。

```{r}
library(nlme)
fit_topo_ml <- gls(z ~ 1,
  data = topo, method = "ML",
  correlation = corExp(value = 65, form = ~ x + y)
)
summary(fit_topo_ml)
```

如果使用限制极大似然估计，会发现参数估计结果与之相距甚远，而对数似然函数值相差无几。参数估计结果 $(\sigma,\phi) = (128.8275, 25.47324)$ 。

```{r}
fit_topo_reml <- gls(z ~ 1,
  data = topo, method = "REML",
  correlation = corExp(value = 65, form = ~ x + y)
)
summary(fit_topo_reml)
```

### 泊松混合分布 {#sec-poisson-mixture-distributions}

有限混合模型（Finite Mixtures of Distributions）的应用非常广泛，本节参考 **BB** 包 [@BB2009] 的帮助手册，以泊松混合分布为例，介绍其参数的极大似然估计。更多详细的理论和算法介绍从略，感兴趣的读者可以查阅相关文献 [@Hasselblad1969]。**BB** 包比内置函数 `optim()` 功能更强，可以求解大规模非线性方程组，也可以求解带简单约束的非线性优化问题，还可以从多个初始值出发寻找全局最优解。

两个泊松分布以一定比例 $p$ 混合，以概率 $p$ 服从泊松分布 $\mathrm{Poisson}(\lambda_1)$ ，而以概率 $1-p$ 服从泊松分布 $\mathrm{Poisson}(\lambda_1)$ 。

$$
p\times \mathrm{Poisson}(\lambda_1) + (1 - p)\times \mathrm{Poisson}(\lambda_2)
$$

泊松混合分布的概率密度函数 $f(x;p,\lambda_1,\lambda_2)$ 如下：

$$
f(x;p,\lambda_1,\lambda_2) = p \times \frac{\lambda_1^x \exp(-\lambda_1)}{x!} + (1 - p) \times \frac{\lambda_2^x \exp(-\lambda_2)}{x!} 
$$

随机变量 $X$ 服从参数为 $p$ 的伯努利分布 $X \sim \mathrm{Bernoulli}(1, p)$ ，随机变量 $Y$ 服从泊松混合分布，在伯努利分布的基础上，泊松混合分布也可作如下定义：

$$
\begin{array}{l}
Y \sim \left\{
\begin{array}{l}
\mathrm{Poisson}(\lambda_1), \quad \text{当} ~ X = 1 ~ \text{时},\\
\mathrm{Poisson}(\lambda_2), \quad \text{当} ~ X = 0 ~ \text{时}.
\end{array} \right.
\end{array}
$$

对数似然函数如下：

$$
\ell(p,\lambda_1,\lambda_2) = \sum_{i=0}^{n}y_i \log\big(p\times \exp(-\lambda_1) \times\frac{\lambda_1^{x_i}}{x_i!} + (1 - p)\times \exp(-\lambda_2) \times\frac{\lambda_2 ^{x_i}}{x_i!} \big)
$$

下 @tbl-death-count 数据来自 1947 年 Walter Schilling 发表在 JASA 的一篇文章 [@Schilling1947]。连续三年搜集伦敦《泰晤士报》刊登的死亡告示，每天的告示发布 80 岁及以上女性死亡人数。经过汇总统计，发现，在三年里，没有人死亡的告示出现 162 次，死亡 1 人的告示出现 267 次。

|          |     |     |     |     |     |     |     |     |     |     |
|----------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 死亡人数 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| 发生频次 | 162 | 267 | 271 | 185 | 111 | 61  | 27  | 8   | 3   | 1   |

: 死亡人数的统计 {#tbl-death-count}

考虑到夏季和冬季对老人死亡率的影响是不同的，因此，引入泊松混合分布来对数据建模。

```{r}
# 对数似然函数
# p 是一个长度为 3 的向量
# y 是观测数据向量
poissmix_loglik <- function(p, y) {
  i <- 0:(length(y) - 1)
  loglik <- y * log(p[1] * exp(-p[2]) * p[2]^i / exp(lgamma(i + 1)) +
    (1 - p[1]) * exp(-p[3]) * p[3]^i / exp(lgamma(i + 1)))
  sum(loglik)
}
# lgamma(i + 1) 表示整数 i 的阶乘的对数
# 参数的下限
lo <- c(0, 0, 0)
# 参数的上限
hi <- c(1, Inf, Inf)
# 随机生成一组参数初始值
p0 <- runif(3, c(0.2, 1, 1), c(0.8, 5, 8)) 
# 汇总统计出来的死亡人数的频次分布
y <- c(162, 267, 271, 185, 111, 61, 27, 8, 3, 1)
```

调用 **BB** 包的函数 `BBoptim()` 求解多元非线性箱式约束优化问题。

```{r}
library(BB)
# 参数估计
ans <- BBoptim(
  par = p0, fn = poissmix_loglik, y = y,
  lower = lo, upper = hi, 
  control = list(maximize = TRUE)
)
ans
```

`numDeriv::hessian` 计算极大似然点的黑塞矩阵，然后计算参数估计的标准差。

```{r}
# 黑塞矩阵
hess <- numDeriv::hessian(x = ans$par, func = poissmix_loglik, y = y)
hess
# 标准差
se <- sqrt(diag(solve(-hess)))
se
```

`multiStart` 从不同初始值出发寻找全局最大值，先找一系列局部极大值，通过比较获得全局最大值。

```{r}
# 随机生成 10 组初始值
p0 <- matrix(runif(30, c(0.2, 1, 1), c(0.8, 8, 8)), 
             nrow = 10, ncol = 3, byrow = TRUE)
ans <- multiStart(
  par = p0, fn = poissmix_loglik, action = "optimize",
  y = y, lower = lo, upper = hi, quiet = TRUE,
  control = list(maximize = TRUE, trace = FALSE)
)
# 筛选出迭代收敛的解
pmat <- round(cbind(ans$fvalue[ans$conv], ans$par[ans$conv, ]), 4)
dimnames(pmat) <- list(NULL, c("fvalue", "parameter 1", 
                               "parameter 2", "parameter 3"))
# 去掉结果一样的重复解
pmat[!duplicated(pmat), ]
```

### 极大似然估计 {#sec-maximum-likelihood-estimation}

一元函数最优化问题和求根问题是相关的。在统计应用中，二项分布的比例参数的置信区间估计涉及求根，伽马分布的参数的极大似然估计涉及求根。下面介绍求根在估计伽马分布的参数中的应用。

形状参数为 $\alpha$ 和尺度参数为 $\sigma$ 的伽马分布的概率密度函数 $f(x;\alpha, \sigma)$ 如下：

$$
f(x;\alpha,\sigma) = \frac{1}{\sigma^\alpha \Gamma(\alpha)}x^{\alpha - 1} \exp(- \frac{x}{\sigma}), \quad \alpha \geq 0, \sigma > 0
$$

其中，$\Gamma(\cdot)$ 表示伽马函数，伽马分布的均值为 $\alpha \sigma$ ，方差为 $\alpha\sigma^2$ 。下 @fig-dgamma 展示两个伽马分布的概率密度函数，形状参数分别为 5 和 9，尺度参数均为 1，即伽马分布 $f(x; 5, 1)$ 和 $f(x; 9, 1)$ 。

```{r}
#| label: fig-dgamma
#| fig-cap: "伽马分布的概率密度函数"
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

ggplot() +
  geom_function(
    fun = dgamma, args = list(shape = 9, scale = 1),
    aes(colour = "list(alpha == 9, sigma == 1)"),
    linewidth = 1.2, xlim = c(0, 20), 
  ) +
  geom_function(
    fun = dgamma, args = list(shape = 5, scale = 1),
    aes(colour = "list(alpha == 5, sigma == 1)"),
    linewidth = 1.2, xlim = c(0, 20)
  ) +
  scale_colour_viridis_d(
    labels = scales::parse_format(),
    begin = 0.3, end = 0.7,
    option = "C"
  ) +
  theme_bw(base_family = "sans") +
  theme(axis.title = element_text(family = "Noto Serif CJK SC"),
        legend.title = element_text(family = "Noto Serif CJK SC"),
        legend.position = "top", legend.justification = "right") +
  labs(x = "随机变量", y = "概率密度", color = "参数")
```

给定一组来自伽马分布的样本 $x_1,x_2,\ldots,x_n$ ，关于参数 $\alpha$ 和 $\sigma$ 的似然函数如下：

$$
\mathcal{L}(\alpha, \sigma) = \big(\frac{1}{\sigma^\alpha \Gamma(\alpha)}\big)^{n} (\prod_{i=1}^{n} x_i)^{\alpha - 1} \exp(- \frac{ \sum_{i=1}^{n} x_i }{\sigma})
$$

则，其对数似然函数如下：

$$
\ell(\alpha, \sigma) = -n\big(\alpha \log(\sigma) + \log \Gamma(\alpha) \big) + (\alpha - 1)\sum_{i=1}^{n}\log(x_i) - \frac{ \sum_{i=1}^{n} x_i }{\sigma}
$$

对数似然函数关于参数 $\alpha$ 和 $\sigma$ 的偏导数如下：

$$
\begin{aligned}
\frac{\partial \ell(\alpha,\sigma)}{\partial \alpha} &= -n\Big( \log(\sigma) + \big(\log \Gamma(\alpha)\big)' \Big) + \sum_{i=1}^{n}\log (x_i) = 0 \\
\frac{\partial \ell(\alpha,\sigma)}{\partial \sigma} &= - \frac{n\alpha}{\sigma} + \frac{\sum_{i=1}^{n}x_i}{\sigma^2} = 0
\end{aligned}
$$

根据第二个式子可得 $\sigma = \frac{1}{n\alpha}\sum_{i=1}^{n}x_i$ ，将其代入第一个式子可得

$$
\log(\alpha) - \big(\log \Gamma(\alpha)\big)' = \log\big(\frac{1}{n}\sum_{i=1}^{n}x_i\big) - \frac{1}{n}\sum_{i=1}^{n}\log (x_i)
$$

```{r}
set.seed(20232023)
x <- rgamma(1000, shape = 1.5, scale = 2)
# 形状参数和尺度参数的矩估计
c(mean(x)^2 /var(x), var(x)/mean(x))
# 极大似然估计
# 常量
cc <- log(mean(x)) - mean(log(x))
# 方程
fun <- function(alpha){
  log(alpha) - digamma(alpha) - cc
}
# 找根
uniroot(f = fun, interval = c(1, 3))
```

求得形状参数的估计 $\alpha = 1.610272$ ，进而，可得尺度参数的估计 $\sigma = 1.932667$ 。

函数 `uniroot()` 只能找到方程的一个根，**rootSolve** 包采用牛顿-拉弗森（ Newton-Raphson ）算法找一元非线性方程（组）的根，特别适合有多个根的情况。

```{r}
library(rootSolve)
# 非线性方程（组）的根
multiroot(f = fun, start = 1.2)
# 搜索一个方程在区间内所有的根
uniroot.all(f = fun, interval = c(1, 3))
```

### 垃圾邮件分类 {#sec-spam-emails}

**kernlab** 包[@kernlab2004]

## 习题 {#sec-optimization-exercises}

1.  某人要周游美国各州，从纽约出发，走遍 50 个州的行政中心，最后回到纽约。规划旅行线路使得总行程最短。Base R 内置的 R 包 **datasets** 包含美国 50 个州的地理中心数据 `state.center` 。

2.  有限混合模型也常用 EM 算法来估计参数，美国黄石公园老忠实间歇泉的喷发规律近似为二维高斯混合分布，请读者以 R 软件内置的数据集 `faithful` 为基础，采用 EM 算法估计参数。

3.  获取百度、阿里、腾讯、京东、美团、滴滴、字节、360、网易、新浪等 10 支股票的历史股价数据。根据 2021-12-01 至 2022-12-01 股票的调整价计算 12 个月的股价收益率，根据月度股价收益率和波动率数据，设置投资组合，使得月度收益率不低于2%。
