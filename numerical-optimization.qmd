# 数值优化 {#sec-numerical-optimization}

```{r}
#| echo: false

source("_common.R")
# 加载 ROI 时不要自动加载插件
Sys.setenv(ROI_LOAD_PLUGINS = FALSE)
```

::: hidden
$$
 \def\bm#1{{\boldsymbol #1}}
$$
:::

本章介绍四类典型的优化问题及 R 语言求解过程。除了 R 软件内置一些数值优化求解器，R 语言社区有大量的运筹优化方面的函数和 R 包。本文将重点介绍 **ROI** 包，它通过插件包对 20 多个 R 包提供统一的调用方式，相当于一个运筹优化方面的基础设施平台，极大地方便学习和使用。本文不能一一概括，仅详述其中两个，求解线性优化（linear optimization）与混合整数优化（mixed integer linear optimization）的 **Rglpk** 包，求解二次优化（quadratic optimization）和非线性优化（nonlinear optimization）的 **nloptr** 包，相信读者之后可以举一反三。

```{mermaid}
%%| label: fig-roi-plugin
%%| fig-width: 6.5
%%| fig-cap: ROI 包、插件包和数值优化 R 包的关系

flowchart TB
  Rglpk --> ROI_Rglpk(ROI.plugin.glpk)
  ROI_Rglpk --> ROI(ROI)
  nloptr --> ROI_nloptr(ROI.plugin.nloptr)
  ROI_nloptr --> ROI(ROI)
  scs --> ROI_lpsolve(ROI.plugin.scs)
  ROI_lpsolve --> ROI(ROI)
  quadprog --> ROI_quadprog(ROI.plugin.quadprog)
  ROI_quadprog --> ROI(ROI)
```

**Rglpk** 包可以求解大规模线性优化，整数优化和混合整数优化，**ROI** 包通过插件包 **ROI.plugin.glpk** 与之连接调用。**nloptr** 包可以求解二次优化和非线性优化，**ROI** 包通过插件包 **ROI.plugin.nloptr** 与之连接调用。**ROI** 包通过插件包来实际调用第三方做数值优化的 R 包。

```{r}
#| message: false

library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.nloptr)
library(ROI.plugin.scs)
library(ROI.plugin.quadprog)
library(lattice)
# 自定义调色板
custom_palette <- function(irr, ref, height, saturation = 0.9) {
  hsv(
    h = height, s = 1 - saturation * (1 - (1 - ref)^0.5),
    v = irr
  )
}
```

## 线性优化 {#sec-linear-optimization}

线性优化是指目标函数和约束条件都是线性的优化问题。

$$
\begin{array}{l}
  \min_x \quad -6x_1 -5x_2 \\
    \text{s.t.} \left\{ 
    \begin{array}{l}
    x_1  + 4x_2 \leq 16\\
    6x_1 + 4x_2 \leq 28\\
    2x_1 - 5x_2 \leq 6
    \end{array} \right.
\end{array}
$$

写成矩阵形式

$$
\begin{array}{l}
\min_x \quad
  \begin{bmatrix}
  -6  \\
  -5
  \end{bmatrix}
  ^{\top} \bm{x} \\
\text{s.t.}\left\{ 
 \begin{array}{l}
  \begin{bmatrix}
  1 & 4  \\
  6 & 4  \\
  2 & -5 
  \end{bmatrix}
  \bm{x} \leq
  \begin{bmatrix}
   16 \\
   28 \\
   6
  \end{bmatrix}
 \end{array} \right.
\end{array} 
$$

```{r}
# 定义优化问题
op <- OP(
  objective = L_objective(c(-6, -5)),
  constraints = L_constraint(
    L = matrix(c(
      1, 4,
      6, 4, 
      2, -5
    ), ncol = 2, byrow = TRUE),
    dir = c("<=", "<=", "<="),
    rhs = c(16, 28, 6)
  ),
  types = c("C", "C"),
  maximum = FALSE
)
# 优化问题描述
op
# 求解优化问题
res <- ROI_solve(op, solver = "glpk")
# 可行解
res$solution
# 目标函数值
res$objval
```

函数 `OP()` 定义一个优化问题，参数如下：

-   `objective` ：线性目标函数的系数，数值型向量。
-   `constraints` ：约束矩阵 $A$ ，约束分量的方向 `>=` 、`<=` 或 `=` ，右手边的向量 $b$ 。
-   `types` ：变量的类型，如 `"B"` 表示 0-1 变量，字母 B 是 binary 的意思，`"I"` 表示整型变量，字母 I 是 integer 的意思，`"C"` 表示数值型变量，字母 C 是 continuous 的意思。本例中，两个变量都是连续型的，`types = c("C", "C")` 。
-   `maximum` ：目标函数需要求极大还是极小，默认求极小，取值为逻辑值 `TRUE` 或 `FALSE`。

## 整数优化 {#sec-integer-linear-optimization}

整数优化分变量取值为 0 或 1 的 0-1 整数优化和带有整数约束的混合整数优化。

### 0-1 整数优化

变量要么是 0 要么是 1

### 混合整数优化 {#sec-mixed-integer-linear-optimization}

一部分变量要求是整数

$$
\begin{array}{l}
  \max_x \quad 3x_1 + 7x_2 - 12x_3 \\
    \text{s.t.}\left\{ 
    \begin{array}{l}
    5x_1 + 7x_2 + 2x_3 \leq 61\\
    3x_1 + 2x_2 - 9x_3 \leq 35\\
    x_1 + 3x_2 + x_3 \leq 31\\
    x_1,x_2 \geq 0, \quad x_2, x_3 \in \mathbb{Z}, \quad x_3 \in [-10, 10]
    \end{array} \right.
\end{array}
$$

矩阵形式如下

$$
\begin{array}{l}
\max_{x} \quad
  \begin{bmatrix}
  3  \\
  7  \\
  -12
  \end{bmatrix}
  ^{\top} \bm{x} \\
\text{s.t.}\left\{ 
 \begin{array}{l}
  \begin{bmatrix}
  5 & 7 & 2 \\
  3 & 2 & -9\\
  1 & 3 & 1
  \end{bmatrix}
  \bm{x} \leq
  \begin{bmatrix}
   61 \\
   35 \\
   31
  \end{bmatrix}
 \end{array} \right.
\end{array} 
$$

第1个变量是连续值，第2、3个变量是整数，第3个变量的下、上界分别是 -10 和 10。

```{r}
op <- OP(
  objective = L_objective(c(3, 7, -12)),
  types = c("C", "I", "I"),
  constraints = L_constraint(
    L = matrix(c(
      5, 7, 2,
      3, 2, -9,
      1, 3, 1
    ), ncol = 3, byrow = TRUE),
    dir = c("<=", "<=", "<="),
    rhs = c(61, 35, 31)
  ),
  # 添加约束
  bounds = V_bound(li = 3, ui = 3, lb = -10, ub = 10, nobj = 3),
  maximum = TRUE
)
op
# 求解
res <- ROI_solve(op, solver = "glpk")
# 最优解
res$solution
res$objval
```

## 凸二次优化 {#sec-quadratic-optimization}

二次优化分严格凸二次和非严格凸二次优化问题，严格凸要求矩阵对称正定，非严格凸要求矩阵对称半正定。对于矩阵负定的情况，不是凸优化问题，暂不考虑。

### 严格凸二次优化

二次优化的一般形式如下：

$$
\begin{aligned}
\min_{\bm{x}} \quad & \frac{1}{2}\bm{x}^{\top}D\bm{x} + \bm{d}^{\top}\bm{x} \\
\text{s.t.} \quad & A\bm{x} \leq \bm{b}
\end{aligned}
$$

二次优化不都是凸优化，当且仅当矩阵 $D$ 半正定时，上述二次规划是凸二次优化，当矩阵 $D$ 正定时，上述二次规划是严格凸二次优化。下面举个严格凸二次规划的具体例子，令

$$
D = \begin{bmatrix}
2 & -1\\
-1 & 2
\end{bmatrix}, \quad
\bm{d} =  
\begin{bmatrix}
3 \\
-2
\end{bmatrix}, \quad
A = \begin{bmatrix}
-1 & -1  \\
1 & -1 \\
0  & 1
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
-2 \\
2 \\
3
\end{bmatrix}
$$

即目标函数

$$
Q(x_1,x_2) = x_1^2 + x_2^2 - x_1 x_2 + 3x_1- 2x_2
$$

二次规划中的数据矩阵和向量 $D,\bm{d},A,\bm{b}$ 依次用 `Dmat`、`dvec`、`Amat`、`bvec` 表示出来。

```{r}
Dmat <- matrix(c(2, -1, -1, 2), nrow = 2, byrow = TRUE)
dvec <- c(3, -2)
Amat <- matrix(c(-1, -1, 1, -1, 0, 1), ncol = 2, byrow = TRUE)
bvec <- c(-2, 2, 3)
```

同样，也是在函数 `OP()`中传递目标函数，约束条件。在函数 `Q_objective()` 中定义二次规划的目标函数，字母 Q 是 Quadratic 的意思，表示二次部分，字母 L 是 Linear 的意思，表示线性部分。函数 `L_constraint()` 的使用同线性优化，不再赘述。根据 **ROI** 包的使用接口定义的参数，定义目标规划。

```{r}
op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(L = Amat, dir = rep("<=", 3), rhs = bvec),
  maximum = FALSE
)
op
```

**nloptr** 包有许多优化求解器，可用于求解二次规划的也有好几个。对于一个目标规划，函数 `ROI_applicable_solvers()` 可以找到能够求解此优化问题的求解器。

```{r}
ROI_applicable_solvers(op)
```

下面使用其中的 `nloptr.slsqp` 来求解。

```{r}
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 2))
nlp$objval
nlp$solution
```

作为对比，移除线性不等式约束，求解无约束优化问题。目标函数仍然是二次型，但是已经没有线性约束条件，所以不是二次规划问题，再用求解器 `nloptr.slsqp` 求解的结果已不是无约束优化的解。

```{r}
op2 <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  maximum = FALSE
)
op2
nlp2 <- ROI_solve(op2, solver = "nloptr.slsqp", start = c(1, 2))
nlp2$objval
nlp2$solution
```

在可行域上画出等高线，标记目标解的位置， @fig-quadprog 展示无约束和有约束条件下的解。图中红点表示无约束下求解器 `nloptr.slsqp` 获得的解 $(0,1)$ ，真正的无约束解是蓝点所在位置为 $(-4/3,1/3)$ ，黄点表示线性约束下求解器 `nloptr.slsqp` 获得的解 $(1/6,11/6)$ 。所以，不能用二次规划的求解器去求解无约束的二次规划问题。

```{r}
#| label: fig-quadprog
#| fig-cap: "对比无约束和有约束条件下的解"
#| fig-width: 5
#| fig-height: 3.33
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

# 约束解
qp_sol <- nlp$solution
# 无约束解
uc_sol <- nlp2$solution
x1 <- seq(-2, 5.5, length.out = 50)
x2 <- seq(-1, 3.5, length.out = 50)
dat <- expand.grid(x1 = x1, x2 = x2)
# 二次规划的目标函数
dat$fn <- with(dat, x1^2 + x2^2 - x1 * x2 + 3 * x1 - 2 * x2)
levelplot(fn ~ x1 * x2, data = dat, aspect = .7,
  xlab = expression(x[1]), ylab = expression(x[2]),
  xlim = c(-2.2, 5.7), ylim = c(-1.1, 3.6),
  panel = function(...) {
    panel.levelplot(...)
    panel.polygon(x = c(2, 5, -1), y = c(0, 3, 3),
      border = TRUE, lwd = 2, col = "transparent"
    )
    panel.points(
      x = c(uc_sol[1], qp_sol[1], -4/3),
      y = c(uc_sol[2], qp_sol[2], 1/3),
      lwd = 5, col = c("red", "yellow", "blue"), pch = 19
    )
  },
  # 减少图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = 0, units = "inches"),
      right.padding = list(x = 0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  scales = list(
    x = list(alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ), contour = TRUE, colorkey = TRUE,
  col.regions = terrain.colors
)
```

蓝色的点是无约束情况下，目标函数的最小值，而求解器 `nloptr.slsqp` 给出的最优解是红点，令人疑惑。不过，**quadprog** 包在求解约束条件下的严格凸二次规划问题时，同时给出无约束条件下的解。这个包自定义了一套二次规划问题的符号，查看求解函数 `solve.QP()` 的说明，略作对应后，求解上述规划问题的代码如下。

```{r}
library(quadprog)
sol <- solve.QP(
  Dmat = Dmat, dvec = -dvec, Amat = t(-Amat), bvec = -bvec
)
sol
```

其中，返回值的 `unconstrained.solution` 表示无约束下的解，与预期的解一致，这就没有疑惑了。可见，约束二次规划问题和无约束二次规划问题的求解器不同。

### 混合整数二次优化

对变量添加整型约束，原二次规划即变成混合整数二次规划 （Mixed Integer Quadratic Programming，简称 MIQP）。目前，ROI 支持的开源求解器都不能处理 MIQP 问题，只有 **CVXR** 包和 [**rmpk**](https://github.com/r-opt/rmpk) 包能解 MIQP 问题，更多关于 **CVXR** 包的介绍见[示例库](https://cvxr.rbind.io/examples/)。

```{r}
#| eval: false

op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(Amat, rep("<=", 3), bvec),
  types = c("I", "C"),
  maximum = FALSE # 求最小
)
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 2))
nlp$objval
nlp$solution
```

**ECOSolveR** 包可以求解一些锥规划，且变量可以包含整数。将凸二次规划转为锥规划问题，再调 `ecos` 求解器。连接 **ECOSolveR** 包提供 `ecos` 求解器。

```{r}
#| eval: false

op <- OP(
  objective = Q_objective(Q = Dmat, L = dvec),
  constraints = L_constraint(Amat, rep("<=", 3), bvec),
  types = c("I", "C"),
  maximum = FALSE # 默认求最小
)
library(ROI.plugin.ecos)
nlp <- ROI_solve(op, solver = "ecos", start = c(1, 2))
nlp$objval
nlp$solution
```

```{r}
#| eval: false
#| code-fold: true
#| echo: !expr knitr::is_html_output()

library(CVXR)
# Variables minimized over
x1 <- Variable(1, integer = TRUE)
x2 <- Variable(1)

# Problem definition
objective <- Minimize(x1^2 + x2^2 - x1 * x2 + 3 * x1 - 2 * x2)
constraints <- list(-x1 - x2 <= -2, x1 - x2 <= 2, x2 <= 3)
prob <- Problem(objective, constraints)

# Problem solution
solution <- psolve(prob, solver = "ECOS")
solution$status
solution$value
solution$getValue(x)
solution$getValue(y)
```

### 非严格凸二次优化

**kernlab** 包[@kernlab2004] 当矩阵 $D$ 为半正定时。

## 凸锥优化 {#sec-cone-optimization}

### 锥与凸锥

二维平面上，以原点为圆心的圆和以原点为顶点的扇面是凸锥。三维空间中，以原点为球心的球和以原点为顶点的圆锥是凸锥，如 @fig-convex-cone 所示。

```{r}
#| label: fig-convex-cone
#| fig-cap: 常见的凸锥
#| echo: false
#| out-width: 50%

knitr::include_graphics(path = "images/cone.png")
```

锥定义在对称的矩阵上，凸锥要求矩阵正定。一个 2 阶对称矩阵 $A$ 是正定的

$$
A = \begin{bmatrix}
  a_{11} & a_{12}  \\
  a_{21} & a_{22}  
  \end{bmatrix}
$$

意味着 $a_{11} > 0, a_{22} > 0, a_{12} = a_{21}, a_{11}a_{22} - a_{12}a_{21} > 0$ 。一般地，将 $n$ 阶半正定的对称矩阵 $A$ 构成的集合记为 $\mathcal{K}_{+}^n$ 。

$$
\mathcal{K}_{+}^n = \{A \in \mathbb{R}^{n \times n}|\bm{x}^{\top}A\bm{x} \geq 0, ~ \forall \bm{x} \in \mathbb{R}^n\}
$$

目标函数为线性的凸锥优化的一般形式如下：

$$
\begin{aligned}
\min \quad &\bm{d}^{\top}\bm{x} \\
\text{s.t.} \quad & A\bm{x} + \bm{k} = \bm{b} \\
& \bm{k} \in \mathcal{K}.
\end{aligned}
$$

其中，集合 $\mathcal{K}$ 是一个非空的封闭凸锥。在一个凸锥里，寻求一个线性目标函数的最小值。专门求解此类问题的 **scs** 包 [@scs2016] 也在 **ROI** 包的支持范围内，可以求解的锥优化包括零锥、线性锥、二阶锥、指数锥、幂锥和半正定锥。

下面举个例子说明凸锥，含参对称矩阵 $A(m_1,m_2,m_3)$ 如下：

$$
A(m_1,m_2,m_3) = \begin{bmatrix}
  1 & m_1 & m_2  \\
  m_1 & 1 & m_3  \\
  m_2 & m_3 & 1 
  \end{bmatrix}.
$$

而 $\bm{k} = \bm{b} - A\bm{x}$ 是非空封闭凸锥集合 $\mathcal{K}$ 中的元素。半正定矩阵 $A$ 生成的集合（凸锥） $K$ 如下：

$$
K = \{ (m_1,m_2,m_3) \in \mathbb{R}^3 \mid A(m_1,m_2,m_3) \in \mathcal{K}_{+}^3 \},
$$

集合 $K$ 是有界半正定的，要求含参矩阵 $A$ 的行列式大于等于 0。 矩阵 $A$ 的行列式如下：

$$
\det(A(m_1,m_2,m_3)) = - (m_1^2 + m_2^2 + m_3^2 -2m_1 m_2 m_3 -1) 
$$

集合 $K$ 的边界可表示为如下方程的解：

$$
m_1^2 + m_2^2 + m_3^2 -2m_1 m_2 m_3 = 1
$$

或等价地表示为如下矩阵形式：

$$
\begin{split}\left[
\begin{array}{c}
m_1\\m_2
\end{array}\right]^{\top}
\left[\begin{array}{rr}
1 & -m_3\\-m_3 &1
\end{array}\right]
\left[\begin{array}{c}
m_1\\m_2
\end{array}\right] = 1 - m_3^2.
\end{split}
$$

当 $m_3 = 0$ 时，集合 $K$ 的边界表示平面上的一个单位圆，当 $m_3 \in [-1, 1]$ ，集合 $K$ 的边界表示一个椭圆。为了获得一个直观的印象，将集合 $K$ 的边界绘制出来，如 @fig-convex-cone 所示，边界是一个三维曲面，曲面及其内部构成一个凸锥。

```{r}
#| label: fig-cone
#| fig-cap: 锥
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

# 分两部分绘图
fn1 <- function(x) {
  x[1] * x[2] + sqrt(x[1]^2 * x[2]^2 - x[1]^2 - x[2]^2 + 1)
}

fn2 <- function(x) {
  x[1] * x[2] - sqrt(x[1]^2 * x[2]^2 - x[1]^2 - x[2]^2 + 1)
}

df2 <- df1 <- expand.grid(
  x = seq(-1, 1, length.out = 51),
  y = seq(-1, 1, length.out = 51)
)

# 计算函数值
df1$fnxy <- apply(df1, 1, fn1)
df2$fnxy <- apply(df2, 1, fn2)
# 添加分组变量
df1$group <- "1"
df2$group <- "2"
# 合并数据
df <- rbind(df1, df2)

# 绘图
wireframe(
  data = df, fnxy ~ x * y, groups = group,
  shade = TRUE, drape = FALSE,
  xlab = expression(m[1]),
  ylab = expression(m[2]),
  zlab = expression(m[3]),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

### 零锥

零锥的定义如下：

$$
\mathcal{K}_{zero} = \{0\}
$$

常用于表示线性等式约束。

### 线性锥

线性锥（Linear Cone）的定义如下：

$$
\mathcal{K}_{lin} = \{x \in \mathbb{R}|x \geq 0\}
$$

常用于表示线性不等式约束。

### 二阶锥

二阶锥（Second-order Cone）的定义如下：

$$
\mathcal{K}_{soc}^{n} = \{(t,x) \in \mathbb{R}^n|x \in \mathbb{R}^{n-1}, t\in\mathbb{R},\| x \|_2 \leq t\}
$$

常用于凸二次优化问题。

### 指数锥

指数锥（Exponential Cone）的定义如下：

$$
\mathcal{K}_{\text{expp}} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_2 > 0,x_2\exp\big(\frac{x_1}{x_2}\big) \leq x_3\} \cup \{(x_1, 0, x_3) \in \mathbb{R}^3 | x_1 \leq 0, x_3 \geq 0 \}
$$

它的对偶如下：

$$
\mathcal{K}_{\text{expd}} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1 < 0, - x_1\exp\big(\frac{x_2}{x_1}\big) \leq \exp(1)x_3\} \cup \{(0, x_2, x_3) \in \mathbb{R}^3 | x_2 , x_3 \geq 0 \}
$$

考虑一个锥优化问题

$$
\begin{aligned}
\max_{(\bm{x}, \bm{t})} \quad & x_1 + 2 x_2 \\
\text{s.t.} \quad & \exp(7 + 3x_1 + 5 x_2) \leq 9 + 11 t_1 + 12t_2 \\
\quad & x_1,x_2 \in (-\infty,20], ~ t_1,t_2 \in (-\infty, 50]
\end{aligned}
$$

约束条件 $\exp(7 + 3x_1 + 5 x_2) \leq 9 + 11 t_1 + 12t_2$ 可以用指数锥来表示

$$
\begin{aligned}
u &= 7 + 3y_1 + 5y_2 \\
v &= 1 \\
w &= 9 + 11t_1 + 12t_2
\end{aligned}
$$

记 $\bm{x} = (y_1,y_2,t_1,t_2)^{\top}$ ，则线性约束矩阵 $A$ 和约束向量 $\bm{b}$ 如下：

$$
A = \begin{bmatrix}
-3 & -5 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & -11 & -12
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
7 \\
1 \\
9
\end{bmatrix}
$$

指数锥用函数 `K_expp()` 表示，锥优化问题的代码如下：

```{r}
# 锥约束
cexpp <- C_constraint(L = rbind(
  c(-3, -5, 0, 0), 
  c(0, 0, 0, 0),
  c(0, 0, -11, -12)
), cone = K_expp(1), rhs = c(7, 1, 9))
# 目标规划
expp <- OP(objective = c(1, 2, 0, 0), constraints = cexpp,
  bounds = V_bound(ld = -Inf, ub = c(20, 20, 50, 50)), 
  maximum = TRUE
)
expp
```

对于锥优化，可以调用 **scs** 包来求解。

```{r}
# 调用 scs 包
library(ROI.plugin.scs)
expp_sol <- ROI_solve(expp, solver = "scs")
# 最优解
expp_sol$solution
# 目标函数值
expp_sol$objval
```

### 幂锥

一个三维幂锥（Power Cone）的定义如下：

$$
\mathcal{K}_{\text{powp}}^{\alpha} = \{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1,x_2 \geq 0,x_1^{\alpha}x_2^{1-\alpha} \geq |x_3| \}, \alpha \in [0,1]
$$

它的对偶形式如下：

$$
\mathcal{K}_{\text{powp}}^{\alpha} = \Big\{(x_1, x_2,x_3) \in \mathbb{R}^3 | x_1,x_2 \geq 0,\big(\frac{x_1}{\alpha}\big)^{\alpha}\big(\frac{x_2}{1 - \alpha}\big)^{1-\alpha} \geq |x_3| \Big\}, \alpha \in [0,1]
$$

考虑如下锥优化问题

$$
\begin{aligned}
\min_{\bm{x}} \quad & 3x_1 + 5 x_2 \\
\text{s.t.} \quad & 5 + x_1 \leq (2 + x_2)^4 \\
\quad & x_1 \geq 0, ~ x_2 \geq 2
\end{aligned}
$$

约束条件 $5 + x_1 \leq (2 + x_2)^4$ 可以重新表示为幂锥

$$
\begin{aligned}
u &= 5 + y_1\\
v &= 1 \\
w &= 2 + y_2 \\
\alpha &= 1/4
\end{aligned}
$$

记 $\bm{x} = (y_1,y_2)^{\top}$ ，约束矩阵和约束向量如下

$$
A = \begin{bmatrix}
-1  & 0 \\
0   & 0 \\
0   & -1
\end{bmatrix}, \quad
\bm{b} = \begin{bmatrix}
5 \\
1 \\
2
\end{bmatrix}
$$

幂锥用函数 `K_powp()` 表示，锥优化问题的代码如下：

```{r}
A <- rbind(c(-1, 0), c(0, 0), c(0, -1))
cpowp <- C_constraint(L = A, cones = K_powp(1 / 4), rhs = c(5, 1, 2))
op <- OP(
  objective = c(3, 5),
  constraints = cpowp,
  bounds = V_bound(lb = c(0, 2))
)
op
```

```{r}
op_sol <- ROI_solve(op, solver = "scs", max_iter = 1e6)
op_sol$solution
op_sol$objval
```

### 半正定锥

如果矩阵 $A$ 是半正定的，记为 $A \succeq 0$ ，如果矩阵 $A$ 是正定的，记为 $A \succ 0$ 。记 $n$ 阶实对称矩阵的集合为 $\mathcal{S}^{n}$ 。半正定锥（Positive Semidefinite Cone）的定义如下：

$$
\mathcal{K}_{\text{psd}}^{n} = \{A | A \in \mathcal{S}^{n}, \bm{x}^{\top}A\bm{x} \geq 0, \forall \bm{x} \in \mathbb{R}^n \}
$$

考虑如下锥规划问题

$$
\begin{aligned}
\min_{\bm{x}} \quad & x_1 + x_2 - x_3 \\
\text{s.t.} \quad & 
x_1 \begin{bmatrix}
10  & 3 \\
3   & 10
\end{bmatrix} + 
x_2 \begin{bmatrix}
6  & -4 \\
-4   & 10
\end{bmatrix} + 
x_3 \begin{bmatrix}
8  & 1 \\
1  & 6
\end{bmatrix} \preceq 
\begin{bmatrix}
16  & -13 \\
-13  & 60
\end{bmatrix}
\\
\quad & x_1,x_2,x_3 \geq 0
\end{aligned}
$$

函数 `K_psd()` 表示半正定锥，函数 `vech()` 将对称矩阵的上三角部分拉成一个向量。

```{r}
(A <- toeplitz(x = 3:1))
vech(A)
```

锥规划的表示如下

```{r}
F1 <- rbind(c(10, 3), c(3, 10))
F2 <- rbind(c(6, -4), c(-4, 10))
F3 <- rbind(c(8, 1), c(1, 6))
F0 <- rbind(c(16, -13), c(-13, 60))
# 目标规划
op <- OP(
  objective = L_objective(c(1, 1, -1)),
  constraints = C_constraint(
    L = vech(F1, F2, F3),
    cones = K_psd(3),
    rhs = vech(F0)
  )
)
op
```

仍然调用 **scs** 求解器

```{r}
op_sol <- ROI_solve(op, solver = "scs")
op_sol$solution
op_sol$objval
```

## 非线性优化 {#sec-nonlinear-optimization}

非线性优化按是否带有约束，以及约束是线性还是非线性。

R 自带的函数 `nlminb()` 可求解无约束、箱式约束优化问题，`constrOptim()` 还可求解线性不等式约束优化，其中包括带线性约束的二次规划。`optim()` 提供一大类优化算法，且包含随机优化算法---模拟退火算法，可求解无约束、箱式约束优化问题。

### 无约束优化

#### 示例 1

Rastrigin 函数是多模态函数，有许多局部极小值。

$$
f(\bm{x})= \sum_{i=1}^{n}\big(x_i^2 - 10 \cos(2\pi x_i) + 10\big)
$$

计算函数值的 R 代码

```{r}
fn <- function(x) {
  sum(x^2 - 10 * cos(2 * pi * x) + 10)
}
```

二维 Rastrigin 函数图像

```{r}
#| label: fig-rastrigin
#| fig-cap: 二维 Rastrigin 函数图像
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(-4, 4, length.out = 151),
  y = seq(-4, 4, length.out = 151)
)

df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

设置 10 维的优化

```{r}
op <- OP(
  objective = F_objective(fn, n = 10L),
  bounds = V_bound(ld = -50, ud = 50, nobj = 10L)
)
```

调全局优化器求解非凸优化问题

```{r}
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$solution
nlp$objval
```

#### 示例 2

有如下复杂的目标函数

$$
\begin{aligned}
  & \min_x ~ \cos(x_1)\cos(x_2) - \sum_{i=1}^{5}\Big( (-1)^i \cdot i \cdot 2 \cdot \exp\big(-500 \cdot ( (x_1 - i \cdot 2)^2 + (x_2 - i\cdot 2)^2 ) \big) \Big) \\
  & \text{s.t.} ~ -50 \leq x_1, x_2 \leq 50
\end{aligned}
$$

```{r}
subfun <- function(i, m) {
  (-1)^i * i * 2 * exp(-500 * ((m[1] - i * 2)^2 + (m[2] - i * 2)^2))
}

fn <- function(x) {
  cos(x[1]) * cos(x[2]) -
    sum(mapply(FUN = subfun, i = 1:5, MoreArgs = list(m = x)))
}
```

目标函数的图像见 @fig-super-function ，搜索区域 $[-50, 50] \times [-50, 50]$ 内几乎没有变化的梯度，给寻优过程带来很大困难。

```{r}
#| label: fig-super-function
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-cap: 函数图像
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(-50, 50, length.out = 101),
  y = seq(-50, 50, length.out = 101)
)
df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

将区域 $[0, 12] \times [0, 12]$ 上的三维图像绘制出来，可见，有不少局部陷阱，且分布在 $x_2 = x_1$ 的直线上。

```{r}
#| label: fig-zoom-super-function
#| fig-cap: 局部放大的函数图像
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

df <- expand.grid(
  x = seq(0, 12, length.out = 151),
  y = seq(0, 12, length.out = 151)
)

df$fnxy <- apply(df, 1, fn)
wireframe(
  data = df, fnxy ~ x * y,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]),
  ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90), alpha = 0.75, 
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

最优解在 $(7.999982, 7.999982)$ 取得，目标函数值为 -7.978832。

```{r}
fn(x = c(7.999982, 7.999982))
```

面对如此复杂的函数，调用全局优化器寻优。

```{r}
op <- OP(
  objective = F_objective(fn, n = 2L),
  bounds = V_bound(ld = -50, ud = 50, nobj = 2L)
)
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$solution
nlp$objval
```

实际上，还是陷入局部最优解。运筹优化方面的商业软件，著名的有 Lingo 和 Matlab，下面采用 Lingo 20 求解，Lingo 代码如下：

```         
SETS:
P/1..5/;
Endsets
Min=@cos(x1) * @cos(x2) - @Sum(P(j): (-1)^j * j * 2 * @exp(-500 * ((x1 - j * 2)^2 + (x2 - j * 2)^2)));
@Bnd(-50, x1, 50);
@Bnd(-50, x2, 50);
```

启用全局优化求解器后，在 $(x_1 = 7.999982, x_2 = 7.999982)$ 取得最小值 -7.978832。而默认未启用全局优化求解器的情况下，在 $(x_1 = 18.84956, x_2 = -40.84070)$ 取得局部极小值 -1.000000。

在这种情况下，数值优化算法遇到瓶颈，可以采用一些全局随机优化算法，比如 **GA** 包 [@GA2013] 实现的遗传算法。经过对参数的一些调优，可以获得与商业软件几乎一样的结果。

```{r}
nlp <- GA::ga(
  type = "real-valued",
  fitness = function(x) -fn(x),
  lower = c(0, 0), upper = c(12, 12),
  popSize = 500, maxiter = 100, 
  monitor = FALSE, seed = 20232023
)
# 最优解
nlp@solution
# 目标函数值
nlp@fitnessValue
```

其中，参数 `type` 指定决策变量的类型，`type = "real-valued"` 表示目标函数中的决策变量是实值连续的，参数 `fitness` 是目标函数，函数 `ga()` 对目标函数求极大，所以，对当前优化问题，添加了一个负号。 参数 `popSize` 控制种群大小，值越大，运行时间越长，搜索范围越广，获得的全局优化解越好。对于复杂的优化问题，可以不断增加种群大小来寻优，直至增加种群大小也不能获得更好的解。参数 `maxiter` 控制种群进化的次数，值越大，搜索次数可以越多，获得的解越好。参数 `popSize` 的影响大于参数 `maxiter` ，减少陷入局部最优解（陷阱）的可能。根据已知条件尽可能缩小可行域，以减少种群数量，进而缩短算法迭代时间。

### 箱式约束优化

有如下箱式约束优化问题，示例来自函数 `nlminb()` 的帮助文档，目标函数和[香蕉函数](https://en.wikipedia.org/wiki/Rosenbrock_function)有些相似。

$$
\begin{array}{l}
  \min_x \quad  (x_1 - 1)^2 + 4\sum_{i =1}^{n -1}(x_{i+1} -x_i^2)^2  \\
  \text{s.t.} \quad 2 \leq x_1,x_2,\cdots,x_n \leq 4
\end{array}
$$

R 语言编码的函数代码如下：

```{r}
fn <- function(x) {
  n <- length(x)
  sum(c(1, rep(4, n - 1)) * (x - c(1, x[-n])^2)^2)
}
```

考虑二维的情形，绘制三维曲面图像，见 @fig-valley-persp 。如果没有约束，全局极小值点在 $(1,1)$ 处取得。

```{r}
#| label: fig-valley-persp
#| fig-cap: 类香蕉函数的曲面图
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| code-fold: true
#| echo: !expr knitr::is_html_output()

dat <- expand.grid(
  x1 = seq(from = 0, to = 4, length.out = 41),
  x2 = seq(from = 0, to = 4, length.out = 41)
)
dat$fn <- apply(dat, 1, fn)

wireframe(
  data = dat, fn ~ x1 * x2,
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]), ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90),
  scales = list(arrows = FALSE, col = "black"),
  shade.colors.palette = custom_palette,
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

$n$ 维目标函数是非线性的，给定初值 $(3, 3, \cdots, 3)$，下面求解 25 维的箱式约束，

```{r}
nlminb(
  start = rep(3, 25), objective = fn,
  lower = rep(2, 25), upper = rep(4, 25)
)
```

`nlminb()` 出于历史兼容性的原因尚且存在，最优解的第24个分量没有在可行域的边界上。使用 `constrOptim()` 函数求解，默认求极小，需将箱式或线性不等式约束写成矩阵形式，即 $Ax \geq b$ 的形式，参数 ui 是 $k \times n$ 的约束矩阵 $A$，ci 是右侧 $k$ 维约束向量 $b$。以上面的优化问题为例，将箱式约束 $2 \leq x_1,x_2 \leq 4$ 转化为矩阵形式，约束矩阵和向量分别为：

$$
A = \begin{bmatrix}
1  & 0  \\
0  & 1 \\
-1 & 0 \\
0  & -1
\end{bmatrix}, \quad
b = \begin{bmatrix}
2 \\
2 \\
-4 \\ 
-4
\end{bmatrix}
$$

```{r}
constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  method = "Nelder-Mead", # 没有提供梯度，则必须用 Nelder-Mead 方法
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

从求解的结果来看，`convergence = 1` 意味着迭代次数到达默认的极限 `maxit = 500`，结合 `nlminb()` 函数的求解结果来看，实际上还没有收敛。如果没有提供梯度，则必须用 Nelder-Mead 方法，下面增加迭代次数到 1000。

```{r}
constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  method = "Nelder-Mead", 
  control = list(maxit = 1000),
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

还是没有收敛，可见 Nelder-Mead 方法在这个优化问题上收敛速度比较慢。下面考虑调用基于梯度的优化算法 --- BFGS 方法。

```{r}
# 输入 n 维向量，输出 n 维向量
gr <- function(x) {
  n <- length(x)
  c(2 * (x[1] - 2), rep(0, n - 1))
  +8 * c(0, x[-1] - x[-n]^2)
  -16 * c(x[-n], 0) * c(x[-1] - x[-n]^2, 0)
}

constrOptim(
  theta = rep(3, 25), # 初始值
  f = fn, # 目标函数
  grad = gr,
  method = "BFGS", 
  control = list(maxit = 1000),
  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),
  ci = c(rep(2, 25), rep(-4, 25))
)
```

相比于 Nelder-Mead 方法，目标值 373 更大，可见已陷入局部最优解，下面通过 ROI 包，分别调用求解器 `nloptr.lbfgs` 和 `nloptr.directL` ，发现前者同样陷入局部最优解，而后者可以获得与 `nlminb()` 函数一致的结果。

```{r}
# 调用改进的 BFGS 算法
op <- OP(
  objective = F_objective(fn, n = 25L, G = gr),
  bounds = V_bound(ld = 2, ud = 4, nobj = 25L)
)
nlp <- ROI_solve(op, solver = "nloptr.lbfgs", start = rep(3, 25))
nlp$objval
nlp$solution
```

```{r}
# 调全局优化算法
nlp <- ROI_solve(op, solver = "nloptr.directL")
nlp$objval
nlp$solution
```

下面再与函数 `optim()` 提供的 `L-BFGS-B` 算法比较。

```{r}
optim(
  par = rep(3, 25), fn = fn, gr = NULL, method = "L-BFGS-B",
  lower = rep(2, 25), upper = rep(4, 25)
)
```

值得注意的是，当提供梯度信息的时候，虽然求解速度提升了，但是最优解变差了。

```{r}
optim(
  par = rep(3, 25), fn = fn, gr = gr, method = "L-BFGS-B",
  lower = rep(2, 25), upper = rep(4, 25)
)
```

### 非线性约束优化

**nloptr** 包的非线性优化能力覆盖开源优化软件 [Octave](https://www.octave.org/) 和 [Ipopt](https://github.com/coin-or/Ipopt) 。

#### 示例 1

-   非线性等式约束

示例来自 Octave 的[非线性优化帮助文档](https://octave.org/doc/v8.2.0/Nonlinear-Programming.html)，Octave 函数 `sqp()` 使用序列二次规划求解器（successive quadratic programming solver）解非线性规划问题，示例中该优化问题包含多个非线性等式约束。

$$
\begin{array}{l}
\min_x \quad \mathrm{e}^{\prod_{i=1}^{5} x_i} - \frac{1}{2}(x_1^3 + x_2^3 + 1)^2 \\
\text{s.t.} \left\{ 
  \begin{array}{l}
   \sum_{i=1}^{5}x_i^2 - 10 = 0 \\
   x_2 x_3 - 5x_4 x_5 = 0 \\
   x_1^3 + x_2^3 + 1 = 0
  \end{array} \right.
\end{array}
$$

目标函数是非线性的，包含 5 个变量，约束条件是非线性的，有 3 个等式约束。先手动计算目标函数的梯度，等式约束的雅可比矩阵。

```{r}
# 目标函数
fn <- function(x) {
  exp(prod(x)) - 0.5 * (x[1]^3 + x[2]^3 + 1)^2
}
# 目标函数的梯度
gr <- function(x) {
  c(
    exp(prod(x))*prod(x[-1]) - 3*(x[1]^3 + x[2]^3 + 1)*x[1]^2,
    exp(prod(x))*prod(x[-2]) - 3*(x[1]^3 + x[2]^3 + 1)*x[2]^2,
    exp(prod(x))*prod(x[-3]), 
    exp(prod(x))*prod(x[-4]),
    exp(prod(x))*prod(x[-5])
  )
}
# 等式约束
heq <- function(x) {
  c(
    sum(x^2) - 10,
    x[2] * x[3] - 5 * x[4] * x[5],
    x[1]^3 + x[2]^3 + 1
  )
}
# 等式约束的雅可比矩阵
heq.jac <- function(x) {
  matrix(c(2 * x[1], 2 * x[2], 2 * x[3], 2 * x[4], 2 * x[5],
    0, x[3], x[2], -5 * x[5], -5 * x[4],
    3 * x[1]^2, 3 * x[2]^2, 0, 0, 0),
    ncol = 5, byrow = TRUE
  )
}
```

在 `OP()` 函数里定义目标规划的各个成分。

```{r}
# 定义目标规划
op <- OP(
  # 5 个目标变量
  objective = F_objective(F = fn, n = 5L, G = gr), 
  constraints = F_constraint(
    F = list(heq = heq),
    dir = "==",
    rhs = 0,
    # 等式约束的雅可比矩阵
    J = list(heq.jac = heq.jac)
  ),
  bounds = V_bound(ld = -Inf, ud = Inf, nobj = 5L),
  maximum = FALSE # 求最小
)
op
```

调用 SQP（序列二次规划） 求解器

```{r}
nlp <- ROI_solve(op,
  solver = "nloptr.slsqp",
  start = c(-1.8, 1.7, 1.9, -0.8, -0.8)
)
nlp$solution
nlp$objval
```

计算结果和 Octave 的示例一致。

#### 示例 2

-   非线性等式约束
-   非线性不等式约束，不等式约束包含等号
-   箱式约束

此优化问题来源于 **Ipopt** 官网的[帮助文档](https://coin-or.github.io/Ipopt/INTERFACES.html)，约束条件比较复杂。提供的初始值为 $x_0 = (1,5,5,1)$，最优解为 $x_{\star} = (1.00000000,4.74299963,3.82114998,1.37940829)$。优化问题的具体内容如下：

$$
\begin{array}{l}
  \min_x \quad x_1 x_4 (x_1 + x_2 + x_3) + x_3 \\
    \text{s.t.} \left\{ 
    \begin{array}{l}
     x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40 \\
     x_1 x_2 x_3 x_4 \geq 25 \\
     1 \leq x_1, x_2, x_3, x_4 \leq 5
    \end{array} \right.
\end{array}
$$

下面用 **ROI** 调 **nloptr** 包求解，看结果是否和例子一致，**nloptr** 支持箱式约束且支持不等式约束包含等号。

```{r}
# 一个 4 维的目标函数
fn <- function(x) {
  x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3]
}
# 目标函数的梯度
gr <- function(x) {
  c(
    x[4] * (2 * x[1] + x[2] + x[3]), x[1] * x[4],
    x[1] * x[4] + 1, x[1] * (x[1] + x[2] + x[3])
  )
}
# 等式约束
heq <- function(x) {
  sum(x^2)
}
# 等式约束的雅可比
heq.jac <- function(x) {
  2 * c(x[1], x[2], x[3], x[4])
}
# 不等式约束
hin <- function(x) {
  prod(x)
}
# 不等式约束的雅可比
hin.jac <- function(x) {
  c(prod(x[-1]), prod(x[-2]), prod(x[-3]), prod(x[-4]))
}
# 定义目标规划
op <- OP(
  objective = F_objective(F = fn, n = 4L, G = gr), # 4 个目标变量
  constraints = F_constraint(
    F = list(heq = heq, hin = hin),
    dir = c("==", ">="),
    rhs = c(40, 25),
    # 等式和不等式约束的雅可比
    J = list(heq.jac = heq.jac, hin.jac = hin.jac)
  ),
  bounds = V_bound(ld = 1, ud = 5, nobj = 4L),
  maximum = FALSE # 求最小
)
```

作为对比参考，先计算目标函数的初始值和最优值。

```{r}
# 目标函数初始值
fn(c(1, 5, 5, 1))
# 目标函数最优值
fn(c(1.00000000, 4.74299963, 3.82114998, 1.37940829))
```

求解一般的非线性约束问题。

-   求解器 `nloptr.mma` / `nloptr.cobyla` 仅支持非线性不等式约束，不支持等式约束。
-   函数 `nlminb()` 只支持等式约束。

因此，下面分别调用 `nloptr.auglag`、`nloptr.slsqp` 和 `nloptr.isres` 来求解上述优化问题。

```{r}
nlp <- ROI_solve(op, solver = "nloptr.auglag", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

```{r}
nlp <- ROI_solve(op, solver = "nloptr.slsqp", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

```{r}
nlp <- ROI_solve(op, solver = "nloptr.isres", start = c(1, 5, 5, 1))
nlp$solution
nlp$objval
```

可以看出，**nloptr** 提供的优化能力可以覆盖 [Ipopt 求解器](https://github.com/coin-or/Ipopt)，从以上求解的情况来看，推荐使用 `nloptr.slsqp` 求解器，这也是 Octave 的选择。
