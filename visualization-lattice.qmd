# lattice 入门 {#sec-basic-lattice}

```{r}
#| echo: false

source("_common.R")
```

> If you imagine that this pen is Trellis, then Lattice is not this pen.
>
> --- Paul Murrell [^visualization-lattice-1]

[^visualization-lattice-1]: Paul 在 DSC 2001 大会上的幻灯片 见<https://www.stat.auckland.ac.nz/~paul/Talks/dsc2001.pdf>

**lattice** 最初是受到商业统计软件 S/S-Plus 中的 Trellis 组件启发，打算在 R 软件中重新实现一套新的绘图系统，在使用接口上保持与 Trellis 兼容，Trellis 使用文档也同样适用于 **lattice**。

本章主要介绍 **lattice** 包 [@Deepayan2008] 及其相关的 **latticeExtra** 包。

```{r}
#| message: false

library(lattice)
library(latticeExtra)
library(splines)
library(nlme)
library(mgcv)
library(maps)
library(sf)
library(RColorBrewer)
```

## 分组散点图 {#sec-lattice-xyplot}

```{r}
#| label: fig-lattice-xyplot-1
#| fig-width: 4.5
#| fig-height: 4
#| fig-showtext: true
#| fig-cap: 分组散点图

library(lattice)
xyplot(
  x = Sepal.Length ~ Petal.Length, groups = Species, scales = "free",
  data = iris, grid = TRUE, xlab = "萼片长度", ylab = "花瓣长度",
  auto.key = list(space = "top", columns = 3)
)
```

-   参数 `x` 需要传递 R 语言中的表达式，这是一种被广泛使用的公式语法，示例中为 `Sepal.Length ~ Petal.Length` ，表示横坐标为 `Petal.Length`， 纵坐标为 `Sepal.Length` 。
-   参数 `groups` 指定分组变量，此处为 `Species` 变量，表示鸢尾花种类。
-   参数 `scales` 设置坐标轴刻度， `scales = "free"` 表示去掉边框上面和右面的刻度线。
-   参数 `data` 指定绘图数据，此处为 `iris` 数据集。
-   参数 `grid` 控制是否添加背景网格线，此处为 `TRUE` 表示添加背景网格线。
-   参数 `xlab` 和参数 `ylab` 分别指定横、纵坐标轴标签。
-   参数 `auto.key` 设置图例，示例中将图例置于图形上方，条目排成 3 列。

除了上面介绍的几个参数，还有许多其它参数，其中一部分会在后续介绍其它种类的图形时顺带介绍，剩余的部分请感兴趣的读者查看函数 `xyplot()` 的帮助文档。

## 图形参数 {#sec-lattice-par}

```{r}
#| label: fig-lattice-par
#| fig-cap: lattice 图形参数设置
#| echo: false
#| fig-width: 6.5
#| fig-height: 6.5
#| fig-showtext: true

show.settings(x = trellis.par.set(list(
  axis.text = list(fontfamily = "sans"), # 轴标签字体
  add.text = list(fontfamily = "mono"), # 注释文本字体
  par.main.text = list(fontfamily = "sans"), # 主标题字体
  par.sub.text = list(fontfamily = "serif") # 副标题字体
)))
```

在之前的 @fig-lattice-xyplot-1 的基础上，添加回归线。通过图形参数 `par.settings` 设置各类绘图元素的符号类型和大小，该参数接受一个列表类型的数据，列表的元素还是列表，列表的层层嵌套实现图中元素的精细控制。列表元素 `superpose.symbol` 控制点的符号，`pch = 16` 设置为 16，相比于默认的点要大一号。列表元素 `superpose.line` 控制线，`lwd = 2` 设置宽度为 2，比默认的宽度大一倍，`lty = 3` 设置线的类型为 3，表示虚线。

```{r}
#| label: fig-lattice-xyplot-2
#| fig-width: 5.5
#| fig-height: 4
#| fig-showtext: true
#| fig-cap: 调整点线基础元素

xyplot(
  x = Sepal.Length ~ Petal.Length, groups = Species, scales = "free",
  data = iris, grid = TRUE, xlab = "萼片长度", ylab = "花瓣长度",
  auto.key = list(space = "top", columns = 3), type = c("p", "r"),
  par.settings = list(
    superpose.symbol = list(pch = 16),
    superpose.line = list(lwd = 2, lty = 3)
  )
)
```

## 常见图形 {#sec-common-lattice}

### 回归曲线图 {#sec-lattice-smoother}

-   **splines** 自然立方样条 `ns()`
-   **mgcv** 广义可加模型 `s()`

```{r}
#| label: fig-lattice-colours
#| fig-width: 3
#| fig-height: 3
#| fig-cap: 调色板
#| fig-showtext: true
#| echo: false

scales::show_col(colours = c("#4285f4", "#34A853", "#FBBC05", "#EA4335"))
```

@fig-lattice-smoother 中用不同的回归模型拟合数据中的趋势。1920s 汽车行驶距离和速度的关系图。函数 `panel.smoother()` 来自 **latticeExtra** 包

```{r}
#| label: fig-lattice-smoother
#| fig-width: 4.5
#| fig-height: 4
#| layout-ncol: 2
#| layout-nrow: 2
#| fig-cap: 回归曲线图
#| fig-subcap:
#| - 线性回归
#| - 局部多项式回归
#| - 自然样条回归
#| - 广义可加回归
#| fig-showtext: true

library(splines)
library(mgcv)
library(latticeExtra)
xyplot(dist ~ speed,
  data = cars, scales = "free", xlab = "速度", ylab = "距离",
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    panel.smoother(y ~ x,
      col.line = "#EA4335", method = "lm", ...
    )
  }
)
xyplot(dist ~ speed,
  data = cars, scales = "free", xlab = "速度", ylab = "距离",
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    panel.smoother(y ~ x,
      col.line = "#4285f4", method = "loess", span = 0.9, ...
    )
  }
)
xyplot(dist ~ speed,
  data = cars, scales = "free", xlab = "速度", ylab = "距离",
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    panel.smoother(y ~ ns(x, 5),
      col.line = "#34A853", method = "lm", ...
    )
  }
)
xyplot(dist ~ speed,
  data = cars, scales = "free", xlab = "速度", ylab = "距离",
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    panel.smoother(y ~ s(x),
      col.line = "#FBBC05", method = "gam", ...
    )
  }
)
```

### 分组箱线图 {#sec-lattice-boxplot}

```{r}
#| label: fig-lattice-bwplot
#| fig-width: 4.5
#| fig-height: 4
#| fig-cap: 分组箱线图
#| fig-showtext: true

bwplot(Petal.Length ~ Species,
  data = iris, scales = "free",
  xlab = "鸢尾花种类", ylab = "花瓣长度"
)
```

### 分组柱形图 {#sec-lattice-barchart}

本节所用数据集 `Insurance` 来自 **MASS** 包，记录一家保险公司面临风险的投保人数量，以及在 1973 年第 3 季度他们提出汽车理赔的数量。数据类型、各个变量的类型及部分预览数据如下：

```{r}
data(Insurance, package = "MASS")
str(Insurance)
```

其中，District 表示投保人居住的地区，因子型变量。Group 汽车按油箱大小分组的变量，有序的因子型变量。Age 投保人的年龄段标签，有序的因子型变量。Holders 投保人数量，整型变量。Claims 理赔数量，整型变量。下 @fig-lattice-barchart 先按投保人的汽车类型分面，再按投保人所在地区分组，展示理赔频度与投保人年龄的关系。

```{r}
#| label: fig-lattice-barchart
#| fig-width: 6
#| fig-height: 6
#| fig-cap: 分组柱形图
#| fig-showtext: true

barchart(
  Claims / Holders ~ Age | Group, groups = District,
  data = Insurance, xlab = "年龄段", ylab = "理赔频度",
  auto.key = list(space = "top", columns = 4, title = "地区", cex.title = 1)
)
```

函数 `barchart()` 中的公式 `Claims / Holders ~ Age | Group` ，斜杠 `/` 表示除法，波浪线 `~` 表示响应变量与自变量的分界，竖线 `|` 表示分面。

### 置信区间图 {#sec-lattice-segplot}

各个郡县每 10 万人当中因癌症死亡的人数。`USCancerRates` 数据集来自 **latticeExtra** 包，记录各个郡县的癌症死亡率及其置信区间，下图展示新泽西州各个郡县的癌症死亡率及其置信区间。

```{r}
#| label: fig-lattice-segplot
#| fig-width: 6
#| fig-height: 5
#| fig-cap: 置信区间图
#| fig-showtext: true

segplot(reorder(county, rate.male) ~ LCL95.male + UCL95.male,
  data = subset(USCancerRates, state == "New Jersey"),
  draw.bands = FALSE, centers = rate.male,
  scales = list(x = list(alternating = 1, tck = c(1, 0))),
  xlab = "癌症死亡率", ylab = "郡县"
)
```

### 经验分布图 {#sec-lattice-step}

用阶梯图表示累积经验分布图，纵轴表示累积概率，不同种类的鸢尾花，花瓣长度的分布明显不同。根据 Glivenko--Cantelli 定理，经验分布函数以概率 1 收敛至累积分布函数。

```{r}
#| label: fig-lattice-ecdfplot
#| fig-showtext: true
#| fig-cap: 经验分布图
#| fig-width: 6
#| fig-height: 4

ecdfplot(~ Petal.Length | Species, data = iris, scales = "free", 
         xlab = "花瓣长度", ylab = "累积概率")
```

### 分面水平图 {#sec-lattice-facet}

```{r}
#| label: fig-lattice-facet
#| fig-cap: 分面水平图
#| fig-width: 6.5
#| fig-height: 6
#| fig-showtext: true

depth.ord <- rev(order(quakes$depth))
quakes$Magnitude <- equal.count(quakes$mag, 4)
quakes.ordered <- quakes[depth.ord, ]

levelplot(depth ~ long + lat | Magnitude,
  data = quakes.ordered, scales = "free",
  panel = panel.levelplot.points, 
  prepanel = prepanel.default.xyplot, 
  type = c("p", "g"), layout = c(2, 2)
)
```

### 三维透视图 {#sec-lattice-wireframe}

有如下参数方程

$$
\begin{aligned}
\left\{ 
 \begin{array}{l}
x(u,v) = \cos(u)\big(r + \cos(u / 2)\big) \\
y(u,v) = \sin(u)\big(r + \cos(u / 2)\sin(tv) - \sin(u / 2)\sin(2tv)\big)\sin(tv) -
    \sin(u / 2)\sin(2tv) \\
z(u,v) = \sin(u / 2) \sin(tv) + \cos(u / 2) \sin(tv)
\end{array} \right.
\end{aligned}
$$

其中，$u$ 和 $v$ 是参数，$\frac{u}{2\pi} \in [0.3,1.25], \frac{v}{2\pi} \in [0,1]$，$r$ 和 $t$ 是常量，不妨设 $r = 2$ 和 $t=1$ 。

```{r}
#| label: fig-levelplot-wireframe
#| fig-cap: 三维透视图
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true

# lattice 书 6.3.1 节 参数
kx <- function(u, v) cos(u) * (r + cos(u / 2))
ky <- function(u, v) {
  sin(u) * (r + cos(u / 2) * sin(t * v) -
    sin(u / 2) * sin(2 * t * v)) * sin(t * v) -
    sin(u / 2) * sin(2 * t * v)
}
kz <- function(u, v) sin(u / 2) * sin(t * v) + cos(u / 2) * sin(t * v)
n <- 50
u <- seq(0.3, 1.25, length = n) * 2 * pi
v <- seq(0, 1, length = n) * 2 * pi
um <- matrix(u, length(u), length(u))
vm <- matrix(v, length(v), length(v), byrow = TRUE)
r <- 2
t <- 1

wireframe(kz(um, vm) ~ kx(um, vm) + ky(um, vm),
  shade = TRUE, drape = FALSE,
  xlab = expression(x[1]), ylab = expression(x[2]),
  zlab = list(expression(
    italic(f) ~ group("(", list(x[1], x[2]), ")")
  ), rot = 90), alpha = 0.75,
  scales = list(arrows = FALSE, col = "black"),
  # 减少三维图形的边空
  lattice.options = list(
    layout.widths = list(
      left.padding = list(x = -0.5, units = "inches"),
      right.padding = list(x = -1.0, units = "inches")
    ),
    layout.heights = list(
      bottom.padding = list(x = -1.5, units = "inches"),
      top.padding = list(x = -1.5, units = "inches")
    )
  ),
  par.settings = list(axis.line = list(col = "transparent")),
  screen = list(z = 30, x = -65, y = 0)
)
```

### 地形轮廓图 {#sec-lattice-contour}

奥克兰火山地形图

```{r}
#| label: fig-levelplot-volcano
#| fig-cap: 奥克兰火山的地形轮廓图
#| fig-width: 6
#| fig-height: 4
#| fig-showtext: true

levelplot(volcano,
  col.regions = hcl.colors, useRaster = TRUE,
  # 去掉图形上、右边多余的刻度线
  scales = list(
    x = list(alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ),
  par.settings = list(
    # x/y 轴标签字体，刻度标签字体
    par.xlab.text = list(fontfamily = "Noto Serif CJK SC"),
    par.ylab.text = list(fontfamily = "Noto Serif CJK SC"),
    axis.text = list(fontfamily = "sans")
  ),
  xlab = "南北方向", ylab = "东西方向"
)
```

参数 `col.regions` 需要传递一个函数，示例中函数 `hcl.colors()` 默认使用 viridis 调色板，其它常见的还有函数 `gray.colors()` 、`terrain.colors()` 和 `topo.colors()` 等，还可以用函数 `colorRampPalette()` 构造调色板函数。

函数 `panel.2dsmoother()` 来自 **latticeExtra** 包，数据的二维分布，默认采用 `tp` thin plate regression spline 回归样条方法平滑。

```{r}
#| label: fig-levelplot-topo
#| fig-width: 4.5
#| fig-height: 4
#| fig-showtext: true
#| fig-cap: 轮廓图
#| message: false

library(mgcv)
data(topo, package = "MASS")
levelplot(z ~ x * y, data = topo, scales = "free",
  panel = panel.2dsmoother, contour = TRUE,
  form = z ~ s(x, y), method = "gam",
  xlab = "水平方向", ylab = "垂直方向"
)
```

### 置信椭圆图 {#sec-lattice-ellipse}

**latticeExtra** 包的函数 `panel.ellipse()` 可以绘制置信椭圆。二维数据

```{r}
#| label: fig-lattice-ellipse
#| fig-width: 4.5
#| fig-height: 4
#| fig-showtext: true
#| fig-cap: 分组置信椭圆图

xyplot(Sepal.Length ~ Petal.Length,
  groups = Species, data = iris, scales = "free",
  xlab = "萼片长度", ylab = "花瓣长度",
  par.settings = list(
    superpose.symbol = list(pch = 16),
    superpose.line = list(lwd = 2, lty = 3)
  ),
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    panel.ellipse(x, y, ...)
  },
  auto.key = list(space = "top", columns = 3)
)
```

### 地区分布图 {#sec-lattice-choropleth}

最后一个想要介绍的是地区分布图，也叫面量图、围栏图，描述空间栅格数据的分布，常见的一种情况是展示各个地区的人口、社会、经济指标。下面通过 **tigris** 包可以下载美国人口调查局发布的数据，本想下载与观测数据年份最近的地图数据，但是 2009 年及以前的地图数据缺失，因此，笔者下载了 2010 年的地图数据，它与得票率数据最近。

```{r}
#| eval: false
#| echo: true

library(tigris)
us_state_map <- states(cb = TRUE, year = 2010, resolution = "20m", class = "sf")
us_state_map <- shift_geometry(us_state_map, geoid_column = "STATE", position = "below")
```

第一行代码用 **tigris** 包的函数 `states()` 下载 2010 年比例尺为 1:20000000 的多边形州边界矢量地图数据，返回一个 simple feature 类型的空间数据类型。第二行代码用该包的另一个函数 `shift_geometry()` 移动离岸的州和领地，将它们移动到主体部分的下方。

```{r}
#| message: false

library(sf)
us_state_sf <- readRDS("data/us-state-map-2010.rds")
# sf 转 sp
us_state_sp <- as(us_state_sf, "Spatial")
library(maps)
# sp 转 map
us_state_map <- SpatialPolygons2map(us_state_sp, namefield = "NAME")
# 准备观测数据
data(votes.repub)
# 转为 data.frame 类型
votes_repub <- as.data.frame(votes.repub)
```

数据集 `votes.repub` 记录 1856-1976 年美国历届大选中共和党在各州的得票率。图中以由红到蓝的颜色变化表示由低到高的得票率，1964 年共和党在东南一隅得票率较高，在其它地方得票率普遍较低，形成一边倒的情况，最终由民主党的林登·约翰逊当选美国第36任总统。1968 年共和党在东南部得票率最低，与 1964 年相比，整个反过来了，最终由共和党的理查德·尼克松当选美国第37任总统。

```{r}
#| label: fig-lattice-choropleth
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 5
#| fig-cap: 共和党在各州的得票率

library(RColorBrewer)
rdbu_pal <- colorRampPalette(colors = brewer.pal(n = 11, name = "RdBu"))
mapplot(rownames(votes_repub) ~ `1964` + `1968`, data = votes_repub,
  border = NA, map = us_state_map, colramp = rdbu_pal, layout = c(1, 2),
  scales = list(draw = FALSE), xlab = "", ylab = ""
)
```

参数 `border` 设置州边界线的颜色，NA 表示去掉边界线。参数 `map` 设置州边界地图数据。参数 `colramp` 设置一个调色板，用于将得票率与调色板上的颜色映射起来。美国历届大选，共和党和民主党竞争总统职位，最终由得票率决定，用红蓝对抗型调色板表现竞争关系。基于 **RColorBrewer** 包的 `RdBu` 调色板，用函数 `colorRampPalette()` 构造一个新的红蓝调色板。参数 `layout` 将多个子图按照一定顺序排列，图中设置 2 行 1 列的多图布局。参数 `scales` 用来调整刻度，设置 `list(draw = FALSE)` 将图中的刻度去掉了。参数 `xlab` 设置一个空字符，即 `xlab = ""` 可去掉横坐标轴标签，参数 `ylab` 应用于设置纵坐标，用法与参数 `xlab` 一样。图中，主要表现得票率在各州的分布，因此，坐标轴刻度和标签都不太重要，可以去掉。

## 总结 {#sec-basic-lattice-summary}

现在回过头来看，无论是图形样式还是绘图语法， **lattice** 可以看作是介于 Base R 和 **ggplot2** 之间的一种绘图风格。举例来说，下面比较 Base R 和 **lattice** 的图形样式。

```{r}
#| label: fig-lattice-vs-base
#| fig-width: 4
#| fig-height: 4
#| fig-showtext: true
#| fig-cap: 对比 Base R 和 lattice 制作的分组散点图
#| layout-ncol: 2
#| par: true
#| fig-subcap:
#| - Base R 图形
#| - lattice 图形

plot(Sepal.Length ~ Petal.Length, col = Species, data = iris,
  xlab = "萼片长度", ylab = "花瓣长度"
)
xyplot(Sepal.Length ~ Petal.Length, groups = Species, data = iris,
  scales = "free", xlab = "萼片长度", ylab = "花瓣长度"
)
```

与函数 `plot()` 对应的是函数 `xyplot()` ，它们共用一套公式语法，参数 `data` 的含义也是一样的。与参数 `col` 对应的是参数 `groups` ，作用是添加数据分组标识。在两个函数中，添加横纵坐标轴标签都是用参数 `xlab` 和 `ylab` 。函数 `xyplot()` 中参数 `scales` 的作用是对坐标轴刻度的调整，参数值 `"free"` 表示去掉图形上边和右边的刻度线，默认情况下是有刻度线的。

在高级的绘图函数方面，Base R 和 **lattice** 基本都有功能对应的函数，在低水平的绘图函数方面，二者截然不同，主要是因为后者基于另一套绘图系统 --- **grid** 绘图系统。Base R 作图常常需要一个函数一个函数地不断叠加，在图中画上点、线、轴、标签等元素，而 **lattice** 主要通过面板函数，层层叠加的方式，每一个面板函数实现一个功能，整合一系列绘图操作。本章主要介绍 **lattice** 包和 **latticeExtra** 包，用到的高级绘图函数如下表。

| R 包             | 函数                 | 图形       | 作用         |
|------------------|----------------------|------------|--------------|
| **lattice**      | `xyplot()`           | 分组散点图 | 描述关系     |
| **lattice**      | `bwplot()`           | 分组箱线图 | 描述分布     |
| **lattice**      | `barchart()`         | 分组柱形图 | 描述对比     |
| **lattice**      | `levelplot()`        | 地形轮廓图 | 描述趋势     |
| **lattice**      | `wireframe()`        | 三维透视图 | 描述趋势     |
| **latticeExtra** | `segplot()`          | 置信区间图 | 描述不确定性 |
| **latticeExtra** | `panel.smoother()`   | 回归曲线图 | 描述趋势     |
| **latticeExtra** | `panel.2dsmoother()` | 地形轮廓图 | 描述趋势     |
| **latticeExtra** | `ecdfplot()`         | 经验分布图 | 描述分布     |
| **latticeExtra** | `panel.ellipse()`    | 置信椭圆图 | 描述分布     |
| **latticeExtra** | `mapplot()`          | 地区分布图 | 描述分布     |

: lattice 和 latticeExtra 包的部分函数 {#tbl-lattice-extra}
