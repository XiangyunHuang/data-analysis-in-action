# 数据可视化 {#data-visualization}


```{r}
#| echo: false

knitr::knit_hooks$set(par = function(before, options, envir) {
  if (before && options$fig.show != "none") {
    par(
      mar = c(4, 4, .5, .5)
    )
  }
})

if (xfun::is_macos()) {
  # 准备 Noto 中英文字体
  sysfonts::font_paths(new = "~/Library/Fonts/")
  ## 宋体
  sysfonts::font_add(
    family = "Noto Serif CJK SC",
    regular = "NotoSerifCJKsc-Regular.otf",
    bold = "NotoSerifCJKsc-Bold.otf"
  )
  ## 黑体
  sysfonts::font_add(
    family = "Noto Sans CJK SC",
    regular = "NotoSansCJKsc-Regular.otf",
    bold = "NotoSansCJKsc-Bold.otf"
  )
} else { # Github Action Ubuntu
  sysfonts::font_paths(new = c(
    "/usr/share/fonts/opentype/noto/",
    "/usr/share/fonts/truetype/noto/"
  ))
  ## 宋体
  sysfonts::font_add(
    family = "Noto Serif CJK SC",
    regular = "NotoSerifCJK-Regular.ttc",
    bold = "NotoSerifCJK-Bold.ttc"
  )
  ## 黑体
  sysfonts::font_add(
    family = "Noto Sans CJK SC",
    regular = "NotoSansCJK-Regular.ttc",
    bold = "NotoSansCJK-Bold.ttc"
  )
}

## 衬线字体
sysfonts::font_add(
  family = "Noto Serif",
  regular = "NotoSerif-Regular.ttf",
  bold = "NotoSerif-Bold.ttf",
  italic = "NotoSerif-Italic.ttf",
  bolditalic = "NotoSerif-BoldItalic.ttf"
)
## 无衬线字体
sysfonts::font_add(
  family = "Noto Sans",
  regular = "NotoSans-Regular.ttf",
  bold = "NotoSans-Bold.ttf",
  italic = "NotoSans-Italic.ttf",
  bolditalic = "NotoSans-BoldItalic.ttf"
)
```


## 本章介绍 {#sec-intro-to-ggplot2}

:::{.callout-tip}
其它小节完成后再写本节。
:::

数据可视化的主要目的有两个：其一是探索 Explore，其二是解释 Explain。

大多教科书侧重理论和方法，计算机强调编程，数值计算是精确的，图形是粗燥的。然而，只有模型和方法，缺乏数据探索的分析和建模，计算的结果和分析的结论可能是不正确的，数据可能在欺骗你[@Anscombe1973]。

[**datasauRus**](https://github.com/jumpingrivers/datasauRus) 包 [@datasauRus2022] 内置了一个数据集 datasaurus_dozen，它整合了 13 个子数据集，它们在均值、标准差等描述性统计量方面十分接近，见下 @tbl-datasaurus-summ 。其中 $\bar{x},\sigma_x$ 分别代表预测变量 $X$ 的均值和标准差，$\bar{y},\sigma_y$ 代表响应变量 $Y$ 的均值和标准差，$\beta_0,\beta_1$ 代表回归方程 @eq-datasaurus-lm 的截距和斜率，$R^2$ 代表模型拟合数据的程度。

$$
y = \beta_0 + \beta_1 x + \epsilon
$$ {#eq-datasaurus-lm}

```{r}
#| echo: false
#| label: tbl-datasaurus-summ
#| tbl-cap: "datasaurus_dozen 数据集的一些描述性统计量和线性回归结果"

data("datasaurus_dozen", package = "datasauRus")
library(data.table)
datasaurus_dozen <- as.data.table(datasaurus_dozen)
datasaurus_summ <- datasaurus_dozen[, cbind.data.frame(
  x_mean = mean(x),
  x_sd = sd(x),
  y_mean = mean(y),
  y_sd = sd(y),
  as.list(coef(lm(y ~ x))),
  r_squared = summary(lm(y ~ x))$r.squared #,
  # adj_r_squared = summary(lm(y ~ x))$adj.r.squared,
  # rse = sqrt(sum(residuals(lm(y ~ x))^2)/(.N - 2))
), by = .(dataset)]

knitr::kable(datasaurus_summ, col.names = c(
  "子数据集", "$\\bar{x}$", "$\\sigma_x$", "$\\bar{y}$", "$\\sigma_y$",
  "$\\beta_0$", "$\\beta_1$", "$R^2$" #, "调整的 $R^2$", "残差标准差"
), digits = 3, escape = FALSE)
```


诸多统计量都难以发现它们的差异，透过数据可视化这面照妖镜，却可以使数据的本来面目无所遁形，如 @fig-datasaurus-dozen 所示。可见，单个统计量就好比管窥蠡测，稍有不慎，我们就成了盲人摸象。


```{r}
#| label: fig-datasaurus-dozen
#| fig-cap: "数据可视化为何如此重要"
#| fig-width: 6
#| fig-height: 6
#| fig-showtext: true
#| echo: false

library(ggplot2)
ggplot(datasaurus_dozen, aes(x = x, y = y)) +
  geom_point(aes(colour = dataset), show.legend = FALSE) +
  facet_wrap(facets = ~dataset, ncol = 4) +
  theme_void() +
  theme(strip.text = element_blank())
```

数据可视化的重要性在于探索数据的真实分布，为数据建模提供假设和依据，也为验证、评估模型的效果。结合 @fig-datasaurus-dozen 也解释了为什么线性回归模型在解释数据方面的无能为力，即 $R^2$ 介于 0.004 至 0.005 之间，数据根本不符合线性模型的条件。


有时候是有的数据符合模型假设，而有的不符合，我们没有上帝之眼，看不到哪些符合哪些不符合。在数据集不多的情况下，可以全部展示出来，数据集很多的时候，可以抽样一部分，再展示。下面再举一个例子，anscombe 数据集来自 R 软件内置的 R 包 **datasets**，它包含四组数据 $(x_i, y_i), i =1,2,3,4$，如 @tbl-anscombe-datasets 所示。

```{r}
#| label: tbl-anscombe-datasets
#| tbl-cap: "anscombe 数据集"
#| echo: false

new_order <- unlist(lapply(1:4, function(x) paste(c("x", "y"), x, sep = "")))
# knitr::kable(anscombe[, new_order], booktabs = T) |>
#   kableExtra::kable_styling(
#     bootstrap_options = "basic",
#     full_width = F, position = "center"
#   ) |>
#   kableExtra::add_header_above(c(
#     "第1组" = 2, "第2组" = 2,
#     "第3组" = 2, "第4组" = 2
#   ))

# flextable::flextable(anscombe[, new_order]) |>
#   flextable::add_header_row(
#     colwidths = c(2, 2, 2, 2),
#     values = c("第1组", "第2组", "第3组", "第4组")
#   )

gt::gt(anscombe[, new_order]) |> 
  gt::tab_spanner(label = "第1组", columns = c("x1", "y1")) |> 
  gt::tab_spanner(label = "第2组", columns = c("x2", "y2")) |> 
  gt::tab_spanner(label = "第3组", columns = c("x3", "y3")) |> 
  gt::tab_spanner(label = "第4组", columns = c("x4", "y4"))
```

用统计的方法发现四组数据的样本均值、方差、相关系数和回归系数几乎是相同的，实际上，借助散点 @fig-anscombe 分别描述各组数据的关系时，却发现四组数据之间有极大的差异，且只有第一组数据看起来符合线性模型的条件 [@Anscombe1973]。

```{r}
#| label: fig-anscombe
#| echo: false
#| fig-cap: "数据可视化为何如此重要"
#| fig-subcap: 
#| - "第一组数据"
#| - "第二组数据"
#| - "第三组数据"
#| - "第四组数据"
#| fig-width: 3
#| fig-height: 3
#| fig-showtext: true
#| fig-ncol: 2

library(ggplot2)
data(anscombe)
p <- ggplot(data = anscombe) +
  theme_classic()
p +
  geom_point(aes(x = x1, y = y1), color = "#E41A1C") +
  geom_smooth(aes(x = x1, y = y1),
    color = "#E41A1C",
    formula = y ~ x, method = "lm", se = FALSE
  )

p +
  geom_point(aes(x = x2, y = y2), color = "#377EB8") +
  geom_smooth(aes(x = x2, y = y2),
    color = "#377EB8",
    formula = y ~ x, method = "lm", se = FALSE
  )
p +
  geom_point(aes(x = x3, y = y3), color = "#4DAF4A") +
  geom_smooth(aes(x = x3, y = y3),
    color = "#4DAF4A",
    formula = y ~ x, method = "lm", se = FALSE
  )
p +
  geom_point(aes(x = x4, y = y4), color = "#984EA3") +
  geom_smooth(aes(x = x4, y = y4),
    color = "#984EA3",
    formula = y ~ x, method = "lm", se = FALSE
  )
```

图形还告诉我们第二组数据的更适合二次非线性回归，第三组数据受到离群点的重大影响，第四组数据自变量只有两个取值，像是两个分布按不同比例混合的结果。


## 图形实例 {#sec-case-study}

### 老忠实间歇泉喷发规律 {#sec-faithful}

@fig-faithful-bkde2d 展示美国怀俄明州黄石国家公园[老忠实间歇泉](https://en.wikipedia.org/wiki/Old_Faithful)喷发规律，横轴表示喷发持续时间（以分钟计），纵轴表示等待时间（以分钟计），点的亮暗程度（白到黑）代表附近点密度的高低，亮度值通过二维核密度估计方法得到，具体实现借助了 **KernSmooth** [@KernSmooth1995] 包提供的 `bkde2D()` 函数，设置了喷发时间的窗宽为 0.7 分钟，等待时间的窗宽为 7分钟。不难看出，每等待55分钟左右间歇泉喷发约2分钟，或者每等待80分钟左右间歇泉喷发4.5约分钟，非常守时，表现得很老实，故而得名。说实话，二维核密度估计在这里有点大材小用了，因为数据点比较少，肉眼也能分辨出来哪里聚集的点多，哪里聚集的点少。

```{r}
#| label: fig-faithful-bkde2d
#| echo: false
#| par: true
#| fig-cap: "二维核密度估计"
#| fig-subcap: 
#| - "faithful 数据集的散点图"
#| - "点的亮暗表示核密度估计值的大小"
#| - "等高线表示核密度估计值"
#| - "等高线表示核密度估计值"
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true
#| fig-ncol: 2
#| message: false
#| out-width: '50%'

# faithful 添加二维核密度估计 density 列
library(KernSmooth)
den <- bkde2D(x = faithful, bandwidth = c(0.7, 7), gridsize = c(51L, 51L))
faithful2d <- expand.grid(eruptions = den$x1, waiting = den$x2) |>
  transform(density = as.vector(den$fhat))

plot(faithful,
  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,
  xlim = c(0.5, 6.5),
  ylim = c(35, 100)
)
title(xlab = "喷发时间", ylab = "等待时间", family = "Noto Serif CJK SC")

plot(faithful,
  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,
  xlim = c(0.5, 6.5),
  ylim = c(35, 100),
  col = densCols(faithful,
    bandwidth = c(0.7, 7),
    nbin = c(51L, 51L), colramp = hcl.colors
  )
)
title(xlab = "喷发时间", ylab = "等待时间", family = "Noto Serif CJK SC")

plot(faithful,
  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,
  xlim = c(0.5, 6.5),
  ylim = c(35, 100),
  col = densCols(faithful,
    bandwidth = c(0.7, 7),
    nbin = c(51L, 51L), colramp = hcl.colors
  )
)
contour(den$x1, den$x2, den$fhat, nlevels = 10, add = TRUE, family = "Noto Sans")
title(xlab = "喷发时间", ylab = "等待时间", family = "Noto Serif CJK SC")

# 散点添加颜色
mkBreaks <- function(u) u - diff(range(u)) / (length(u) - 1) / 2
# faithful 划入网格内
xbin <- cut(faithful[, 1], mkBreaks(den$x1), labels = FALSE)
ybin <- cut(faithful[, 2], mkBreaks(den$x2), labels = FALSE)
# 网格对应的核密度估计值即为 faithful 对应的核密度估计值
faithful$dens <- den$fhat[cbind(xbin, ybin)]
# 若是 faithful 数据点没有划分，则置为 0 
faithful$dens[is.na(faithful$dens)] <- 0

library(ggplot2)
library(ggnewscale)

ggplot() +
  geom_point(
    data = faithful, aes(x = eruptions, y = waiting, color = dens),
    shape = 20, size = 2, show.legend = FALSE
  ) +
  scale_colour_viridis_c(option = "D") +
  new_scale_color() +
  geom_contour(data = faithful2d, aes(
    x = eruptions, y = waiting,
    z = density, colour = after_stat(level)
  ), bins = 14, linewidth = 0.45, show.legend = FALSE) +
  scale_colour_viridis_c(option = "C", direction = -1, begin = 0.2, end = 0.8) +
  # colorspace::scale_color_continuous_sequential(palette = "Grays") +
  scale_x_continuous(breaks = 1:6) +
  scale_y_continuous(breaks = 10 * 4:10) +
  coord_cartesian(xlim = c(0.5, 6.5), ylim = c(35, 100)) +
  labs(x = "喷发时间", y = "等待时间", colour = "密度") +
  theme_bw(base_size = 13) +
  theme(
    legend.title = element_text(family = "Noto Serif CJK SC"),
    axis.title = element_text(family = "Noto Serif CJK SC"),
    axis.title.x = element_text(
      margin = margin(b = 0, l = 0, t = 20, r = 0)
    ),
    axis.title.y = element_text(
      margin = margin(b = 0, l = 0, t = 0, r = 20)
    ),
    panel.border = element_rect(color = "black"),
    panel.grid = element_blank(),
    panel.grid.major = element_line(
      color = "lightgray",
      linetype = 3, linewidth = 0.5
    ),
    axis.ticks.length = unit(0.25, "cm"),
    axis.text.x = element_text(
      family = "Noto Sans", color = "black",
      vjust = -1.5, size = rel(1.25)
    ),
    axis.text.y = element_text(
      family = "Noto Sans", color = "black",
      angle = 90, vjust = 1.5, hjust = 0.5,
      size = rel(1.25)
    )
  )
```


:::{.callout-tip}
函数 `bkde2D()` 实现二维带窗宽的核密度估计（2D Binned Kernel Density Estimate），R 语言存在多个版本，**grDevices** 包的函数 `densCols()` 直接调用 **KernSmooth** 包的函数 `bkde2D()`，**graphics** 包的函数 `smoothScatter()` 与函数 `densCols()` 一样，内部也是调用 `bkde2D()` 函数，**ggplot2** 包的图层 `geom_density_2d()` 采用 **MASS** 包的函数 `kde2d()`，在算法实现上，`MASS::kde2d()` 与 `KernSmooth::bkde2D()` 不同，前者是二维核密度估计（Two-Dimensional Kernel Density Estimation）。
:::


<!-- 
在不规则的区域上插值，geom_contour 和 geom_contour_filled 先调用 interp::interp() 或 akima::bilinear()

[interp](https://cran.r-project.org/package=interp)

规则的方形网格上，二元高斯核

核密度估计方法在可视化中应用是相当广泛的，下面简单介绍核密度估计的原理，做到知其然且知其所以然

多维核平滑方法见文献 @Chacon2018

密度估计和二维平滑方法 参考书籍
https://cswr.nrhstat.org/
-->


### 斐济及其周边地震活动 {#sec-fiji-quakes}

<!-- 空间数据探索、分析、可视化，空间分析，空间 -->

将震级分割成三个区间，并以明暗不同的颜色表示震级大小，接着，根据斐济及周边地区的位置，选择相应的坐标参考系，最后，用 ggplot2 深度定制出 @fig-quakes-sf ，相比于 @fig-quakes 更加清晰、准确地反映了数据情况，目标区域位于南半球，横跨 180 度经线。

```{r}
#| label: fig-quakes-sf
#| echo: false
#| fig-cap: "太平洋岛国斐济及其周边的地震分布"
#| message: false
#| fig-width: 5
#| fig-height: 4
#| fig-showtext: true

library(sf)
quakes_sf <- st_as_sf(quakes, coords = c("long", "lat"), crs = st_crs(4326))

# library(rnaturalearth)
# library(rnaturalearthdata)
## 需要 rnaturalearthdata 包
# fiji_medium <- ne_countries(country = "fiji", scale = "medium", returnclass = "sf")
# nz_medium <- ne_countries(country = "New Zealand", scale = "medium", returnclass = "sf")
# ggplot() +
#   geom_sf(data = fiji_medium, fill = "gray") +
#   geom_sf(data = nz_medium, fill = "gray") +
#   geom_sf(
#     data = quakes_sf, aes(color = cut(mag, 3))
#   ) +
#   scale_colour_brewer(palette = "Greys") +
#   coord_sf(
#     crs = 3460,
#     xlim = c(569061, 3008322),
#     ylim = c(1603260, 4665206)
#   ) +
#   theme_minimal() +
#   labs(x = "经度", y = "纬度", color = "震级")
# st_bbox 获取数据 quakes_sf 的边界
# 地理图层 geom_sf 支持通过 scale_x_continuous 设定刻度标签
# 也可以借助 st_graticule 构造经纬网数据，再添加一个地理图层 geom_sf 
ggplot() +
  geom_sf(
    data = quakes_sf, aes(color = cut(mag, 6))
  ) +
  scale_x_continuous(breaks = c(
    # 东经
    seq(from = 165, to = 180, by = 5),
    # 西经
    seq(from = -180, to = -170, by = 5)
  )) +
  scale_colour_brewer(
    palette = "Greys",
    labels = c(
      "(4.0,4.4]", "(4.4,4.8]", "(4.8,5.2]",
      "(5.2,5.6]", "(5.6,6.0]", "(6.0,6.4]"
    )
  ) +
  coord_sf(
    crs = 3460,
    xlim = c(569061, 3008322),
    ylim = c(1603260, 4665206)
  ) +
  theme_minimal() +
  labs(x = "经度", y = "纬度", color = "震级")
```

有的地理区域处于板块交界处，地震频发，以至于 @fig-quakes-sf 部分区域的散点覆盖严重，影响重点区域的观测。因此，将斐济及周边区域划分成 $40 \times 80$ 的网格，统计每个小格子内散点的数量，即地震次数，再将地震次数映射给颜色。相比于 @fig-quakes-sf，@fig-quakes-grid-sf 可以更加清晰地展示地震活跃度的空间分布。

```{r}
#| label: fig-quakes-grid-sf
#| echo: false
#| fig-cap: "斐济及其周边的地震活动"
#| message: false
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

# 目标区域划分成 40x80 的网格
quakes_grid_sf <- st_make_grid(quakes_sf, n = c(40, 80))
# 统计每个区域内包含的点的数量，也就是地震次数
quakes_grid_cnt <- st_sf(
  count = lengths(st_intersects(quakes_grid_sf, quakes_sf)),
  geometry = st_cast(quakes_grid_sf, "MULTIPOLYGON")
)
# 将多边形绘制出来，以地震次数填充颜色
ggplot() +
  geom_sf(
    data = quakes_grid_cnt[quakes_grid_cnt$count > 0, ],
    aes(fill = count), linewidth = 0.01
  ) +
  scale_fill_viridis_c(option = "C") +
  scale_x_continuous(breaks = c(
    # 东经
    seq(from = 165, to = 180, by = 5),
    # 西经
    seq(from = -180, to = -170, by = 5)
  )) +
  coord_sf(
    crs = 3460,
    xlim = c(569061, 3008322),
    ylim = c(1603260, 4665206)
  ) +
  theme_minimal() +
  labs(x = "经度", y = "纬度", fill = "频次")
```

@fig-quakes-grid-sf 通过将连续空间离散化，再统计各个小网格中地震次数，而 @fig-quakes-density-ppp 将地震活动看作是一种随机事件，用非参数的方法 --- 二维核密度估计方法计算各个位置发生地震活动的可能性。

```{r}
#| label: fig-quakes-density-ppp
#| echo: false
#| fig-cap: "斐济及其周边的地震活动"
#| message: false
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

## 基于 sf 对象构造
quakes_sf <- st_transform(quakes_sf, crs = 3460)
# 组合 POINT 构造 POLYGON
quakes_sfp <- st_cast(st_combine(st_geometry(quakes_sf)), "POLYGON")
# 构造 POLYGON 的凸包
quakes_sfp_hull <- st_convex_hull(st_geometry(quakes_sfp))
# 添加 buffer 
quakes_sfp_buffer <- st_buffer(quakes_sfp_hull, dist = 100000)
# planar point pattern 表示 ppp 
# sf 转化为 ppp 类型
quakes_ppp <- spatstat.geom::as.ppp(X = st_geometry(quakes_sf))
# 限制散点在给定的窗口边界内平滑
spatstat.geom::Window(quakes_ppp) <- spatstat.geom::as.owin(quakes_sfp_buffer)
# 高斯核密度估计 36*36 的网格
# density.ppp 的含义是什么？统计原理是什么？
# dimyx 指定先 y 后 x
# spatstat 版本 3.0-0 以后 spatstat.core 包被拆分成 spatstat.explore 和 spatstat.model 两个包
# 届时得用 spatstat.explore::density.ppp 替换 spatstat.core::density.ppp
density_spatstat <- spatstat.core::density.ppp(quakes_ppp, 
                                               dimyx = c(36, 36), 
                                               kernel = "gaussian")
# 转化为 stars 对象 栅格数据
density_stars <- stars::st_as_stars(density_spatstat)
# 设置坐标参考系
density_sf <- st_set_crs(st_as_sf(density_stars), 3460)

ggplot() +
  geom_sf(data = density_sf, aes(fill = v), col = NA) +
  geom_sf(data = st_boundary(quakes_sfp_hull), linewidth = 0.25) +
  geom_sf(data = st_boundary(quakes_sfp_buffer), linewidth = 0.5) +
  scale_fill_viridis_c(
    option = "C", trans = "log10",
    labels = scales::label_log(),
    limits = c(1e-12, 1e-9)
  ) +
  scale_x_continuous(breaks = c(
    # 东经
    seq(from = 165, to = 180, by = 5),
    # 西经
    seq(from = -180, to = -170, by = 5)
  )) +
  labs(x = "经度", y = "纬度", fill = "密度") +
  theme_minimal()
```

### 美国近88年男性死亡率变化 {#sec-usa-mortality}

<!-- 函数型数据探索、分析和可视化，趋势分析，时间 -->

@fig-usa-mortality 展示美国 1933-2020 年男性分年龄的死亡率数据[^usa-mortality]。图分上下两部分，上半部分展示死亡率原值随年龄的变化情况，以 ggplot2 默认的调色板给各个年份配色，下半部分展示死亡率对数变换后随年龄的变化情况，并以红、橙、黄、绿、青、蓝、紫构造彩虹式的调色板给各个年份配色。作图过程中，使用对数变换和调用彩虹式的调色板，帮助我们观察到更多的细节、层次。对数变换后，更加清晰地展示死亡率的变化，尤其是 0-20 岁之间的死亡率起伏变化。调用彩虹式的调色板后，约 20 年为一个阶段，每个阶段内呈现梯度变化，多个阶段体现层次性，更加清晰地展示死亡率曲线的变动趋势，透过层次看到 80 多年来，美国在医疗和公共卫生方面取得的显著改善。

[^usa-mortality]: 数据来自德国马克斯普朗克人口研究所、美国加州大学伯克利分校、法国人口研究所共同建立的人类死亡率数据库 (<https://www.mortality.org/>)。


```{r}
#| label: fig-usa-mortality
#| fig-cap: "1933-2020 年美国男性死亡率曲线"
#| fig-width: 6
#| fig-height: 6
#| echo: false
#| fig-showtext: true

usa_mortality <- readRDS(file = "data/usa-mortality-2020.rds")
library(patchwork)
p1 <- ggplot(data = usa_mortality, aes(x = Age, y = Male, group = Year)) +
  geom_vline(xintercept = "100", colour = "gray", lty = 2) +
  geom_line(aes(color = Year), linewidth = 0.25) +
  scale_x_discrete(
    breaks = c("0", "20", "40", "60", "80", "100"),
    labels = c("0", "20", "40", "60", "80", "100")
  ) +
  theme_classic() 
p2 <- p1 +
  labs(x = "年龄", y = "死亡率", color = "年份")
p3 <- p1 +
  scale_y_log10(labels = scales::label_log()) +
  scale_colour_gradientn(colors = pals::tol.rainbow()) +
  labs(x = "年龄", y = "死亡率（对数尺度）", color = "年份")
p2 / p3
```

@fig-usa-mortality 也展示了很多基础信息，出生时有很高的死亡率，出生后死亡率迅速下降，一直到10岁，死亡率才又开始回升，直到 20 岁，死亡率才回到出生时的水平。之后，在青年阶段死亡率缓慢增加，直至老年阶段达到很高的死亡率水平。相比于老年阶段，医疗水平的改善作用主要体现在婴儿、儿童、青少年阶段。

@fig-usa-mortality 还展示了一个潜在的数据质量问题，在 100 岁之后，死亡率波动程度明显在变大，这是因为高龄人数变得很少，即死亡率的分母变得很小，分子的细小波动会被放大，也因为同样的原因，100 岁以上的死亡率主要依赖模型估计，甚至出现死亡率大于 1 的罕见情况。因此，就对比医疗和公共卫生水平的变化而言，从数据的实际情况出发，100 岁以上的情况可以不参与比较。




### 子代身高与亲代身高的关系 {#sec-galton}

<!-- 函数型数据探索、分析和可视化，关系 -->

[弗朗西斯·高尔顿](https://galton.org/)（Francis Galton, 1822-1911）是历史上著名的优生学家、遗传学家和统计学家，是统计学中相关和回归等一批概念的提出者，是遗传学中回归现象的发现者。1885年，高尔顿以保密和给予金钱报酬的方式，向社会征集了 205 对夫妇及其 928 个成年子女的身高数据[@Galton1886]。

目前，Michael Friendly 从原始文献中整理后，将该数据集命名为 `GaltonFamilies`，放在 R 包 **HistData** [@Friendly2021] 内，方便大家使用。篇幅所限，下 @tbl-galton 展示该数据集的部分内容。

```{r}
#| echo: false
#| label: tbl-galton
#| tbl-cap: "高尔顿收集的 205 对夫妇及其子女的身高数据（部分）"

library(data.table)
data(GaltonFamilies, package = "HistData")
GaltonFamilies <- as.data.table(GaltonFamilies)

knitr::kable(head(GaltonFamilies), col.names = c(
  "家庭编号", "父亲身高", "母亲身高", "中亲身高",
  "子女数量", "子女编号", "子女性别", "子女身高"
))
```

表中子女性别一栏，Male 表示男性，Female 表示女性。表中 1 号家庭父亲身高 78.5 英寸，母亲身高 67.0 英寸，育有 4 个成年子女，1 男 3 女，子女身高依次是 73.2 英寸、 69.2 英寸、 69.0 英寸 和 69.0 英寸。1 英寸相当于 2.54 厘米，78.5 英寸相当于 199.39 厘米，约等于 2 米的身高。

高尔顿提出「中亲」概念，即父母的平均身高，认为子代身高只与父母平均身高相关，而与父母身高差无关，为了消除性别给身高带来的差异，女性身高均乘以 1.08。

根据数据统计的均值和协方差，椭圆 level = 0.95

```{r}
#| label: fig-galton-gender
#| fig-cap: "子代身高与亲代身高的关系"
#| fig-width: 6
#| fig-height: 5
#| echo: false
#| fig-showtext: true

ggplot(data = GaltonFamilies, aes(x = midparentHeight, y = childHeight, color = gender)) +
  geom_point(aes(fill = gender), pch = 21, color = "white", 
             size = 2, alpha = 0.75) +
  geom_smooth(method = "lm", formula = "y~x", se = FALSE) +
  stat_ellipse(type = "norm", level = 0.95, linetype = 2) +
  scale_color_brewer(palette = "Set1", labels = c(male = "男", female = "女")) +
  scale_fill_brewer(palette = "Set1", labels = c(male = "男", female = "女")) +
  guides(fill = guide_legend(reverse = TRUE), 
         color = guide_legend(reverse = TRUE)) +
  labs(x = "父母平均身高", y = "子女身高", fill = "性别", color = "性别") +
  theme_classic()
```


女儿的身高乘以 1.08 后，两条回归线将几乎重合。

```{r}
#| label: fig-galton
#| fig-cap: "子代身高与亲代身高的关系"
#| fig-width: 6
#| fig-height: 5
#| echo: false
#| fig-showtext: true

GaltonFamilies[, height_children := childHeight * c("female" = 1.08, "male" = 1)[gender]] |>
  ggplot(aes(x = midparentHeight, y = height_children, color = gender)) +
  geom_smooth(method = "lm", formula = "y~x", se = FALSE) +
  geom_point(size = 1, alpha = 0.75) +
  stat_ellipse( type = "norm", linetype = 2) +
  scale_color_brewer(palette = "Set1", labels = c(male = "男", female = "女")) +
  labs(x = "父母平均身高", y = "子女身高", color = "性别") +
  theme_classic()
```


```{r}
#| eval: false
#| echo: false

GaltonFamilies[, height_children := childHeight * c("female" = 1.08, "male" = 1)[gender]][, as.list(coef(lm(height_children ~ midparentHeight))), by = "gender"]
```



```{r}
#| label: fig-galton-bivar
#| echo: false
#| par: true
#| fig-cap: "二维核密度估计与二元正态分布"
#| fig-width: 4.5
#| fig-height: 4.5
#| fig-showtext: true

data(Galton, package = "HistData")
plot(Galton,
  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,
  xlim = c(63.5, 73.5),
  ylim = c(61, 74.5),
  col = densCols(Galton,
    bandwidth = c(1, 1),
    nbin = c(11L, 11L), colramp = hcl.colors
  )
)
reg <- lm(child ~ parent, data = Galton)
abline(reg, lwd = 2)
lines(lowess(x = Galton$parent, y = Galton$child), col = "blue", lwd = 2)
library(KernSmooth)
den <- bkde2D(x = Galton, bandwidth = c(1, 1), gridsize = c(11L, 11L))
contour(den$x1, den$x2, den$fhat, nlevels = 10, add = TRUE, family = "Noto Sans")
title(xlab = "父母平均身高", ylab = "子女身高", family = "Noto Serif CJK SC")
```





### 预期寿命与人均收入的关系 {#sec-state-x77}

<!-- 相关性探索、分析和可视化，关系 -->

生物遗传的回归现象，更确切地说是因果而不是相关，是一种近似的函数关系。与回归紧密相连的是另一个统计概念是相关，主要刻画数量指标之间的关系深浅程度，相关系数是其中一个度量。在经济、社会领域中，很多数据指标存在相关性，接下来的这个例子基于 1977 年美国人口调查局发布的统计数据，篇幅所限，下 @tbl-state-x77 展示美国各州的部分统计数据。

```{r}
#| echo: false
#| label: tbl-state-x77
#| tbl-cap: "1977 年美国人口调查局发布的各州统计数据（部分）"

state_x77 <- data.frame(state.x77,
  state_name = rownames(state.x77),
  state_region = state.region,
  check.names = FALSE
)

knitr::kable(head(state_x77[, c(
  "state_name", "state_region", "Population",
  "Income", "Life Exp"
)]), col.names = c(
  "州名", "区域划分", "人口数量",
  "人均收入", "预期寿命"
), row.names = FALSE)
```

该数据集在 R 环境中的结构如下：

```{r}
str(state_x77)
```

它是一个 50 行 10 列的数据框，其中，state_name（州名）是字符型变量， state_region（区域划分）是因子型变量。除了这两个变量外，Population（人口数量，单位：1000），Income（人均收入，单位：美元），Life Exp（预期寿命，单位：岁）等都是数值型的变量。下 @fig-state-x77-scatter 展示了1977 年美国各州的预期寿命和人均收入的关系，通过此图，可以初步观察出两个指标存在一些明显的正向相关性，也符合常识。


```{r}
#| label: fig-state-x77-scatter
#| fig-cap: "1977 年美国各州预期寿命与人均收入的关系：散点图"
#| fig-width: 4.5
#| fig-height: 3.5
#| echo: false
#| fig-showtext: true

library(ggplot2)
ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point() +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局"
  ) +
  theme_classic() +
  theme(
    panel.grid = element_line(colour = "gray92"),
    panel.grid.major = element_line(linewidth = rel(1.0)),
    panel.grid.minor = element_line(linewidth = rel(0.5))
  )
```

为了更加清楚地观察到哪些州预期寿命长，哪些州人均收入高，在 @fig-state-x77-scatter 基础上，在散点旁边添加州名。此外，为了观察各州的地域差异，根据各州所属区域，给散点分类，最后，将各州人口数量映射给散点的大小，形成如下 @fig-state-x77-bubble 所示的分类气泡图。

```{r}
#| label: fig-state-x77-bubble
#| fig-cap: "1977 年美国各州预期寿命与人均收入的关系：分地域气泡图"
#| fig-width: 7
#| fig-height: 5.5
#| echo: false
#| fig-showtext: true

library(ggplot2)
library(ggrepel)
library(scales)
ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point(aes(size = 1000 * Population, color = state_region)) +
  geom_text_repel(aes(label = state_name), size = 3, seed = 2022) +
  scale_size(labels = label_number(scale_cut = cut_short_scale())) +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系（分地域）",
    caption = "数据源：美国人口调查局",
    size = "人口数量", color = "区域划分"
  ) +
  theme_classic() +
  theme(
    panel.grid = element_line(colour = "gray92"),
    panel.grid.major = element_line(linewidth = rel(1.0)),
    panel.grid.minor = element_line(linewidth = rel(0.5))
  )
```

整体来说，预期寿命与人均收入息息相关。


```{r}
#| label: fig-state-x77-lm
#| fig-cap: "1977 年美国各州预期寿命与人均收入的关系：回归分析"
#| fig-width: 7
#| fig-height: 5.5
#| echo: false
#| fig-showtext: true

ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point(aes(size = 1000 * Population, color = state_region)) +
  geom_smooth(method = "lm", formula = "y~x") +
  geom_text_repel(aes(label = state_name), size = 3, seed = 2022) +
  scale_size(labels = label_number(scale_cut = cut_short_scale())) +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局",
    size = "人口数量", color = "区域划分"
  ) +
  theme_classic() +
  theme(
    panel.grid = element_line(colour = "gray92"),
    panel.grid.major = element_line(linewidth = rel(1.0)),
    panel.grid.minor = element_line(linewidth = rel(0.5))
  )
```



:::{.callout-tip}
从 @fig-state-x77-bubble 到 @fig-state-x77-lm ，尝试初步量化两个变量之间的相关性之前，有没有想过，回归线应该更加陡峭一些，即回归线的斜率应该更大一些，是什么原因导致平缓了这么多？是阿拉斯加州和内华达州的数据偏离集体太远。那又是什么原因导致阿拉斯加州人均收入全美第一，而预期寿命倒数呢？同样的，内华达州的人均收入也不低，但预期寿命为什么上不去呢？
:::



```{r}
#| eval: false
#| echo: false
ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +
  geom_point(aes(size = 1000 * Population, color = state_region)) +
  geom_smooth(method = "lm", formula = "y~x", color = "red") +
  geom_smooth(data = function(x) subset(x, !state_name %in% c("Nevada", "Alaska") ), method = "lm", formula = "y~x", color = "green") +
  geom_text_repel(aes(label = state_name), size = 3, seed = 2022) +
  scale_size(labels = label_number(scale_cut = cut_short_scale())) +
  labs(
    x = "人均收入（美元）", y = "预期寿命（年）",
    title = "1977 年各州预期寿命与人均收入的关系",
    caption = "数据源：美国人口调查局",
    size = "人口数量", color = "区域划分"
  ) +
  theme_classic() +
  theme(
    panel.grid = element_line(colour = "gray92"),
    panel.grid.major = element_line(linewidth = rel(1.0)),
    panel.grid.minor = element_line(linewidth = rel(0.5))
  )
```




### 解释置信区间及其覆盖概率 {#sec-coverage-probability}

<!-- 统计理论、方法的可视化，理论 -->

统计图形很重要的一个作用是解释统计概念，这就要求不拘泥于抽象的严格数学表达，借助数值模拟，可视化等手段帮助读者发散思维，加深理解复杂的逻辑概念，建立统计直觉，正如顾恺之所言「以形写神，形神兼备」。下面仅以二项分布为例讲讲区间估计及其覆盖概率。众所周知，在置信水平为 $1 - \alpha$ 的情况下，二项分布 $\mathrm{Bin}(n,p)$ 的参数 $p$ （也叫成功概率）的 Wald 区间估计为 $(\hat{p} - Z_{1-\alpha/2} \sqrt{\hat{p}*(1-\hat{p})/n}, \hat{p} + Z_{1-\alpha/2} \sqrt{\hat{p}*(1-\hat{p})/n})$，这里 $n$ 为样本量，$Z_{1-\alpha/2}$ 为标准正态分布 $\mathcal{N}(0,1)$ 在 $1-\alpha/2$ 处的分位点，一般 $\alpha$ 取 0.05，进而 $Z_{1-\alpha/2} \approx 1.96$。用通俗的话说，有 $1 - \alpha$ 的把握确定参数真值 $p$ 在该估计区间内，可见区间估计的意义是解决点估计可靠性问题，但是可靠性和精度往往不能兼得。统计上，通常的做法是先给定可靠性，去尽可能提升精度，即给定置信水平，使估计区间的长度尽可能短，这就涉及到区间估计的方法问题。

下面通过数值模拟的方式辅助说明 Wald 和 Agresti-Coull 两种区间估计方法，现固定样本量 $n = 10$ 或 $n = 100$，重复抽样 1000 次，将参数 $p$ 以 0.01 的间隔离散化，从 0.01 取值到 0.99。已知给定参数 $p$，每次抽样都可以得到参数 $p$ 的估计值 $\hat{p}$ 及其置信区间，1000 次的重复抽样可以计算出来 1000 个置信区间，每个区间要么覆盖真值，要么没有覆盖真值，覆盖的比例可以近似为覆盖概率。

如 @fig-coverage 所示，从上往下分别代表 Wald、 Agresti-Coull 和 Wilson 区间估计，纵坐标是覆盖概率，横坐标是参数 $p$ 的真值，图中黑虚线表示置信水平 $1-\alpha=0.95$，红、蓝点线分别表示样本量 $n=10$ 和 $n=100$ 的模拟情况。不难看出，Wald 区间估计方法在小样本情况下表现很差，覆盖概率很少能达到置信水平的，而 Agresti-Coull 区间估计在 Wald 基础上添加了修正后，情况得到显著改善，详细的介绍见文献 @Blyth1960;@Lawrence2001;@Geyer2005 。


```{r}
#| label: fig-coverage
#| fig-cap: "二项分布参数的几种区间估计：覆盖概率随成功概率的变化"
#| fig-width: 6
#| fig-height: 6
#| fig-showtext: true
#| echo: false

# Wald 覆盖
coverage_wald <- function(p = 0.1, n = 10, nsim = 1000) {
  phats <- rbinom(nsim, prob = p, size = n) / n
  ll <- phats - qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)
  ul <- phats + qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)
  mean(ll < p & ul > p)
}
# Agresti-Coull 覆盖
coverage_agresti <- function(p = 0.1, n = 10, nsim = 1000) {
  phats <- (rbinom(nsim, prob = p, size = n) + 2) / (n + 4)
  ll <- phats - qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)
  ul <- phats + qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)
  mean(ll < p & ul > p)
}
# Clopper and Pearson (1934)
coverage_clopper <- function(p = 0.1, n = 10, nsim = 1000) {
  phats <- rbinom(nsim, prob = p, size = n) / n
  ll <- 0
  ul <- 0
  mean(ll < p & ul > p)
}
# Wilson (1927)
coverage_wilson <- function(p = 0.1, n = 10, nsim = 1000) {
  phats <- rbinom(nsim, prob = p, size = n) / n
  lambda <- qnorm(1 - 0.05 / 2)
  ll <- phats + lambda^2 / (2 * n) - lambda * sqrt(phats * (1 - phats) / n + lambda^2 / (4 * n^2))
  ul <- phats + lambda^2 / (2 * n) + lambda * sqrt(phats * (1 - phats) / n + lambda^2 / (4 * n^2))
  mean(ll / (1 + lambda^2 / n) < p & ul / (1 + lambda^2 / n) > p)
}

sim_dat <- transform(expand.grid(
  p = seq(0.01, 0.99, by = 0.01),
  n = c(10, 100),
  nsim = 1000,
  methods = c("Wald", "Agresti-Coull", "Wilson")
),
prob = ifelse(methods == "Wald",
  Vectorize(coverage_wald)(p = p, n = n, nsim = nsim),
  ifelse(methods == "Agresti-Coull",
    Vectorize(coverage_agresti)(p = p, n = n, nsim = nsim), 
    Vectorize(coverage_wilson)(p = p, n = n, nsim = nsim)
  )
),
nsample = ifelse(n == 10, "n=10", "n=100")
)

ggplot(data = sim_dat, aes(x = p, y = prob, color = nsample)) +
  geom_hline(yintercept = 0.95, linetype = 2, 
             linewidth = 1, color = "gray60") +
  geom_point() +
  geom_path() +
  # annotate(geom = "text", x = 0, y = 0.95, label = "0.950",
  #          fontface = "bold", hjust = 2, size = 3.5) +
  # scale_color_grey() +
  scale_color_brewer(palette = "Set1") +
  facet_wrap(facets = ~methods, ncol = 1, scales = "free_y") +
  labs(x = "成功概率", y = "覆盖概率", color = "样本量") +
  theme_bw(base_size = 13, base_family = "Noto Sans") +
  theme(title = element_text(family = "Noto Serif CJK SC")) + 
  coord_cartesian(clip = 'off')
```

通过 @fig-coverage 一看就明白了几种区间估计方法的优劣，以及为什么软件普遍默认采用 Wilson 估计方法？因为它又稳定又准确。 Wilson 区间估计用的更加广泛的，Base R 内置的二项比例检验函数 `prop.test()` 在不启用 Yates 修正时，就是用该方法获得比例 $p$ 的区间估计[@Wilson1927]。




:::{.callout-tip}
请读者再思考两个问题： @fig-coverage 为什么呈现对称的形式，泊松分布会和二项分布有类似的现象吗？如果有的话，连续分布，如正态分布和指数分布也会有吗？
:::





## 作图工具 {#sec-overview-of-ggplot2}


### 基础作图系统 {#sec-base-graphics}

尽管 **ggplot2** 非常流行，但并不意味着它比前辈们如 Base R 或 **lattice** [@Deepayan2008] 更加优秀，它们只是各领风骚。知晓各自的优缺点，更加有助于你选择合适的工具应用到合适的场景中。

这里以 Base R 内置的地震数据集 quakes 为例，如 @fig-quakes 所示，展示太平洋岛国斐济及其周边的地震分布，左图是一行 **ggplot2** 绘图代码生成的图形，如果你的目的是看看数据情况，那到此结束。甚至还可以更快、更简单点，直接调用 Base R 的函数 `plot()`，这是探索数据，而不是表达洞见。

```{r}
#| eval: false
#| echo: true
#| label: quakes-quick

# ggplot2 绘图
library(ggplot2)
ggplot(data = quakes, aes(x = long, y = lat)) + geom_point()
# Base R 绘图
plot(data = quakes, lat ~ long)
```


```{r}
#| label: fig-quakes
#| echo: false
#| fig-cap: "太平洋岛国斐济及其周边的地震分布"
#| fig-width: 4
#| fig-height: 3
#| fig-subcap: 
#|  - "ggplot2 默认设置"
#|  - "Base R 默认设置"
#| layout-ncol: 2
#| fig-showtext: true
#| par: true

# ggplot2 绘图
library(ggplot2)
ggplot(data = quakes, aes(x = long, y = lat)) + geom_point()
# Base R 绘图
plot(data = quakes, lat ~ long)
```


所以，若以出版级的要求， **ggplot2** 绘图并不简单，那比 Base R 又如何呢？以 Base R 内置的 pressure 数据集为例，展示汞蒸气的压力随温度的变化趋势，如 @fig-pressure 所示，左子图用区区 3 行 Base R 代码就搞定了，而右子图用 15 行 **ggplot2** 代码才勉强达到相似的效果。类似的情况绝不仅限于描述趋势的点线图，归根结底，是刻画图形细节的要素都差不多，只是表达方式不同罢了。




<!-- 
比如示例(<https://stackoverflow.com/questions/27934840/>)用 Base R 复现一张直方图，示例(<https://stackoverflow.com/questions/3932038/>)给 Base R 图形添加图例，网站(<http://motioninsocial.com/tufte/>)更是用 Base R、**ggplot2** 和 **lattice** 分别绘制了 9 种常见统计图形。反之，用 Base R 实现 **ggplot2** 风格图形，也不那么简单，以分类散点图为例，详见博客 [Styling plots in base R graphics to match ggplot2 classic theme](https://www.tenderisthebyte.com/blog/2021/05/09/pretty-plots-with-base-r-grahpics/)。 
-->


```{r}
#| label: fig-pressure
#| fig-cap: "汞蒸气的压力随温度的指数级变化"
#| fig-subcap: 
#|  - Base R 图形
#|  - ggplot2 图形
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true
#| fig-ncol: 2
#| par: true
#| echo: false

# Base R 图形
plot(pressure, type = "b", pch = 19, ann = FALSE)
title(xlab = "温度", ylab = "压力")
# ggplot2 图形
library(ggplot2)
ggplot(data = pressure, aes(x = temperature, y = pressure)) +
  geom_line() +
  geom_point(size = 2) +
  labs(x = "温度", y = "压力") +
  scale_x_continuous(breaks = seq(0, 400, by = 50)) +
  theme_bw(base_size = 13) +
  theme(
    axis.title = element_text(),
    axis.title.x = element_text(
      margin = margin(b = 0, l = 0, t = 20, r = 0)
    ),
    axis.title.y = element_text(
      margin = margin(b = 0, l = 0, t = 0, r = 20)
    ),
    panel.border = element_rect(color = "black"),
    panel.grid = element_blank(),
    axis.ticks.length = unit(0.25, "cm"),
    axis.text.x = element_text(
      color = "black",
      vjust = -1.5, size = rel(1.25)
    ),
    axis.text.y = element_text(
      color = "black",
      angle = 90, vjust = 1.5, hjust = 0.5,
      size = rel(1.25)
    )
  )
```


@fig-pressure 所用数据集 pressure 来自 Base R 自带的 **datasets** 包，描述汞蒸气压力（以毫米计）随温度（以摄氏度计）的变化。为美观起见，除了设置字体外，右图以黑白主题替换了默认的灰色主题，调整了横、纵坐标轴标题到坐标轴的距离，面板边界线从灰色调为黑色，取消背景网格线，轴须增加至0.25厘米，适当增加了刻度标签的大小和位置。再和原始的 ggplot2 的图形对比，@fig-pressure-ugly 所示，美颜前后已不可同日而语，能解决最重要的 20% 细节问题就能让整个档次显著提升，达到让大多数人认可的水准。当然，一味地追求统一 Base R 风格或 ggplot2 风格是没有必要的，举此例也无意宣扬 Base R 绘图的简便，展示 ggplot2 绘图的复杂，简便和复杂往往不是由工具决定的，而是数据本身和工具使用的场景。将错误的工具放在错误的数据上，除了能带来实现上的技术挑战，造出一堆难以理解的图形垃圾，还可能误导受众。

```{r}
#| label: fig-pressure-ugly
#| fig-cap: "ggplot2 默认的风格"
#| echo: false
#| fig-width: 4.5
#| fig-height: 3.5
#| fig-showtext: true

# https://github.com/Mikata-Project/ggthemr
# 书籍就绪后，考虑统一颜色主题
ggplot(data = pressure, aes(x = temperature, y = pressure)) +
  geom_line() +
  geom_point() +
  labs(x = "温度", y = "压力") +
  theme(
    axis.title = element_text(family = "Noto Serif CJK SC"),
    axis.text = element_text(family = "Noto Sans")
  )
```


既然这样，为什么我仍然选择介绍 **ggplot2** 呢？对新手来说比较友好，有一套紧凑、一致的语法，掌握规律后，学习曲线比较低，可以非常高效地绘制中等质量的图形。此外，衍生包 **gganimate** [@gganimate2020] 可以与 ggplot2 如丝般顺滑衔接，以成本极低的方式绘制动态图形，而且，**ggplot2** 的绘图语法已经出圈到交互式可视化领域，举例来说，R 包 **plotly** [@Carson2020] 和 **leaflet** [@leaflet2022] 等都提供一套相似度极高的管道语法，学习成本进一步摊薄了。总而言之，软件成熟，生态庞大，社区活跃。



### ggplot2 作图系统 {#sec-grammar-of-graphics}

**ggplot2** [@Hadley2016] 是一个 R 语言扩展包，专用于绘制各种各样的统计图形，是数据探索和可视化的利器。
2007 年 6 月 1 日 **ggplot2** 在 CRAN 上发布第一个正式版本 0.5，截止写作时间，**ggplot2** 已经持续迭代 10 多年了，发布了 40 多个版本，形成了一个非常庞大的生态，直接依赖 **ggplot2** 的 R 包接近 3000 个。从如下三个地方，可以窥见 **ggplot2** 生态的一角，感受其魅力。

- Daniel Emaasit 收集了 110 多个 **ggplot2** 衍生包，维护了一个 [网站](https://exts.ggplot2.tidyverse.org/gallery/)，统一组织、展示这些 R 包。本文会精心挑选一些高质量的 R 包予以介绍。

- Tom Mock 发起的 [tidytuesday](https://github.com/rfordatascience/tidytuesday/) 项目吸引了数以千计的数据科学爱好者参与数据分析、探索和可视化项目，涌现了一批批优秀的基于 **ggplot2** 的可视化作品，极大地提升了 **ggplot2** 生态的影响力。本文也会基于真实的数据介绍每一个统计图形。

- Yan Holtz 整理了数以百计的统计图形，分门别类地在[网站](https://r-graph-gallery.com/)上展示，方便读者预览效果、选择合适的图形。也是受该网站启发，本文在介绍完 **ggplot2** 绘图的基础要素后，从统计图形的作用出发，按照趋势、关系、占比、对比、分布和不确定性等六大方面予以介绍。



## 图形基础 {#sec-foundations-of-ggplot2}

2006 年 Hans Rosling（汉斯·罗琳）在 TED 做了一场精彩的演讲 --- The best stats you've ever seen。演讲中展示了一系列生动形象的动画，用数据记录的事实帮助大家理解世界的变化，可谓是动态图形领域的惊世之作。时至今日，已经超过 1500 万人观看，产生了十分广泛的影响。下面从数据源头 --- 世界银行获取数据，整理后取名 `gapminder`。本节将基于 `gapminder` 数据集介绍 **ggplot2** 绘图的基础知识，包括图层、标签、刻度、配色、图例、主题、文本、分面、字体、动画和组合等 11 个方面，理解这些有助于绘制和加工各种各样的统计图形，可以覆盖日常所需。gapminder 数据集以数据框的形式存储在 R 软件运行环境中，一共 4950 行，7 列。篇幅所限，下 @tbl-gapminder 展示该数据集的部分内容，表中人均 GDP 和预期寿命两列四舍五入保留一位小数。

```{r}
#| echo: false
#| label: tbl-gapminder
#| tbl-cap: "gapminder 数据集（部分）"

gapminder <- readRDS(file = "data/gapminder-2020.rds")
knitr::kable(head(gapminder), digits = 1,
  col.names = c(
    "年份", "国家或地区", "区域划分", "收入水平",
    "人均 GDP", "预期寿命", "人口总数"
  )
)
```

在 R 环境中，加载 gapminder 数据集后，可以用 `str()` 函数查看数据集 gapminder 各个列的数据类型和部分属性值。

```{r}
#| label: load-gapminder

# 查看数据
str(gapminder)
```

其中，country（国家或地区）是字符型变量，region （区域）是因子型变量，income_level（收入水平）是有序的因子型变量，year （年份）、 pop （人口总数）、lifeExp （出生时的预期寿命，单位：岁）和 gdpPercap （人均 GDP，单位：美元）是数值型变量。


### 图层 {#sec-layer}

ggplot2 绘图必须包含以下三个要素，缺少任何一个，图形都是不完整的。

1.  数据，前面已经重点介绍和准备了；
1.  映射，数据中的变量与几何元素的对应关系；
1.  图层，至少需要一个图层用来渲染观察值。

下面逐一说明三个要素的作用，为简单起见，从数据集 gapminder 中选取 2007 年的数据。

```{r}
#| label: fig-layer-point
#| fig-cap: "ggplot2 绘图三要素"
#| fig-subcap: 
#| - "只有数据"
#| - "只有数据和坐标映射"
#| - "数据、坐标映射和点图层"
#| - "数据、坐标映射、点图层和视觉映射（可选）"
#| layout-ncol: 2
#| layout-nrow: 2
#| fig-width: 4
#| fig-height: 3
#| fig-showtext: true

gapminder_2007 <- gapminder[gapminder$year == 2007, ]
ggplot(data = gapminder_2007)
ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp))
ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point()
ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(size = pop))
```

@fig-layer-point-1 仅提供数据，只渲染出来一个绘图区域。 @fig-layer-point-2 仅提供数据和映射，将变量 gdpPercap 映射给横轴，变量 lifeExp 映射给纵轴，继续渲染出来横、纵坐标轴及标签。 @fig-layer-point-3 提供了数据、映射和图层三要素，观察值根据几何图层 `geom_point()` 将几何元素 「点」渲染在绘图区域上，形成散点图。函数 `ggplot()` 和函数 `geom_point()` 之间是以加号 `+` 连接的。无论最终产出的图形如何复杂，这个模式贯穿 ggplot2 绘图。


10 多年来，**ggplot2** 包陆续添加了很多几何图层，目前支持的有 53 个，如下：

```{r}
#| eval: true
#| echo: false
#| label: layout-geom

ls("package:ggplot2", pattern = "^geom_*")
```

也正因这些丰富多彩的图层，ggplot2 可以非常便捷地做各种数据探索和展示工作。从时间序列数据、网络社交数据到文本数据、空间数据，乃至时空数据都有它大显身手的地方。



### 标签 {#sec-label}

用函数 `labs()` 可以添加横轴、纵轴、图例的标题，整个图片的标题和副标题等。下图 @fig-label-1 是默认设置下显示的标签内容，而 @fig-label-2 是用户指定标签内容后的显示效果。

```{r}
#| label: fig-label
#| fig-width: 7
#| fig-height: 3.5
#| fig-cap: "添加标签"
#| fig-subcap: 
#| - "默认设置"
#| - "自定义标签"
#| layout-ncol: 1
#| fig-showtext: true

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region))
ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region)) +
  labs(x = "人均 GDP", y = "预期寿命", tag = "标签",
       title = "这里是标题", caption = "这是图形说明", 
       subtitle = "这里是副标题", color = "图例标题")
```


### 刻度 {#sec-scale}

<!-- 
几何元素的透明度 alpha、颜色 color、填充色 fill、线类型 linetype、几何元素的形状 shape 及大小 size，坐标轴 x/y 的变换 
-->

有时候 @fig-layer-point-3 看起来不太好，收入低的国家太多，聚集在一起，重叠覆盖比较严重。而高收入国家相对较少，分布稀疏，距离低收入比较远，数据整体的分布很不平衡。此时，可以考虑对横轴标度做一些变换，常用的有以 10 为底的对数变换，如 @fig-scale-log10 。


```{r}
#| label: fig-scale-log10
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 3
#| fig-cap: "人均 GDP 做对数变换"

library(scales)
ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +
  scale_x_log10() +
  labs(x = "人均 GDP", y = "预期寿命")
```

为了更加醒目地展示横轴做了对数变换，需要添加对应的刻度标签。**scales** 包 [@scales2022] 提供很多刻度标签支持，比如函数 `label_log()` 默认提供以 10 为底的刻度标签，如 @fig-scale-labels 。

```{r}
#| label: fig-scale-labels
#| fig-showtext: true
#| fig-cap: "刻度标签随数据变换调整"
#| fig-width: 5
#| fig-height: 3

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +
  scale_x_log10(labels = label_log()) +
  labs(x = "人均 GDP", y = "预期寿命")
```

这其实还不够，有的刻度标签含义不够显然，且看 @fig-scale-labels 的横轴第一个刻度标签 $10^{2.48}$ 是用来替换 @fig-scale-log10 的横轴第一个刻度标签 300。10 的 2.48 次方可不容易看出是 300 的意思，实际上它等于 302。因此，结合人均 GDP 的实际范围，有必要适当调整横轴显示范围，这可以在函数 `scale_x_log10()` 中设置参数 `limits`，横轴刻度标签会随之适当调整，调整后的效果如 @fig-scale-limits 。


```{r}
#| label: fig-scale-limits
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 3
#| fig-cap: "设置数据展示范围"

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +
  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +
  labs(x = "人均 GDP", y = "预期寿命")
```

根据横轴所代表的人均 GDP （单位：美元）的实际含义，其实，可以进一步，添加更多的信息，即刻度标签带上数量单位，此处是美元符号。**scales** 包提供的函数 `label_dollar()` 可以实现，效果如 @fig-scale-dollar 。

```{r}
#| label: fig-scale-dollar
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 3
#| fig-cap: "设置数据展示范围"

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +
  scale_x_log10(labels = label_dollar(), limits = c(100, 110000)) +
  labs(x = "人均 GDP", y = "预期寿命")
```


最后，有必要添加次刻度线作为辅助参考线。图中点与点之间的横向距离代表人均 GDP 差距，以 10 为底的对数变换不是线性变化的，肉眼识别起来有点困难。从 100 美元到 100000 美元，在 100 美元、1000 美元、10000 美元和 100000 美元之间均添加 10 条次刻度线，每个区间内相邻的两条次刻度线之差保持恒定。下面构造刻度线的位置，了解原值和对数变换后的对应关系。

```{r}
# 刻度线位置
mb <- unique(as.numeric(1:10 %o% 10^(1:4)))
# 对数变换后
log10(mb)
# 刻度线位置
format(mb, big.mark = ",", scientific = 999)
```

函数 `scale_x_log10()` 提供参数 `minor_breaks` 设定刻度线的位置。最终效果如 @fig-scale-minor-breaks 。

```{r}
#| label: fig-scale-minor-breaks
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 3
#| fig-cap: "添加次刻度线，提供更多参考"

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point() +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  labs(x = "人均 GDP", y = "预期寿命")
```



### 配色 {#sec-color}

好的配色可以让图形产生眼前一亮的效果，R 语言社区在统计图形领域深耕 20 多年，陆续涌现很多专门调色的 R 包，常见的有：

- **RColorBrewer** [@RColorBrewer2022] (<https://github.com/axismaps/colorbrewer/>)
- **munsell** [@munsell2018] (<https://github.com/cwickham/munsell/>)
- **colorspace** [@Zeileis2020] (<https://colorspace.r-forge.r-project.org/>)
- **paletteer** [@paletteer2021] (<https://github.com/EmilHvitfeldt/paletteer>)
- **scico** [@scico2022] (<https://github.com/thomasp85/scico>)
- **viridis** [@viridis2021] (<https://github.com/sjmgarnier/viridis/>)
- **viridisLite** [@viridis2021] (<https://github.com/sjmgarnier/viridisLite/>)
- **colormap** [@colormap2016] (<https://github.com/bhaskarvk/colormap>)

**ggplot2** 提供多种方式给图形配色，最常见的要数函数 `scale_color_brewer()`，它调用 RColorBrewer 包制作离散型的调色板，根据离散型变量的具体情况，可分为发散型 qualitative、对撞型 Diverging、有序型 Sequential。在图 @fig-scale-minor-breaks 的基础上，将分类型的区域变量映射给散点的颜色，即得到 @fig-color-brewer 。

```{r}
#| label: fig-color-brewer
#| fig-cap: "使用 RColorBrewer 包提供的 Set1 调色板"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 3.5

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region)) +
  scale_color_brewer(palette = "Set1") +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  labs(x = "人均 GDP", y = "预期寿命", color = "区域")
```

另一种方式是调用函数 `scale_color_manual()`，需要用户给分类变量值逐个指定颜色，即提供一个命名的向量，效果如 @fig-color-manual 。

```{r}
#| label: fig-color-manual
#| fig-cap: "手动挨个指定分类变量的颜色"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 3.5

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region)) +
  scale_color_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  labs(x = "人均 GDP", y = "预期寿命", color = "区域")
```


### 图例 {#sec-legend}

在 @fig-color-brewer 的基础上，继续将每个国家的人口总数映射给点的大小，绘制气泡图。此时有两个视觉映射变量 --- 离散型的变量 country （国家）和连续型的变量 pop （人口总数）。不仅仅是图层函数 `geom_point()`，所有的几何图层都提供参数 `show.legend` 来控制图例的显示或隐藏。传递命名逻辑向量还可以在多个图例中选择性保留。 @fig-legend-show 在两个图例中保留一个，即人口总数。

```{r}
#| label: fig-legend-show
#| fig-cap: "在两个图例中保留一个"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 3.5

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region, size = pop),
    show.legend = c(color = FALSE, size = TRUE)
  ) +
  scale_color_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  labs(x = "人均 GDP", y = "预期寿命", size = "人口总数")
```

全世界各个国家的人口总数从百万级横跨到十亿级，根据此实际情况，适当调整图例刻度标签是很有必要的，可以让图例内容更具可读性。 @fig-legend-label 是修改图例刻度标签后的效果，其中 M 表示 Million（百万），B 表示 Billion （十 亿）。

```{r}
#| label: fig-legend-label
#| fig-cap: "修改图例刻度标签"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 3.5

ggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region, size = pop),
    show.legend = c(color = FALSE, size = TRUE)
  ) +
  scale_color_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12), labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  labs(x = "人均 GDP", y = "预期寿命", size = "人口总数")
```


### 主题 {#sec-theme}

主题就是一系列风格样式的集合，提前设定标题、文本、坐标轴、图例等元素的默认参数，供后续调用。10 年来，R 语言社区陆续出现很多主题包。

- **ggthemes** [@ggthemes2021] 收集了网站（如 Fivethirtyeight）、杂志（如《经济学家》）、软件（如 Stata）等的配色主题，打包成可供 **ggplot2** 绘图的主题，更多内容见 (<https://github.com/jrnold/ggthemes>)
- **ggsci** [@ggsci2018] 包收集了多份期刊杂志的图形配色，将其融入 **ggplot2** 绘图主题中，更多内容见 (<https://github.com/road2stat/ggsci>)。
- **ggpubr** [@ggpubr2020] 包在 **ggplot2** 之上封装一套更加易用的函数，可以快速绘制出版级的统计图形 (<https://github.com/kassambara/ggpubr>)。
- **ggcharts** [@ggcharts2020] 包类似 **ggpubr** 包，也提供一套更加快捷的函数接口，缩短数据可视化的想法与实际图形的距离，更多内容见 (<https://github.com/thomas-neitmann/ggcharts>)。
- **ggthemr** [@ggthemr2020] 是比较早的 **ggplot2** 主题包，上游依赖少，更多内容见 (<https://github.com/Mikata-Project/ggthemr>)。
- **ggtech** [@ggtech2018] 包收集了许多科技公司的设计风格，将其制作成可供 ggplot2 绘图使用的主题，更多内容见 (<https://github.com/ricardo-bion/ggtech>)。
- **bbplot** [@bbplot2022] 为 BBC 新闻定制的一套主题，更多内容见 (<https://github.com/bbc/bbplot>)。
- **pilot** [@pilot2022] 包提供一套简洁的 **ggplot2** 主题，特别是适合展示分类、离散型数据，更多内容见 (<https://github.com/olihawkins/pilot>)。
- **ggthemeassist** [@ggThemeAssist2016] 包提供 RStudio IDE 插件，帮助用户以鼠标点击的交互方式设置 **ggplot2** 图形的主题样式，更多内容见 (<https://github.com/calligross/ggthemeassist>)。


在 @fig-legend-label 的基础上，以 **ggplot2** 包内置的主题 `theme_classic()` 替换默认的主题，效果如下 @fig-theme-classic ，这是一套非常经典的主题，它去掉所有的背景色和参考系，显得非常简洁。


```{r}
#| label: fig-theme-classic
#| fig-cap: "ggplot2 内置的经典主题风格"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
    data = function(x) subset(x, year == 2007),
    aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  theme_classic() +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```


在已有主题的基础上，还可以进一步细微调整，比如，将图例移动至绘图区域的下方，见 @fig-theme-position 。

```{r}
#| label: fig-theme-position
#| fig-cap: "图例置于图形下方"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
    data = function(x) subset(x, year == 2007),
    aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  theme_classic() +
  theme(legend.position = "bottom") +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```



或者用户觉得合适的任意位置。

```{r}
#| label: fig-theme-custom
#| fig-cap: "微调图例位置"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
    data = function(x) subset(x, year == 2007),
    aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  theme_classic() +
  theme(legend.position =  c(0.875, 0.3)) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```


或者更换其它主题，比如 **ggplot2** 包内置极简主题 `theme_minimal()`，它还可以保留主、次刻度线，更加适合当下的数据。

```{r}
#| label: fig-theme-minimal
#| fig-cap: "ggplot2 内置的极简主题风格"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
    data = function(x) subset(x, year == 2007),
    aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  theme_minimal() +
  theme(legend.position =  c(0.875, 0.3)) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```




### 注释 {#sec-annotation}

注释可以是普通文本，数学公式，还可以是图形照片、表情包。注释功能非常强大，但也是非常灵活，往往使用起来颇费功夫，需要结合数据情况，从图形所要传递的信息出发，适当添加。R 语言社区陆续出现一些扩展包，让用户使用起来更方便些。

- **ggrepel** [@ggrepel2021] 包可以通过添加一定距离的扰动，可以缓解文本重叠的问题，更多内容见 (<https://github.com/slowkow/ggrepel>)。
- **ggtext** [@ggtext2020] 包支持以 Markdown 语法添加丰富的文本内容，更多内容见 (<https://github.com/wilkelab/ggtext>)。
- **geomtextpath** [@geomtextpath2022] 包新添几何图层 --- 文本路径。注释文本随路径变化，更多内容见 (<https://github.com/AllanCameron/geomtextpath>) 。
- **string2path** [@string2path2022] 包字体轮廓生成路径，注释文本随路径变化，更多内容见 (<https://github.com/yutannihilation/string2path>)。
- **ggimage** [@ggimage2022] 包提供图像图层，实现以图片代替散点的效果，图片还可以是表情包，更多内容见 (<https://github.com/GuangchuangYu/ggimage>)。

在 @fig-theme-minimal 的基础上，给人口总数大于 2 亿的国家添加文本注释。这可以用 **ggplot2** 包提供的文本图层函数 `geom_text()` 实现，效果如 @fig-text 。

```{r}
#| label: fig-text
#| fig-cap: "添加文本注释"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

library(ggrepel)
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(
    data = function(x) subset(x, year == 2007),
    aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  geom_text(
    data = function(x) subset(x, year == 2007 & pop >= 20 * 10^7),
    aes(label = country), show.legend = FALSE
  ) +
  scale_size(range = c(2, 12)) +
  theme_minimal() +
  theme(legend.position = c(0.9, 0.35)) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```

当需要给许多点添加文本注释时，就难以避免地遇到注释文本重叠的问题。比如给人口总数大于 5000 万的国家添加文本注释，此时，适合使用 **ggrepel** 包，调用函数 `geom_text_repel()` --- 这是一个新的文本图层，通过添加适当的位移缓解文本重叠问题。

```{r}
#| label: fig-text-ggrepel
#| fig-cap: "缓解文本注释相互覆盖的问题"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 4.5

library(ggrepel)
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2007),
             aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_x_log10(
    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)
  ) +
  geom_text_repel(
    data = function(x) subset(x, year == 2007 & pop >= 5 * 10^7),
    aes(label = country), size = 3, max.overlaps = 50,
    segment.colour = "gray", seed = 2022, show.legend = FALSE
  ) +
  scale_size(range = c(2, 12)) +
  theme_minimal() +
  theme(legend.position = c(0.9, 0.35)) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```




### 分面 {#sec-facet}

**ggplot2** 包有两个函数 `facet_wrap()` 和 `facet_grid()` 都可以用来实现分面操作，分面的目的是将数据切分，一块一块地展示。下面在 @fig-theme-minimal 的基础上，按收入水平变量分面，即将各个国家或地区按收入水平分开，效果如 @fig-facet-wrap 所示。`facet_grid()` 与 `facet_wrap()` 的效果是类似的，就不再赘述了。

```{r}
#| label: fig-facet-wrap
#| fig-cap: "按收入水平变量分面"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2007),
             aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +
  facet_wrap(facets = ~income_level, ncol = 2) +
  theme_classic() +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```

在函数 `facet_wrap()` 内设置不同的参数值，会有不同的排列效果。设置 `ncol = 3`，意味着排成 3 列，而分类变量 continent 总共有 5 种不同的类别，因此将会是 3 列 2 行的布局，效果如下 @fig-facet-ncol 。

```{r}
#| label: fig-facet-ncol
#| fig-cap: "按区域变量分面"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 6

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2007),
             aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +
  facet_wrap(facets = ~income_level, ncol = 3) +
  theme_classic() +
  theme(legend.position = c(0.9, 0.2)) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```


## 图形中阶 {#sec-intermediate-of-ggplot2}


### 坐标系统 {#sec-coord}



### 中英字体 {#sec-font}

**showtext** [@Qiu2015] 是一个专用于处理中英文字体的 R 包，支持 Base R 和 **ggplot2** 绘图，支持调用系统已安装的字体，也支持调用给定路径下的字体，还支持各种奇形怪状的表情字体，更多内容见 (<https://github.com/yixuan/showtext>)，好玩的字体配合好玩的图形，可以玩出很多花样。

```{r}
#| eval: false
#| echo: true

## 简体中文宋体字
sysfonts::font_add(
  family = "Noto Serif CJK SC",
  regular = "NotoSerifCJKsc-Regular.otf",
  bold = "NotoSerifCJKsc-Bold.otf"
)
## 无衬线英文字体
sysfonts::font_add(
  family = "Noto Sans",
  regular = "NotoSans-Regular.ttf",
  bold = "NotoSans-Bold.ttf",
  italic = "NotoSans-Italic.ttf",
  bolditalic = "NotoSans-BoldItalic.ttf"
)
```

接下来查看在当前运行环境下，可供 **showtext** 包使用的字体。如果配置成功，输出的字体列表中会包含 `Noto Serif CJK SC` 和 `Noto Sans` 两款字体。

```{r}
#| label: font-families

sysfonts::font_families()
```

确认字体配置好了以后，全局默认字体为 Noto 无衬线英文字体，将所有标题处的字体设置为 Noto 系列的简体中文字体。通过与前面的 @fig-facet-ncol 比较，下 @fig-font 中的字体样式是明显不一样的。

```{r}
#| label: fig-font
#| fig-cap: "Noto 系列中英文字体"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 6

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2007),
             aes(fill = region, size = pop),
    show.legend = c(fill = TRUE, size = FALSE),
    shape = 21, col = "white"
  ) +
  scale_fill_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12)) +
  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +
  facet_wrap(facets = ~income_level, ncol = 3) +
  theme_classic(base_family = "Noto Sans") +
  theme(
    title = element_text(family = "Noto Serif CJK SC"),
    text = element_text(family = "Noto Serif CJK SC"),
    legend.position =  c(0.9, 0.20)
  ) +
  labs(x = "人均 GDP", y = "预期寿命", fill = "区域")
```

**ragg** 包 (<https://github.com/r-lib/ragg>) 无需手动配置字体，只要是系统已经安装的字体，在 ggplot2 绘图时，将字体名称传递给 `family` 即可。


### 制作动画 {#sec-animation}


从 1991 年至2020 年，gapminder 数据集一共是 30 年的数据。 @sec-font 根据 2007 年的数据绘制了 @fig-font ，每年的数据绘制一幅图像，30 年总共可获得 30 帧图像，再以每秒播放 5 帧图像的速度将 30 帧图像合成 GIF 动画。因此，设置这个动画总共 30 帧，每秒播放的图像数为 5。

```{r}
options(gganimate.nframes = 30, gganimate.fps = 5)
```

**gganimate** 包提供一套代码风格类似 **ggplot2** 包的动态图形语法，可以非常顺滑地与之连接。在了解了 ggplot2 绘制图形的过程后，用 **gganimate** 包制作动画是非常容易的。**gganimate** 包会调用 **gifski** (<https://github.com/r-rust/gifski>) 包来合成动画，因此，除了安装 **gganimate** 包，还需要安装 **gifski** 包。接着，在已有的 **ggplot2** 绘图代码基础上，再追加一个转场图层函数 `transition_time()`，这里是按年逐帧展示图像，因此，其转场的时间变量为 gapminder 数据集中的变量 `year`。

```{r}
#| label: fig-animate-facets
#| fig-cap: "生成 GIF 动画"
#| fig-width: 7
#| fig-height: 6
#| fig-showtext: true
#| fig-show: "animate"
#| cache: true

library(gganimate)
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region, size = pop),
    show.legend = c(color = TRUE, size = TRUE)
  ) +
  scale_color_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_size(range = c(2, 12), labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +
  facet_wrap(facets = ~income_level) +
  theme_classic(base_family = "Noto Sans") +
  theme(
    title = element_text(family = "Noto Serif CJK SC"),
    text = element_text(family = "Noto Serif CJK SC")
  ) +
  labs(
    title = "{frame_time} 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "区域"
  ) +
  transition_time(time = year)
```


```{r}
#| label: fig-animate-region
#| fig-cap: "生成 GIF 动画"
#| fig-width: 7
#| fig-height: 7
#| fig-showtext: true
#| fig-show: "animate"
#| cache: true

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = income_level, size = pop),
    show.legend = c(color = TRUE, size = TRUE)
  ) +
  scale_color_brewer(palette = "RdYlGn") +
  scale_radius(range = c(1, 6), trans = "log10",
             labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +
  facet_wrap(facets = ~region, ncol = 3) +
  theme_classic(base_family = "Noto Sans") +
  theme(
    title = element_text(family = "Noto Serif CJK SC"),
    text = element_text(family = "Noto Serif CJK SC")
  ) +
  labs(
    title = "{frame_time} 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "收入水平"
  ) +
  transition_time(time = year)
```


去掉分面

```{r}
#| label: fig-animate-scale
#| fig-cap: "生成 GIF 动画"
#| fig-width: 7
#| fig-height: 5
#| fig-showtext: true
#| fig-show: "animate"
#| cache: true

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = region, size = pop),
             show.legend = c(color = TRUE, size = TRUE)
  ) +
  scale_color_manual(values = c(
    `拉丁美洲与加勒比海地区` = "#E41A1C", `撒哈拉以南非洲地区` = "#377EB8",
    `欧洲与中亚地区` = "#4DAF4A", `中东与北非地区` = "#984EA3",
    `东亚与太平洋地区` = "#FF7F00", `南亚` = "#FFFF33", `北美` = "#A65628"
  )) +
  scale_radius(range = c(1, 6), trans = "log10",
             labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_dollar(), minor_breaks = mb, limits = c(10, 130000)) +
  scale_y_continuous(n.breaks = 6) +
  theme_classic(base_family = "Noto Sans") +
  theme(
    title = element_text(family = "Noto Serif CJK SC"),
    text = element_text(family = "Noto Serif CJK SC"),
    panel.grid.major = element_line(),
    panel.grid.minor.x = element_line()
  ) +
  labs(
    title = "{frame_time} 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "区域"
  ) +
  transition_time(time = year)
```




### 组合图形 {#sec-patchwork}

**patchwork** (<https://github.com/thomasp85/patchwork>) 包提供了一套非常简洁的语法，用来组合多个 ggplot2 图形。如 @fig-patchwork 所示，用散点图分别绘制 2002 年和 2007 年的数据，并将图形肩并肩的并排展示。


```{r}
#| label: fig-patchwork
#| fig-cap: "左右组合"
#| fig-width: 8
#| fig-height: 4
#| fig-showtext: true

p1 <- ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2020),
             aes(color = income_level, size = pop)) +
  scale_color_brewer(palette = "RdYlGn") +
  scale_radius(range = c(1, 6), trans = "log10",
               labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +
  theme_minimal() +
  labs(
    title = "2020 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "收入水平"
  )

p2 <- ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2010),
             aes(color = income_level, size = pop)) +
  scale_color_brewer(palette = "RdYlGn") +
  scale_radius(range = c(1, 6), trans = "log10",
               labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +
  theme_minimal() +
  labs(
    title = "2010 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "收入水平"
  )

library(patchwork)
p1 | p2
```

除了用竖线 `|` 左右并排，还可以用斜杠 `/` 做上下排列，见下 @fig-patchwork-updown 。

```{r}
#| label: fig-patchwork-updown
#| fig-cap: "上下组合"
#| fig-width: 6
#| fig-height: 8
#| fig-showtext: true

p1 / p2
```

还可以引入括号 `()`，实现更加复杂的图形组合，见下 @fig-patchwork-grid 。

```{r}
#| label: fig-patchwork-grid
#| fig-cap: "多图组合"
#| fig-width: 8
#| fig-height: 8
#| fig-showtext: true

p3 <- ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(data = function(x) subset(x, year == 2000),
             aes(color = income_level, size = pop)) +
  scale_color_brewer(palette = "RdYlGn") +
  scale_radius(range = c(1, 6), trans = "log10",
               labels = label_number(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +
  theme_minimal() +
  labs(
    title = "2000 年", x = "人均 GDP",
    y = "预期寿命", size = "人口总数", color = "收入水平"
  )

p1 / (p2 | p3)
```

结合上面的介绍，不难看出，竖线 `|` 用于左右分割，斜杠 `/` 用于上下分割，而括号 `()` 用于范围的限定，下 @fig-patchwork-layout 是去掉括号后的效果。

```{r}
#| label: fig-patchwork-layout
#| fig-cap: "多图组合"
#| fig-width: 8
#| fig-height: 8
#| fig-showtext: true

p1 / p2 | p3
```


还可以将图例收集起来，合并放置在一处。p1 、p2 和 p3 的图例是一样的，可以将 p2 和 p3 的图例隐藏起来，将 p1 的图例放置在右侧居中的位置。


```{r}
#| label: fig-patchwork-collect
#| fig-cap: "多图组合"
#| fig-width: 8
#| fig-height: 6
#| fig-showtext: true

p4 <- p2 +
  theme(legend.position = "none")
p5 <- p3 +
  theme(legend.position = "none")
p1 / (p4 | p5) +
  plot_layout(guides = "collect")
```


看起来，有点像分面绘图，但是一个图占两列又表示它不是分面绘图，而是多图布局的效果。


最常用的功能就是这些啦，更多内容可以去 **patchwork** 包官网了解。其它可以用来组合多个 ggplot2 图形的 R 包有 **cowplot** (<https://github.com/wilkelab/cowplot>)、**gridExra** (<https://cran.r-project.org/package=gridExtra>) 和 **gghalves** (<https://github.com/erocoar/gghalves>) 等。


### 插入公式 {#sec-math}

ggplot2 内置的数学公式解析和表达能力

[latex2exp](https://github.com/stefano-meschiari/latex2exp) 


### 导出图形 {#sec-export-image}

保存图形 ggsave 

### 图文混合 {#sec-image-text} 

大篇注释


### 添加水印 {#sec-watermark}








## 描述趋势 {#sec-visualize-data-trend}


<!--
写作模式：

1. 提出问题：引发兴趣，探案，讲故事。
2. 数据探索：数据预处理、分组计算等操作
3. 绘图说明：给出最终展示图，说明关键函数，技巧实现
4. 一般总结：图形的一般作用，目的是方便读者将其应用于其它场景，举一反三。
5. 本节小结：5-6 个不同图形探索的对比总结
-->


R 是一个自由的统计计算和统计绘图环境，最初由新西兰奥克兰大学统计系的 Ross Ihaka 和 Robert Gentleman 共同开发。1997 年之后，成立了一个 R Core Team（R 语言核心团队），他们在版本控制系统 Apache Subversion（<https://subversion.apache.org/>）上一起协作开发至今。25 年，四分之一个世纪过去了，下面分析他们留下的一份开发日志，了解一段不轻易为人所知的故事。

首先，下载 1997 年至今，约 25 年的原始代码提交日志数据。下载数据的代码如下，它是一行 Shell 命令，可在 MacOS 或 Ubuntu 等 Linux 系统的终端里运行，借助 Apache Subversion 软件，将提交日志导出为 XML 格式（<https://www.w3.org/standards/xml/core>）的数据文件，保存在目录 `data-raw/` 下，文件名为 `svn_trunk_log_20220727.xml`，本书网页版随附。

```{bash}
#| eval: false

svn log --xml --verbose -r 6:82626 https://svn.r-project.org/R/trunk > data-raw/svn_trunk_log_20220727.xml
```

去掉没什么信息的前5次代码提交记录：初始化仓库，上传原始的 R 软件源码等。
从 Ross Ihaka 在 1997-09-18 提交第 1 次代码改动开始，下载所有的提交日志。截至写作时间，即 2022年7月27日，代码最新版本号为 82626，意味着代码仓库已存在 8 万多次提交。

下载数据后，借助 **xml2**（<https://github.com/r-lib/xml2/>）包预处理这份 XML 格式数据，提取最重要的信息，谁在什么时间做了什么改动。经过一番操作后，将清洗干净的数据，
保存到目录 `data/` 下，以 R 软件特有的文件格式保存为 `svn_trunk_log_20220727.rds`，同样与书随附。这样下来，原 XML 格式保存的 35 M 文件减少为 1 M 多，极大地减少了存储空间，也极大地方便了后续的数据探索和可视化。下面是这份日志数据开头的两行：

```{r}
svn_trunk_log <- readRDS(file = "data/svn_trunk_log_20220727.rds")
head(svn_trunk_log, 2)
```

一共是四个字段，分别是代码提交时记录的版本号 revision，提交代码的人 author，提交代码的时间 stamp 和提交代码时伴随的说明 msg。接下来，带着问题一起探索开源统计软件 R 过去 25 年波澜壮阔的历史！



### 折线图 {#sec-line}

<!-- 
折线图层 geom_line
-->


- 过去 25 年代码提交次数的变化情况

折线图的意义是什么？在表达趋势变化，趋势的解读很重要。

不再介绍每个函数、每个参数和每行代码的作用，而是重点阐述折线图的作用，以及如何解读数据，阐述解读的思路和方向，建立起数据分析的思维。将重点放在这些方面，有助于书籍存在的长远意义，又结合了最真实的背景和原始数据，相信对实际工作的帮助会更大。而对于使用到统计方法的函数，则详加介绍，展示背后的实现细节，而不是调用函数做调包侠。


先来了解一下总体趋势，即过去 25 年里代码提交次数的变化情况。


数据集 `svn_trunk_log` 没有年份字段，但时间字段 stamp 隐含了年份信息，因此，新生成一个字段 year 将年份信息从 stamp 提取出来。


```{r}
svn_trunk_log <- within(svn_trunk_log, {
  # 提取日期、月份、年份、星期、第几周、第几天等时间成分
  year <- as.integer(format(stamp, "%Y"))
  date <- format(stamp, format = "%Y-%m-%d", tz = "UTC")
  month <- format(stamp, format = "%m", tz = "UTC")
  hour <- format(stamp, format = "%H", tz = "UTC")
  week <- format(stamp, format = "%U", tz = "UTC")
  wday <- format(stamp, format = "%a", tz = "UTC")
  nday <- format(stamp, format = "%j", tz = "UTC")
})
```

接着，调用分组聚合函数 `aggregate()` 统计各年的代码提交量。

```{r}
trunk_year <- aggregate(data = svn_trunk_log, revision ~ year, FUN = length)
```

然后，将数据集 trunk_year 以折线图展示，如 @fig-trunk-year-line 所示。

```{r}
#| label: fig-trunk-year-line
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_line() +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



为什么呈现这样的变化趋势？我最初想到的是先逐步增加，然后下降一会儿，再趋于平稳。

> 小时趋势

上午高峰

```{r}
#| label: fig-trunk-hour-line
#| fig-cap: "提交代码的时段分布"
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ year + hour, length) |> 
  ggplot(aes(x = hour, y = revision, group = year)) +
  geom_line() +
  theme_classic() +
  labs(x = "时段", y = "提交量")
```

```{r}
#| label: fig-trunk-hour-line-2013
#| fig-cap: "2013 年以来提交代码的时段分布"
#| fig-showtext: true

aggregate(data = svn_trunk_log, revision ~ year + hour, 
          length, subset = year >= 2013) |> 
  ggplot(aes(x = hour, y = revision, group = year)) +
  geom_line() +
  theme_classic() +
  labs(x = "时段", y = "提交量")
```

> 月趋势

12月和次年1月、7-8 月份提交量迎来小高峰，应该是教授们放寒暑假。是否有新人加入？

```{r}
#| label: fig-trunk-month-line
#| fig-cap: "提交代码的月份分布"
#| fig-showtext: true
#| fig-width: 7
#| fig-height: 5

aggregate(data = svn_trunk_log, revision ~ year + month, length) |>
  transform(date = as.Date(paste(year, month, "01", sep = "-"))) |>
  ggplot(aes(x = date, y = revision)) +
  geom_point(aes(color = factor(year)), show.legend = F, size = 0.75) +
  geom_line(aes(color = factor(year)), show.legend = F) +
  scale_x_date(date_minor_breaks = "1 year") +
  theme_classic() +
  theme(panel.grid.minor.x = element_line()) +
  labs(x = "时间（月粒度）", y = "提交量")
```



### 瀑布图 {#sec-waterfall}


<!-- 
矩形图层 geom_rect
-->

相比于折线图，瀑布图将变化趋势和增减量都展示了，如 @fig-waterfall 所示，每年的提交量就好像瀑布上的水，图中当期相对于上一期的增减量

```{r}
#| label: fig-waterfall
#| fig-cap: "25 年代码逐年提交量的变化趋势"
#| fig-showtext: true

trunk_year <- trunk_year[order(trunk_year$year), ]

trunk_year_tmp <- data.frame(
  xmin = trunk_year$year[-length(trunk_year$year)],
  ymin = trunk_year$revision[-length(trunk_year$revision)],
  xmax = trunk_year$year[-1],
  ymax = trunk_year$revision[-1],
  fill = trunk_year$revision[-1] - trunk_year$revision[-length(trunk_year$revision)] > 0
)

ggplot() +
  geom_rect(
    data = trunk_year_tmp,
    aes(
      xmin = xmin, ymin = ymin,
      xmax = xmax, ymax = ymax, fill = fill
    ), show.legend = FALSE
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


瀑布图是以数据点作为对角点构造矩形，用对撞型的颜色表示增减，下 @fig-waterfall-point 在 @fig-waterfall 基础上添加了数据点，用以直观说明矩形图层 `geom_rect()` 构造瀑布图的方法。**ggTimeSeries** 包 [@ggTimeSeries2022] (<https://github.com/thecomeonman/ggTimeSeries>) 提供统计图层 `stat_waterfall()` 实现类似的瀑布图。

```{r}
#| label: fig-waterfall-point
#| fig-cap: "矩形图层构造瀑布图"
#| fig-showtext: true

ggplot() +
  geom_rect(
    data = trunk_year_tmp,
    aes(
      xmin = xmin, ymin = ymin,
      xmax = xmax, ymax = ymax, fill = fill
    ), show.legend = FALSE
  ) +
  geom_point(
    data = trunk_year,
    aes(x = year, y = revision), size = 0.75
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


```{r}
#| echo: false
#| eval: false

# ggTimeSeries 包也可制作瀑布图
library(ggTimeSeries)
ggplot(data = trunk_year, aes(x = year, y = revision)) +
  stat_waterfall() +
  scale_fill_brewer(palette = "Set2") +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```



### 曲线图 {#sec-smooth}

<!-- 
平滑图层 geom_smooth
-->

将散点以线段逐个连接起来，形成折线图，刻画原始的变化，而曲线图的目标是刻画潜在趋势。有两种画法，其一从代数的角度出发，做插值平滑，在相邻两点之间以一条平滑的曲线连接起来；其二从统计的角度出发，做趋势拟合，通过线性或非线性回归，获得变化趋势，以图呈现，使得散点之中隐藏的趋势更加清晰。


**ggplot2** [@Hadley2016] 包提供函数 `geom_smooth()` 拟合散点图中隐含的趋势，通过查看函数 `geom_smooth()` 的帮助文档，可以了解其内部调用的统计方法。默认情况下，采用局部多项式回归拟合方法，内部调用了函数 `loess()` 来拟合趋势，如 @fig-trunk-year-smooth 所示。


```{r}
#| label: fig-trunk-year-smooth
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(data = subset(trunk_year, year != c(1997,2022))) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

类似大家熟悉的线性回归拟合函数 `lm()`，函数 `loess()` 也是基于类似的使用语法。下面继续以此数据为例，了解该函数的使用，继而了解 ggplot2 绘制平滑曲线图背后的统计方法。1997 年和 2022 年是不完整的，不参与模型参数的估计。

```{r}
trunk_year_loess <- loess(revision ~ year,
  data = subset(trunk_year, year != c(1997,2022)),
  span = 0.75, degree = 2, method = "loess",
  family = "symmetric",
  control = loess.control(surface = "direct", iterations = 4)
)
```

下面通过设定函数 `geom_smooth()` 的参数，可以达到一样的效果，见下 @fig-trunk-year-loess 

```{r}
#| label: fig-trunk-year-loess
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(method = "loess", formula = "y~x",
    method.args = list(
      span = 0.75, degree = 2, family = "symmetric",
      control = loess.control(surface = "direct", iterations = 4)
    ), data = subset(trunk_year, year != c(1997,2022))) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

除了 `method = "loess"`，函数 `geom_smooth()` 支持的统计方法还有很多，比如非线性回归拟合 `nls()`

```{r}
trunk_year_nls <- nls(revision ~ a * (year - 1996)^2 + b,
  data = subset(trunk_year, year != c(1997,2022)),
  start = list(a = -0.1, b = 1000)
)
```

采用一元二次非线性回归拟合方法，效果如 @fig-trunk-year-nls 所示。

```{r}
#| label: fig-trunk-year-nls
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    method = "nls", 
    formula = "y ~ a * (x - 1996)^2 + b",
    method.args = list(
      start = list(a = -0.1, b = 1000)
    ), se = FALSE, 
    data = subset(trunk_year, year != c(1997,2022)),
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

::: {.callout-caution}
在函数 `geom_smooth()` 内调用非线性回归拟合方法时，暂不支持提供置信区间。
:::

即便在不清楚统计原理的情况下，也不难看出 @fig-trunk-year-loess 和 @fig-trunk-year-nls 的差异，局部多项式回归捕捉到了更多的信息，特别是起步阶段的上升趋势，以及 2000-2005 年的高峰特点。


```{r}
summary(trunk_year_loess)
```


```{r}
summary(trunk_year_nls)
```

非线性回归模型带有 2 个参数，一共 26 个观察值，因此，自由度为 26 - 2 = 24。
RSE 残差平方和的标准差为

```{r}
# 非线性回归的残差平方和的标准差
sqrt(sum(residuals(trunk_year_nls)^2)/24)
```

```{r}
#| eval: false
#| echo: false

trunk_year_fit <- within(trunk_year, {
  nls_fitted = fitted(trunk_year_nls)
  loess_fitted = fitted(trunk_year_loess)
})
```

以平滑曲线连接相邻的散点，可以构造一个插值方法给函数 `geom_smooth()`，如下示例基于样条插值函数 `spline()`。样条源于德国宝马工程师，车辆外壳弧线，那些拥有非常漂亮的弧线，越光滑，与空气的摩擦阻力越小，车辆的气动外形更加符合流体力学的要求，加工打磨更加困难，往往价值不菲。美感是相通的，即使不懂车标，通过气动外形，也能识别出车辆的档次。

```{r}
#| label: fig-trunk-year-xxspline
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

xxspline <- function(formula, data, ...) {
  dat <- model.frame(formula, data)
  res <- splinefun(dat[[2]], dat[[1]])
  class(res) <- "xxspline"
  res
}

predict.xxspline <- function(object, newdata, ...) {
  object(newdata[[1]])
}

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    formula = "y~x",
    method = xxspline, se = FALSE,
    data = subset(trunk_year, year != c(1997,2022))
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

借助 spline 插值获得平滑曲线，ggalt 包的函数 `geom_xspline` 也提供类似的功能。


ggplot2 当前支持的平滑方法，还有很多


```{r}
#| label: fig-trunk-year-smooth-sets
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    formula = y ~ s(x, k = 12),
    method = "gam", se = FALSE,
    data = subset(trunk_year, year != c(1997, 2022))
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```


自由度为 3 的正交多项式拟合


```{r}
#| label: fig-trunk-year-poly
#| fig-cap: "过去 25 年代码提交次数的变化情况"
#| fig-showtext: true

ggplot(data = trunk_year, aes(x = year, y = revision)) +
  geom_point() +
  geom_smooth(
    method = "lm", 
    formula = "y ~ poly((x - 1996), 3)",
    se = FALSE, 
    data = subset(trunk_year, year != c(1997,2022)),
  ) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray90")) +
  labs(x = "年份", y = "提交量")
```

数学公式表达的统计模型与 R 语言表达的计算公式的对应关系见下 @tbl-formula ，更多详情见帮助文档 `?formula`。

| 数学公式 | R 语言计算公式|
|:---------------- |:---------------- |
| $y = \beta_0$ | `y ~ 1` |
| $y = \beta_0 + \beta_1 x_1$ | `y ~ 1 + x1` 或 `y ~ x1` 或 `y ~ x1 + x1^2` |
| $y = \beta_1 x_1$ | `y ~ 0 + x1` 或 `y ~ -1 + x1` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2$ | `y ~ x1 + x2` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_1 x_2$ | `y ~ x1 * x2` |
| $y = \beta_0 + \beta_1 x_1 x_2$ | `y ~ x1:x2` |
| $y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_1 x_2$ | `y ~ x1 + x2 + x1:x2` |
| $y = \beta_0 + \sum_{i=1}^{999}\beta_i x_i$ | `y ~ .` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^5$ | `y ~ x + I(x^5)` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^2$ | `y ~ x + I(x^2)` |
| $y = \beta_0 + \beta_1 x + \beta_2 x^2$ | `y ~ poly(x, degree = 2, raw = TRUE)` |

: 数学公式与 R 语言表示的计算公式 {#tbl-formula}

自由度为 1 的正交多项式 `poly(x, 1)` 回归模型，
函数 `glm()` 的参数 `offset` 的含义，`weights` 的含义
广义可加模型 gam 中回归样条的方法 `s()`




### 日历图 {#sec-calendar}

<!-- 
瓦片图层 geom_tile
-->

更加直观地展示出节假日、休息工作日、寒暑假，比如描述学生学习规律、需求的季节性变化、周期性变化。

```{r}
# 星期、月份缩写
week.abb <- c(
  "Sun", "Mon", "Tue", "Wed",
  "Thu", "Fri", "Sat"
)
month.abb <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
# 按年、星期、第几周聚合统计提交量数据
svn_trunk_year <- aggregate(
  revision ~ year + wday + week,
  FUN = length,
  data = svn_trunk_log, 
  subset = year %in% 2018:2022
)
# 第几周转为整型数据
# 周几转为因子型数据
svn_trunk_year <- within(svn_trunk_year, {
   week = as.integer(week)
   wday = factor(wday, labels = week.abb)
})
```

```{r}
#| label: fig-calendar
#| fig-cap: "最近 5 年休息和工作日打码活跃度"
#| fig-width: 8
#| fig-height: 7
#| fig-showtext: true

ggplot(data = svn_trunk_year, aes(
  x = week, y = wday,
  fill = cut(revision, breaks = 5 * 0:5)
)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_brewer(palette = "Greens") +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(1, 52, length = 12),
    labels = month.abb
  ) +
  facet_wrap(~year, ncol = 1) +
  theme_minimal() +
  labs(x = "月份", y = "星期", fill = "提交量")
```

经过了解 svn_trunk_year 2018 - 2022 年每天提交量的范围是 0 次到 21 次，0 次表示当天没有提交代码，SVN 上也不会有日志记录。因此，将提交量划分为 5 档



### 棋盘图 {#sec-chess}

<!-- 
标签图层 geom_label
-->

棋盘图一般可以放所有时间节点的聚合信息，格点处为落的子


```{r}
#| echo: false
#| label: rversion-raw-data

rversion <- readRDS(file = "data/rversion-2022.rds")
```

该数据集的存储结构很简单，是一个两列的数据框，它的一些属性如下：

```{r}
str(rversion)
```

做一点数据处理，将 date 字段转为日期类型，并从日期中提取年、月信息。

```{r}
rversion$date <- as.Date(rversion$date, format = "%Y-%m-%d", tz = "UTC")
rversion$year <- format(rversion$date, "%Y")
rversion$month <- format(rversion$date, "%m")
```


统计过去 25 年里每月的发版次数，如图 @fig-rversion-chess

```{r}
#| label: fig-rversion-chess
#| fig-cap: "25 年 R 软件发版情况"
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 8

aggregate(data = rversion, version ~ year + month, length) |>
  ggplot(aes(x = month, y = year)) +
  geom_label(aes(label = version, fill = version),
    show.legend = F, color = "white"
  ) +
  scale_fill_viridis_c(option = "D", begin = 0.2, end = 0.8) +
  theme_classic() +
  theme(panel.grid.major.y = element_line(colour = "gray95")) +
  labs(x = "月份", y = "年份")
```


### 时间线图 {#sec-timeline}

<!-- 
线段图层 geom_segment
-->

时间线图非常适合回顾过去，展望未来，讲故事

时间线图展示信息的层次和密度一般由时间跨度决定。时间跨度大时，展示重点节点信息，时间跨度小时，重点和次重点信息都可以放。从更加宏观的视角，厘清发展脉络，比如近两年的 R 软件发版情况。


本节用到一个数据集 rversion，记录了历次 R 软件发版时间及版本号，见 @tbl-rversion

```{r}
#| echo: false
#| label: tbl-rversion
#| tbl-cap: "R 软件发版数据集（部分）"

knitr::kable(head(rversion), col.names = c("版本号", "发版日期", "发版年份", "发版月份"))
```



```{r}
rversion_tl <- within(rversion, {
  # 版本号为 x.0.0 为重大版本 big
  # 版本号为 x.1.0 x.12.0 x.20.0 为主要版本 major
  # 版本号为 x.0.1 为次要版本 minor
  status <- ifelse(grepl(pattern = "*\\.0\\.0", x = version), "big", version)
  status <- ifelse(grepl(pattern = "*\\.[1-9]{1,2}\\.0$", x = status), "major", status)
  status <- ifelse(!status %in% c("big", "major"), "minor", status)
})
positions <- c(0.5, -0.5, 1.0, -1.0, 1.5, -1.5)
directions <- c(1, -1)
# 位置
rversion_pos <- data.frame(
  # 只要不是同一天发布的版本，方向相对
  date = unique(rversion_tl$date),
  position = rep_len(positions, length.out = length(unique(rversion_tl$date))),
  direction = rep_len(directions, length.out = length(unique(rversion_tl$date)))
)
# 原始数据上添加方向和位置信息
rversion_df <- merge(x = rversion_tl, y = rversion_pos, by = "date", all = TRUE)
# 最重要的状态放在最后绘制到图上
rversion_df <- rversion_df[with(rversion_df, order(date, status)), ]
```

选取一小段时间内的发版情况，比如最近的三年 --- 2020 - 2022 年 


```{r}
# 选取 2020 - 2022 年的数据
sub_rversion_df<- rversion_df[rversion_df$year %in% 2020:2022, ]
# 月份注释
month_dat <- data.frame(
  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = "3 month")
)
month_dat <- within(month_dat, {
  month = format(date, "%b")
})
# 年份注释
year_dat <- data.frame(
  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = "1 year")
)
year_dat <- within(year_dat, {
  year = format(date, "%Y")
})
```


@fig-rversion-timeline 展示 2020-2022 年 R 软件发版情况


```{r}
#| label: fig-rversion-timeline
#| fig-cap: "2020-2022 年 R 软件发版情况"
#| fig-width: 8
#| fig-height: 4
#| fig-showtext: true

ggplot(data = sub_rversion_df) +
  geom_segment(aes(x = date, y = 0, xend = date, yend = position)) +
  geom_hline(yintercept = 0, color = "black", linewidth = 1) +
  geom_label(
    aes(x = date, y = position, label = version, color = status),
    show.legend = FALSE
  ) +
  geom_point(aes(x = date, y = 0, color = status),
    size = 3, show.legend = FALSE
  ) +
  geom_text(
    data = month_dat,
    aes(x = date, y = 0, label = month), vjust = 1.5
  ) +
  geom_text(
    data = year_dat,
    aes(x = date, y = 0, label = year), vjust = -0.5
  ) +
  theme_void()
```

图中红色标注的是里程碑式的重大版本，绿色标注的是主要版本，蓝色标注的次要版本，小修小补，小版本更新。


当时间跨度非常大时，比如过去 25 年，那就只能放重大版本和主要版本信息了，时间上月份信息就不能用名称简写，而用数字更加合适。而且还得竖着放，同时添加那个版本最有影响力的改动。相比于，棋盘图，这是时间线图的优势。


```{r}
#| label: fig-rversion-major
#| fig-cap: "25 年里 R 软件重大及主要版本发布情况"
#| fig-width: 6
#| fig-height: 9
#| fig-showtext: true

sub_rversion_df2 <- rversion_df[rversion_df$status %in% c("big", "major"), ]
ggplot(data = sub_rversion_df2) +
  geom_segment(aes(x = 0, y = date, xend = position, yend = date, color = status),
    show.legend = F
  ) +
  geom_vline(xintercept = 0, color = "black", linewidth = 1) +
  geom_label(
    aes(x = position, y = date, label = version, color = status),
    show.legend = FALSE
  ) +
  geom_point(aes(x = 0, y = date, color = status), size = 3, show.legend = FALSE) +
  geom_text(
    aes(x = 0, y = as.Date(format(date, "%Y-01-01")), label = year),
    hjust = -0.1
  ) +
  theme_void()
```

在 R 语言诞生的前 5 年里，每年发布 3 个主要版本，这 5 年是 R 软件活跃开发的时期。而 2003-2012 年的这 10 年，基本上每年发布 2 个主要版本。2013-2022 年的这 10 年，基本上每年发布 1 个主要版本。


[timevis](https://github.com/daattali/timevis) 包基于 JavaScript 库 [Vis](https://visjs.org/) 的 [vis-timeline](https://github.com/visjs/vis-timeline) 模块，可以 创建交互式的时间线图，支持与 Shiny 应用集成。





## 绘图经验 {#sec-principles-of-ggplot2}


就展示数据而言，本文将介绍数以十计的图形，如此丰富，就单一目的而言，也有多种可选的图形。可见，仅仅掌握 ggplot2 这套工具是远远不够的，还需要了解数据背景，探索、分析数据，获得数据洞见，只有结合这些，才知道选择最合适的图形，进而准确地传递信息，数据才能释放出应有的价值。


### 防止误差线图 {#sec-avoid-errorbar}

举例来说，如 @fig-avoid-errorbar 所示，图中从左往右、从上往下依次是误差线图、 、箱线图、提琴图和散点图，它们基于同一份数据，采用不同的图形展示数据的分布情况。在一些期刊杂志上， @fig-avoid-errorbar-1 非常受欢迎，而实际上它所表达的信息非常有限，严重的情况下，甚至会产生误导。

数据来自中国国家统计局 2021 年发布的统计年鉴，是分城市、镇和乡村的各省、自治区、直辖市的男女比例数据。
一般来说，各地区的性别比例不可能出现严重失调，比如男的是女的一倍，一个省要是出现如此失调的现象是非常罕见的。而 @fig-avoid-errorbar-1 的纵轴给人感觉还有性别比为 50% 甚至 30% 的情况，纯属误导。相比而言，箱线图 @fig-avoid-errorbar-2 就好很多，既把整体情况展示出来了，又将一些性别比例离群的突出出来了，就整个图形来说，城市、镇和乡村的比较也突出出来了，占据了图的主要位置。

在数据量很大的情况下，借助箱线图、提琴图可以非常方便地展示数据分布，


而在数据量很小的情况下，借助散点图可以快速看出原始的数据信息。


```{r}
#| label: fig-avoid-errorbar
#| fig-cap: "防止误差线图"
#| fig-subcap: 
#|   - 误差线
#|   - 箱线图
#|   - 提琴图
#|   - 提琴图和抖动图组合
#| fig-ncol: 2
#| fig-width: 4.5
#| fig-height: 3.5
#| echo: false
#| fig-showtext: true

library(data.table)
province_sex_ratio <- readRDS(file = "data/province-sex-ratio-2020.rds")
province_sex_ratio <- as.data.table(province_sex_ratio)

province_sex_ratio[, .(mean_len = mean(`性别比（女=100）`), sd_len = sd(`性别比（女=100）`)), by = "区域"] |>
  ggplot(aes(x = `区域`, y = mean_len)) +
  geom_col(
    position = position_dodge(0.4), width = 0.4
  ) +
  geom_errorbar(aes(ymin = mean_len - sd_len, ymax = mean_len + sd_len),
    position = position_dodge(0.4), width = 0.2
  ) +
  theme_classic() +
  labs(y = "性别比（女=100）")

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_boxplot() +
  theme_classic()

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin() +
  theme_classic()

library(ggforce)
ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_violin() +
  geom_sina() +
  theme_classic()
```

1.5 个百分点为间隔

```{r}
#| label: fig-visualize-distributions
#| fig-cap: "描述数据分布"
#| fig-subcap: 
#|   - 抖动图
#|   - 岭线图
#|   - 岭线图和抖动图组合
#|   - 岭线图和轴须图组合
#| fig-ncol: 2
#| fig-width: 4.5
#| fig-height: 3.5
#| echo: false
#| fig-showtext: true

ggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +
  geom_jitter(width = 0.25) +
  theme_classic()

library(ggridges)

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(bandwidth = 1.5, alpha = 0.7) +
  theme_classic()

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(bandwidth = 1.5, jittered_points = TRUE, alpha = 0.7) +
  theme_classic()

ggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = `区域`)) +
  geom_density_ridges(
    bandwidth = 1.5,
    jittered_points = TRUE,
    position = position_points_jitter(height = 0),
    point_shape = "|", point_size = 3,
    point_alpha = 1, alpha = 0.7
  ) +
  theme_classic()
```

:::{.callout-tip}
除了中国国家统计年鉴，各省、自治区、直辖市及各级统计局每年都会发布一些统计年鉴、公告等数据，读者可以在此基础上继续收集更多数据，来分析诸多有意思的问题：

1. 城市、镇和乡村男女性别比呈现差异化分布的成因。
1. 城市、镇和乡村男女年龄构成。
1. 将上述问题从省级下钻到市、县级来分析。
:::

