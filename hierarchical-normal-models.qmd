# 分层正态模型 {#sec-hierarchical-normal-models}

```{r}
#| echo: false

source("_common.R")
```

介绍分层正态模型的定义、结构、估计，分层正态模型与线性生长模型的关系，分层正态模型与潜变量模型的关系，分层正态模型与神经网络模型的关系，以 **rstan** 包和 **nlme** 包实现简单分层正态模型，说明 **rstan** 包的一些用法，比较贝叶斯参数估计和频率参数估计的结果，给出结果的解释。

```{r}
#| message: false

library(StanHeaders)
library(ggplot2)
library(rstan)
rstan_options(auto_write = TRUE)
# 如果CPU和内存足够，设置成与马尔科夫链一样多
options(mc.cores = max(c(floor(parallel::detectCores() / 2), 1L)))

custom_colors <- c(
  "#4285f4", # GoogleBlue
  "#34A853", # GoogleGreen
  "#FBBC05", # GoogleYellow
  "#EA4335"  # GoogleRed
)
rstan_ggtheme_options(
  panel.background = element_rect(fill = "white"),
  legend.position = "top"
)
rstan_gg_options(
  fill = "#4285f4", color = "white",
  pt_color = "#EA4335", chain_colors = custom_colors
)
```

## 8schools 数据 {#sec-eight-schools}

8schools 数据最早来自 @Rubin1981

分层正态模型

$$
\begin{aligned}
y_j &\sim \mathcal{N}(\theta_j,\sigma_j) \quad
\theta_j = \mu + \tau * \eta_j \\
\theta_j &\sim \mathcal{N}(\mu, \tau) \quad
\eta_j \sim \mathcal{N}(0,1)
\end{aligned}
$$

### 拟合模型

用 rstan 包来拟合模型

```{r}
# 编译模型
eight_schools_fit <- stan(
  model_name = "eight_schools",
  # file = "code/8schools.stan",
  model_code = "
  // saved as 8schools.stan
  data {
    int<lower=0> J;         // number of schools
    real y[J];              // estimated treatment effects
    real<lower=0> sigma[J]; // standard error of effect estimates
  }
  parameters {
    real mu;                // population treatment effect
    real<lower=0> tau;      // standard deviation in treatment effects
    vector[J] eta;          // unscaled deviation from mu by school
  }
  transformed parameters {
    vector[J] theta = mu + tau * eta;        // school treatment effects
  }
  model {
    target += normal_lpdf(eta | 0, 1);       // prior log-density
    target += normal_lpdf(y | theta, sigma); // log-likelihood
  }
  ",
  data = list( # 观测数据
    J = 8,
    y = c(28, 8, -3, 7, -1, 1, 18, 12),
    sigma = c(15, 10, 16, 11, 9, 11, 10, 18)
  ),
  warmup = 1000, # 每条链预处理迭代次数
  iter = 2000,   # 每条链总迭代次数
  chains = 2,    # 马尔科夫链的数目
  cores = 2,     # 指定 CPU 核心数，可以给每条链分配一个
  verbose = FALSE, # 不显示迭代的中间过程
  refresh = 0,     # 不显示采样的进度
  seed = 20190425  # 设置随机数种子，不要使用 set.seed() 函数
)
```

### 模型输出

```{r}
print(eight_schools_fit, digits = 1)
```

提取任意一个参数的结果，如查看参数 $\tau$ 的 95% 置信区间。

```{r}
print(eight_schools_fit, pars = "tau", probs = c(0.025, 0.975))
```

从迭代抽样数据获得与 `print(fit)` 一样的结果。以便后续对原始采样数据做任意的进一步分析。rstan 包扩展泛型函数 `summary()` 以支持对 stanfit 数据对象汇总，输出各个参数分链条和合并链条的后验分布结果。

### 操作数据

合并四条马氏链的结果

```{r}
eight_schools_sim <- extract(eight_schools_fit, permuted = TRUE)
```

返回的结果是一个列表

```{r}
str(eight_schools_sim)
class(eight_schools_sim)
```

计算参数 $\eta,\theta$ 的均值

```{r}
apply(eight_schools_sim$eta, 2, mean)
apply(eight_schools_sim$theta, 2, mean)
```

计算参数 $\eta,\theta$ 的分位点

```{r}
t(apply(eight_schools_sim$eta, 2, quantile, probs = c(2.5, 25, 50, 75, 97.5) / 100))
t(apply(eight_schools_sim$theta, 2, quantile, probs = c(2.5, 25, 50, 75, 97.5) / 100))
```

计算参数 $\mu,\tau$ 的均值

```{r}
lapply(eight_schools_sim["mu"], mean)
lapply(eight_schools_sim["tau"], mean)
lapply(eight_schools_sim["lp__"], mean)
```

计算参数 $\mu,\tau$ 的分位点

```{r}
lapply(eight_schools_sim["mu"], quantile, probs = c(2.5, 25, 50, 75, 97.5) / 100)
lapply(eight_schools_sim["tau"], quantile, probs = c(2.5, 25, 50, 75, 97.5) / 100)
lapply(eight_schools_sim["lp__"], quantile, probs = c(2.5, 25, 50, 75, 97.5) / 100)
```

### 采样诊断

获取马尔科夫链迭代点列数据

```{r}
eight_schools_sim <- extract(eight_schools_fit, permuted = FALSE)
```

`eight_schools_sim` 是一个三维数组，1000（次迭代）\* 2 （条链）\* 19（个参数）。如果 `permuted = TRUE` 则会合并四条马氏链的迭代结果，变成一个列表。

```{r}
# 数据类型
class(eight_schools_sim)
# 1000（次迭代）* 2 （条链）* 19（个参数）
str(eight_schools_sim)
```

提取参数 $\mu$ 的四条迭代点列

```{r}
eight_schools_mu_sim <- eight_schools_sim[, , "mu"]
```

```{r}
#| label: fig-8schools-mu-base
#| fig-cap: 参数 $\mu$ 的迭代轨迹
#| fig-showtext: true
#| par: true

matplot(eight_schools_mu_sim,
        xlab = "Iteration", ylab = expression(mu),
        type = "l", lty = "solid", col = custom_colors
)
abline(h = apply(eight_schools_mu_sim, 2, mean), col = custom_colors)
legend("bottomleft",
       legend = paste0("chain:", 1:2), box.col = "white", inset = 0.01,
       lty = "solid", horiz = TRUE, col = custom_colors
)
```

或者使用 rstan 提供的 `traceplot` 函数或者 `stan_trace` 函数，rstan 大量依赖 ggplot2 绘图，所以如果你熟悉 GGplot2 可以很方便地定制属于自己的风格，除了 rstan 提供的 `rstan_ggtheme_options` 和 `rstan_gg_options` 两个函数外，还可以使用 ggplot2 自带的大量配置选项和主题，如 `theme_minimal` 主题，因为 `stan_trace`等作图函数返回的是一个 ggplot 对象。

```{r}
#| label: fig-8schools-mu-gg
#| fig-cap: 马氏链的迭代序列
#| fig-showtext: true

stan_trace(eight_schools_fit, pars = "mu") +
  theme_minimal() +
  labs(x = "Iteration", y = expression(mu))
```

序列的自相关图，类似地，我们这里也使用 `stan_ac` 函数绘制自相关图

```{r}
#| label: fig-8schools-mu-acf
#| fig-cap: 马氏链的自相关图
#| fig-showtext: true
#| fig-height: 4

stan_ac(eight_schools_fit, pars = "mu", separate_chains = TRUE, color = "white") +
  theme_minimal()
```

### 后验分布

可以用 `stan_hist` 函数绘制参数 $\mu$ 的后验分布图，它没有 `separate_chains` 参数，所以不能分链条绘制

```{r}
#| label: fig-8schools-mu-hist
#| fig-cap: 参数 $\mu$ 的后验分布
#| fig-showtext: true

stan_hist(eight_schools_fit, pars = "mu", bins = 30) + theme_minimal()
```

参数 $\mu$ 和 $\tau$ 的散点图

```{r}
#| label: fig-8schools-mu-tau
#| fig-cap: 参数 $\mu$ 和 $\tau$ 的联合后验分布
#| fig-showtext: true

stan_scat(eight_schools_fit, pars = c("mu","tau")) + theme_minimal()
```

参数 $\mu$ 的后验概率密度分布图

```{r}
#| label: fig-8schools-mu-dens
#| fig-cap: 参数 $\mu$ 的后验概率密度分布图
#| fig-showtext: true

stan_dens(eight_schools_fit, pars = "mu", separate_chains = TRUE) +
  theme_minimal() +
  labs(x = expression(mu), y = "Density")
```

**bayesplot** 包的函数 `mcmc_pairs()` 以矩阵图展示多个参数的分布。

```{r}
#| label: fig-parameters-posterior
#| fig-cap: 参数 $\mu$，$\tau$ 和 $\mathrm{lp\_\_}$ 的后验分布图
#| fig-showtext: true

bayesplot::mcmc_pairs(eight_schools_fit, pars = c("mu", "tau", "lp__"))
```

### 其它 R 包

接下来，分别用 **nlme** 和 **lme4** 包拟合模型。

```{r}
# 成绩
y <- c(28, 8, -3, 7, -1, 1, 18, 12)
# 标准差
sigma <- c(15, 10, 16, 11, 9, 11, 10, 18)
# 学校编号
g <- 1:8
```

首先，调用 **nlme** 包的函数 `lme()` 拟合模型。

```{r}
library(nlme)
fit_lme <- lme(y ~ 1, random = ~ 1 | g, weights = varFixed(~ sigma^2), method = "REML")
summary(fit_lme)
```

随机效应的标准差 2.917988 ，随机效应部分的估计

```{r}
ranef(fit_lme)
```

类比 Stan 输出结果中的 $\theta$ 向量，每个学校的成绩估计

```{r}
7.785729 + 2.917988 * ranef(fit_lme) 
```

接着，采用 **lme4** 包拟合模型，发现 **lme4** 包获得与 **nlme** 包一样的结果。

```{r}
control <- lme4::lmerControl(
  check.conv.singular = "ignore",
  check.nobs.vs.nRE = "ignore",
  check.nobs.vs.nlev = "ignore"
)
fit_lme4 <- lme4::lmer(y ~ 1 + (1 | g), weights = 1 / sigma^2, control = control, REML = TRUE)
summary(fit_lme4)
```

最后，使用 blme 包 [@Chung2013] ，blme 包基于 lme4 包，截距项结果比较一致，随机效应（组间方差）和残差项（组内方差）完全不同。

```{r}
### Example using a residual variance prior ###
# This is the "eight schools" data set; 
# the mode should be at the boundary of the space.

fit_blme <- blme::blmer(
  y ~ 1 + (1 | g),
  control = control, REML = TRUE,
  resid.prior = point, cov.prior = NULL,
  weights = 1 / sigma^2
)
summary(fit_blme)
```

## rats 数据 {#sec-thirty-rats}

rats 数据最早来自 @gelfand1990 ，记录 30 只小鼠每隔一周的重量，一共进行了 5 周。第一次记录是小鼠第 8 天的时候，第二次测量记录是第 15 天的时候，一直持续到第 36 天。下面在 R 环境中准备数据。

```{r}
# 总共 30 只老鼠
N <- 30
# 总共进行 5 周
T <- 5
# 小鼠重量
y <- structure(c(
  151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
  160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
  157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
  189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
  203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
  263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
  248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
  219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
  273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
  286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
  338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
  334, 302, 302, 323, 331, 345, 333, 316, 291, 324
), .Dim = c(30, 5))
# 第几天
x <- c(8.0, 15.0, 22.0, 29.0, 36.0)
xbar <- 22.0
```

重复测量的小鼠重量数据 rats 如下 @tbl-rats 所示。

```{r}
#| label: tbl-rats
#| tbl-cap: 小鼠重量数据（部分）
#| echo: false

rownames(y) <- 1:30
knitr::kable(head(y), col.names = paste("第", c(8, 15, 22, 29, 36), "天"), row.names = TRUE)
```

小鼠重量数据的分布情况见下 @fig-rats ，由图可以假定 30 只小鼠的重量服从正态分布。

```{r}
#| label: fig-rats
#| fig-cap: 30 只小鼠 5 次测量的数据
#| fig-showtext: true
#| par: true
#| echo: false
#| fig-width: 5
#| fig-height: 4.5

matplot(y, xlab = "小鼠编号", ylab = "小鼠重量")
```

由 @fig-rats-growth 可见， 30 只小鼠的重量增长趋势呈现一种线性趋势。

```{r}
#| label: fig-rats-growth
#| fig-cap: 30 只小鼠 5 次测量的数据
#| fig-showtext: true
#| par: true
#| echo: false
#| fig-width: 5
#| fig-height: 4.5

matplot(t(y), xlab = "测量次数", ylab = "小鼠重量")
```

### rstan {#sec-rats-rstan}

初始化模型参数，设置采样算法的参数。

```{r}
# 迭代链
chains <- 4
# 迭代次数
iter <- 1000
# 初始值
init <- rep(list(list(
  alpha = rep(250, 30), beta = rep(6, 30),
  alpha_c = 150, beta_c = 10,
  tausq_c = 1, tausq_alpha = 1,
  tausq_beta = 1
)), chains)
```

接下来，基于重复测量数据，建立线性生长曲线模型：

$$
\begin{aligned}
\alpha_c &\sim \mathcal{N}(0,100) \quad \beta_c  \sim \mathcal{N}(0,100) \\
\tau^2_{\alpha} &\sim \mathrm{inv\_gamma}(0.001, 0.001) \\
\tau^2_{\beta}  &\sim \mathrm{inv\_gamma}(0.001, 0.001) \\
\tau^2_c &\sim \mathrm{inv\_gamma}(0.001, 0.001) \\
\alpha_n &\sim \mathcal{N}(\alpha_c, \tau_{\alpha})  \quad
\beta_n  \sim \mathcal{N}(\beta_c, \tau_{\beta}) \\
y_{nt} &\sim \mathcal{N}(\alpha_n + \beta_n * (x_t - \bar{x}), \tau_c) \\
& n = 1,2,\ldots,N \quad t = 1,2,\ldots,T
\end{aligned}
$$

其中， $\alpha_c,\beta_c,\tau_c,\tau_{\alpha},\tau_{\beta}$ 为无信息先验，$\bar{x} = 22$ 表示第 22 天，$N = 30$ 和 $T = 5$ 分别表示实验中的小鼠数量和测量次数，下面采用 Stan 编码、编译、采样和拟合模型。

```{r}
rats_fit <- stan(
  model_name = "rats",
  model_code = "
  data {
    int<lower=0> N;
    int<lower=0> T;
    vector[T] x;
    matrix[N,T] y;
    real xbar;
  }
  parameters {
    vector[N] alpha;
    vector[N] beta;

    real alpha_c;
    real beta_c;          // beta.c in original bugs model

    real<lower=0> tausq_c;
    real<lower=0> tausq_alpha;
    real<lower=0> tausq_beta;
  }
  transformed parameters {
    real<lower=0> tau_c;       // sigma in original bugs model
    real<lower=0> tau_alpha;
    real<lower=0> tau_beta;

    tau_c = sqrt(tausq_c);
    tau_alpha = sqrt(tausq_alpha);
    tau_beta = sqrt(tausq_beta);
  }
  model {
    alpha_c ~ normal(0, 100);
    beta_c ~ normal(0, 100);
    tausq_c ~ inv_gamma(0.001, 0.001);
    tausq_alpha ~ inv_gamma(0.001, 0.001);
    tausq_beta ~ inv_gamma(0.001, 0.001);
    alpha ~ normal(alpha_c, tau_alpha); // vectorized
    beta ~ normal(beta_c, tau_beta);  // vectorized
    for (n in 1:N)
      for (t in 1:T)
        y[n,t] ~ normal(alpha[n] + beta[n] * (x[t] - xbar), tau_c);
  }
  generated quantities {
    real alpha0;
    alpha0 = alpha_c - xbar * beta_c;
  }
  ",
  data = list(N = N, T = T, y = y, x = x, xbar = xbar),
  chains = chains, init = init, iter = iter,   
  verbose = FALSE, refresh = 0, seed = 20190425
)
```

模型输出结果如下：

```{r}
print(rats_fit, pars = c("alpha", "beta"), include = FALSE, digits = 1)
```

`alpha_c` 表示小鼠 5 次测量的平均重量，`beta_c` 表示小鼠体重的增长率，$\alpha_i,\beta_i$ 分别表示第 $i$ 只小鼠在第 22 天（第 3 次测量或 $x_t = \bar{x}$ ）的重量和增长率（每日增加的重量）。

对于分量众多的参数向量，比较适合用岭线图展示后验分布，下面调用 **bayesplot** 包绘制参数向量 $\boldsymbol{\alpha},\boldsymbol{\beta}$ 的后验分布。

```{r}
#| label: fig-rats-alpha
#| fig-cap: 参数 $\boldsymbol{\alpha}$ 的后验分布
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 8
#| message: false

# plot(rats_fit, pars = "alpha", show_density = TRUE, ci_level = 0.8, outer_level = 0.95)
bayesplot::mcmc_areas_ridges(rats_fit, pars = paste0("alpha", "[", 1:30, "]")) +
  scale_y_discrete(labels = scales::parse_format()) 
```

参数向量 $\boldsymbol{\alpha}$ 的后验估计可以看作 $x_t = \bar{x}$ 时小鼠的重量，上图即为各个小鼠重量的后验分布。

```{r}
#| label: fig-rats-beta
#| fig-cap: 参数 $\boldsymbol{\beta}$ 的后验分布
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 8
#| message: false

# plot(rats_fit, pars = "beta", ci_level = 0.8, outer_level = 0.95)
bayesplot::mcmc_areas_ridges(rats_fit, pars = paste0("beta", "[", 1:30, "]")) +
  scale_y_discrete(labels = scales::parse_format()) 
```

参数向量 $\boldsymbol{\beta}$ 的后验估计可以看作是小鼠的重量的增长率，上图即为各个小鼠重量的增长率的后验分布。

### nlme {#sec-rats-nlme}

**nlme** 包适合长格式的数据，因此，先将小鼠数据整理成长格式。

```{r}
weight <- c(
  151, 145, 147, 155, 135, 159, 141, 159, 177, 134,
  160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146,
  157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210,
  189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212,
  203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249,
  263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242,
  248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248,
  219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313,
  273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285,
  286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305,
  338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321,
  334, 302, 302, 323, 331, 345, 333, 316, 291, 324
)
rats <- rep(1:30, times = 5)
days <- rep(c(8, 15, 22, 29, 36), each = 30)
rats_data <- data.frame(weight = weight, rats = rats, days = days)
```

将 30 只小鼠的重量变化及回归曲线画出来，发现各只小鼠的回归线的斜率几乎一样，截距略有不同。不同小鼠的出生重量是不同，前面 Stan 采用变截距变斜率的混合效应模型拟合数据。

```{r}
#| label: fig-rats-lm
#| fig-cap: 小鼠重量变化曲线
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 7

ggplot(data = rats_data, aes(x = days, y = weight)) +
  geom_point() +
  geom_smooth(formula = "y ~ x", method = "lm", se = FALSE) +
  theme_bw() +
  facet_wrap(facets = ~rats, labeller = "label_both", ncol = 6) +
  labs(x = "第几天", y = "重量")
```

小鼠的重量随时间增长，不同小鼠的情况又会有所不同。可用随机效应模型表示生长曲线模型，下面加载 **nlme** 包调用函数 `lme()` 拟合该模型。

```{r}
library(nlme)
rats_lme <- lme(data = rats_data, fixed = weight ~ days, random = ~ days | rats)
summary(rats_lme)
```

模型输出结果中，固定效应中的截距项 `(Intercept)` 对应 106.56762，斜率 `days` 对应 6.18571。Stan 模型中截距参数 `alpha0` 的后验估计是 106.332，斜率参数 `beta_c` 的后验估计是 6.188。对比 Stan 和 **nlme** 包的拟合结果，可以发现贝叶斯和频率方法的结果是非常接近的。截距参数 `alpha0` 可以看作小鼠的初始（出生）重量，斜率参数 `beta_c` 可以看作小鼠的生长率 growth rate。

函数 `lme()` 的输出结果中，随机效应的随机截距标准差 10.7425835，对应 `tau_alpha`，表示每个小鼠的截距偏移量的波动。而随机斜率的标准差为 0.5105447，对应 `tau_beta`，相对随机截距标准差来说很小。残差标准差为 6.0146608，对应 `tau_c`，表示与小鼠无关的剩余量的波动，比如测量误差。总之，和 Stan 的结果有所不同，但相去不远。主要是前面的 Stan 模型没有考虑随机截距和随机斜率之间的相关性，这可以进一步调整 [@sorensen2016] 。

Stan 输出中，截距项 alpha、斜率项 beta 参数的标准差分别是 `tau_alpha` 和 `tau_beta` ，残差标准差参数 `tau_c` 的估计为 6.1。简单起见，没有考虑截距项和斜率项的相关性，即不考虑小鼠出生时的重量和生长率的相关性，一般来说，应该是有关系的。函数 `lme()` 的输出结果中给出了截距项和斜率项的相关性为 -0.343，随机截距和随机斜率的相关性为 -0.159。

计算与 Stan 输出中的截距项 `alpha_c` 对应的量，结合函数 `lme()` 的输出，截距、斜率加和之后，如下

```{r}
106.56762 + 6.18571 * 22
```

值得注意，Stan 代码中对时间 days 做了中心化处理，即 $x_t - \bar{x}$，目的是降低采样时参数 $\alpha_i$ 和 $\beta_i$ 之间的相关性，而在拟合函数 `lme()` 中没有做处理，因此，结果无需转化，而且更容易解释。

```{r}
fit_lm <- lm(weight ~ days, data = rats_data)
summary(fit_lm)
```

采用简单线性模型即可获得与 **nlme** 包非常接近的估计结果，主要是小鼠重量的分布比较正态，且随时间的变化非常线性。

### lavaan

**lavaan** 包 [@Rosseel2012] 主要是用来拟合结构方程模型，而生长曲线模型可以放在该框架下。所以，也可以用 **lavaan** 包来拟合，并且，它提供的函数 `growth()` 可以直接拟合生长曲线模型。

```{r}
#| message: false

library(lavaan)
# 设置矩阵 y 的列名
colnames(y) <- c("t1","t2","t3","t4","t5")
rats_growt_model <- " 
  # intercept and slope with fixed coefficients
  intercept =~ 1*t1 + 1*t2 + 1*t3 + 1*t4 + 1*t5
  days =~ 0*t1 + 1*t2 + 2*t3 + 3*t4 + 4*t5 

  # if we fix the variances to be equal, the models are now identical.
  t1 ~~ resvar*t1    
  t2 ~~ resvar*t2
  t3 ~~ resvar*t3
  t4 ~~ resvar*t4
  t5 ~~ resvar*t5
"
```

其中，算子符号 `=~` 定义潜变量，`~~` 定义残差协方差，intercept 表示截距， days 表示斜率。假定 5 次测量的测量误差（组内方差）是相同的。拟合模型的代码如下：

```{r}
rats_growth_fit <- growth(rats_growt_model, data = y)
```

提供函数 `summary()` 获得模型输出，结果如下：

```{r}
summary(rats_growth_fit)
```

输出结果显示 **lavaan** 包的函数 `growth()` 采用极大似然估计方法。协方差部分 `Covariances:` 随机效应中斜率和截距的协方差。截距部分 `Intercepts:` 对应于混合效应模型的固定效应部分。方差部分 `Variances:` 对应于混合效应模型的随机效应部分，包括残差方差、斜率和截距的方差。不难看出，这和前面 **nlme** 包的输出结果差别很大。原因是 **lavaan** 包将测量的次序从 0 开始计，0 代表小鼠出生后的第 8 天。也就是说，**lavaan** 采用的是次序标记，而不是实际数据。将测量发生的时间（第几天）换算成次序（第几次），并从 0 开始计，则函数 `lme()` 的输出和函数 `growth()` 就一致了。

```{r}
# 重新组织数据
days2 <- rep(c(0, 1, 2, 3, 4), each = 30)
rats_data2 <- data.frame(weight = weight, rats = rats, days = days2)
# ML 方法估计模型参数
rats_lme2 <- lme(data = rats_data2, fixed = weight ~ days, random = ~ days | rats, method = "ML")
summary(rats_lme2)
```

可以看到函数 `growth()` 给出的截距和斜率的协方差估计为 8.444，函数 `lme()` 给出对应截距和斜率的标准差分别是 10.652390 和 3.496588，它们的相关系数为 0.227，则函数 `lme()` 给出的协方差估计为 `10.652390*3.496588*0.227` ，即 8.455，协方差估计比较一致。同理，比较两个输出结果中的其它成分，函数 `growth()` 给出的残差方差估计为 36.176，则残差标准差估计为 6.0146，结合函数 `lme()` 给出的 `Random effects:` 中 `Residual`，结果完全一样。函数 `growth()` 给出的 `Intercepts:` 对应于函数 `lme()` 给出的固定效应部分，结果也是完全一样。

```{r}
AIC(rats_growth_fit)
BIC(rats_growth_fit)
logLik(rats_growth_fit)
```

针对模型拟合对象 `rats_growth_fit` ，除了函数 `summary()` 可以汇总结果，**lavaan** 包还提供 `AIC()` 、 `BIC()` 和 `logLik()` 等函数，分别可以提取 AIC、BIC 和对数似然值，结果与前面的函数 `lme()` 的输出是一样的。

### lme4

当采用 **lme4** 包拟合数据的时候，发现输出结果与 **nlme** 包几乎相同。

```{r}
rats_lme4 <- lme4::lmer(weight ~ days + (days | rats), data = rats_data)
summary(rats_lme4)
```

### blme

blme 包基于 lme4 包拟合贝叶斯线性混合效应模型。

```{r}
rats_blme <- blme::blmer(
  weight ~ days + (days | rats), data = rats_data,
  resid.prior = point, cov.prior = NULL
)
summary(rats_blme)
```

### INLA

边际似然中包含随机效应对应的潜高斯分布的积分，INLA 包采用集成嵌套拉普拉斯近似积分。

```{r}
#| message: false

library(INLA)
rats_inla <- inla(weight ~ 1 + days + f(rats, days, model = "iid"),
  data = rats_data, control.predictor = list(compute = TRUE),
  control.compute = list(dic = TRUE))
# 输出结果
summary(rats_inla)
# 固定效应部分的参数估计
rats_inla$summary.fixed
# 随机效应部分（方差协方差矩阵）的超参数
rats_inla$summary.hyperpar
```

从输出结果来看，`Fixed effects:` 部分与前面的输出完全一样。贝叶斯推断给出的是参数的后验分布，所以，不仅是后验点估计，同时给出几个后验分布的分位点，置信水平 95% 的置信区间为 $[103.568, 109.569]$ 。从结果中提取，截距项 `(Intercept)` 的后验边际分布

```{r}
#| label: fig-inla-rats-intercept
#| fig-cap: 截距项的后验边际分布
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

data_i <- rats_inla$marginals.fixed[[1]]
library(ggplot2)
ggplot(data.frame(inla.smarginal(data_i)), aes(x, y)) +
  geom_line() +
  theme_bw()
```

已知随机变量 $X$ 的分布，根据 $P(X < x) = 0.05$ 可得 0.05 分位点 $x$ 。后验分布的 5% 分位点如下。

```{r}
quant <- inla.qmarginal(0.05, data_i)
quant
```

小于 0.05 分位点的概率图如下。

```{r}
#| label: fig-inla-rats-intercept2
#| fig-cap: 截距项的后验边际分布
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

ggplot(data.frame(inla.smarginal(data_i)), aes(x, y)) +
  geom_line() +
  geom_area(data = subset(data.frame(inla.smarginal(data_i)),
                                     x < quant),
            fill = "gray") +
  theme_bw()
```

根据方差的后验边际分布获得随机效应对应的组间方差，方差的后验边际分布图如下。

```{r}
# 边际方差的后验采样数据
marg_variance <- inla.tmarginal(function(x) 1/x,
rats_inla$marginals.hyperpar$`Precision for rats`)
```

```{r}
#| label: fig-inla-rats-variance
#| fig-cap: 方差的后验边际分布
#| fig-width: 5
#| fig-height: 4.5
#| fig-showtext: true

ggplot(data.frame(inla.smarginal(marg_variance)), aes(x, y)) +
  geom_line() +
  theme_bw()
```

边际方差的估计如下：

```{r}
m <- inla.emarginal(function(x) x, marg_variance)
m
```

计算边际方差的标准偏差 $\mathsf{Var}(X) = \mathsf{E}(X^2) - (\mathsf{E}(X))^2$

```{r}
mm <- inla.emarginal(function(x) x^2, marg_variance)
# 方差的标准偏差
sqrt(mm - m^2)
```

## 习题 {#sec-hierarchical-models-exercises}

1.  四个组的重复测量数据，如下表所示，建立贝叶斯线性混合效应模型/分层正态模型分析数据，与 nlme 包拟合的结果对比。

    ```{r}
    #| label: tbl-exer
    #| tbl-cap: 实验数据
    #| echo: false

    y <- c(
      62, 60, 63, 59,
      63, 67, 71, 64, 65, 66,
      68, 66, 71, 67, 68, 68,
      56, 62, 60, 61, 63, 64, 63, 59
    )
    group <- c(rep(1, 4), rep(2, 6), rep(3, 6), rep(4, 8))
    id <- c(1:4, 1:6, 1:6, 1:8)
    dat <- data.frame(y = y, group = group, id = id)
    dat2 <- reshape(dat, direction = "wide", timevar = "group", idvar = "id")
    options(knitr.kable.NA = '')
    knitr::kable(dat2, col.names = c("编号", "第1组", "第2组", "第3组", "第4组"), row.names = FALSE)
    ```

    $$
    \begin{aligned}
    y_{ij}   \sim \mathcal{N}(\theta_i, \sigma^2) &\quad
    \theta_i \sim \mathcal{N}(\mu, \tau^2) \\
    (\mu,\log \sigma, \tau) &\sim \mathrm{uniform\ prior} \\
    i = 1,2,3,4 &\quad j = 1,2, \ldots, n_i
    \end{aligned}
    $$

    $y_{ij}$ 表示第 $i$ 组的第 $j$ 个测量值，$\theta_i$ 表示第 $i$ 组的均值，$\mu$ 表示整体的均值，$\sigma^2$ 表示组内的方差，$\tau^2$ 表示组内的方差。

    ```{r}
    library(nlme)
    fit_lme <- lme(data = dat, fixed = y ~ 1, random = ~ 1 | group)
    summary(fit_lme)
    ```

    随机效应（组间标准差）$\tau^2$ 3.419288 、残差效应（组内标准差）$\sigma^2$ 2.366309。截距 $\mu$ 64.01266 代表整体的均值。各组的均值如下：

    ```{r}
    64.01266 + ranef(fit_lme)
    ```

2.  基于 **lme4** 包中学生对老师的评价数据 `InstEval` 建立（广义）线性混合效应模型分析数据。将响应变量（学生评价）视为有序的离散型变量，比较观察两个模型拟合效果（lme4、GLMMadaptive、spaMM 都不支持有序的响应变量，brms 则支持各类有序回归，使用语法与 lme4 完全一样。但是，由于数据规模比较大，计算时间数以天计，可考虑用 Stan 直接编码）。再者，从 Stan 实现的贝叶斯模型来看，感受 Stan 建模的灵活性和扩展性。（**nlme** 包不支持此等交叉随机效应的表达。）

    ```{r}
    data(InstEval, package = "lme4")
    str(InstEval)
    ```

    -   因子型变量 `s` 表示 1-2972 位参与评分的学生。
    -   因子型变量 `d` 表示 1-2160 位上课的讲师。
    -   因子型变量 `dept` 表示课程相关的 1-15 院系。
    -   因子型变量 `service` 表示讲师除了授课外，是否承担其它服务。
    -   数值型变量 `y` 表示学生给课程的评分，1-5 分对应从坏到很好。

    ```{r}
    # 数值型的响应变量
    fit_lme4 <- lme4::lmer(y ~ 1 + service + (1 | s) + (1 | d) + (1 | dept), data = InstEval)
    summary(fit_lme4)
    ```

    ```{r}
    #| eval: false
    #| echo: true

    # 需要 5-10 分钟时间
    # 有序因子型的响应变量
    InstEval$y <- factor(InstEval$y, ordered = TRUE)
    library(ordinal)
    fit_ordinal <- clmm(
      y ~ 1 + service + (1 | s) + (1 | d) + (1 | dept),
      data = InstEval, link = "probit", threshold = "equidistant"
    )
    summary(fit_ordinal)
    ```
