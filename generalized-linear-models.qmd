# 广义线性模型 {#sec-bayesian-generalized-linear-models}

```{r}
#| echo: false

Sys.setenv(CMDSTANR_NO_VER_CHECK = TRUE)
```

[Stan](https://github.com/stan-dev) 是一个贝叶斯统计建模和计算的概率推理框架，也是一门用于贝叶斯推断和优化的概率编程语言 [@Gelman2015; @Carpenter2017]。它使用汉密尔顿蒙特卡罗算法（Hamiltonian Monte Carlo algorithm ，简称 HMC 算法）抽样，内置一种可以自适应调整采样步长的 No-U-Turn sampler （简称 NUTS 采样器） 。Stan 还提供自动微分变分推断（Automatic Differentiation Variational Inference algorithm 简称 ADVI 算法）算法做近似贝叶斯推断获取参数的后验分布，以及拟牛顿法（the limited memory Broyden-Fletcher-Goldfarb-Shanno algorithm 简称 L-BFGS 算法）优化算法获取参数的惩罚极大似然估计。

经过 10 多年的发展，Stan 已经形成一个相对成熟的生态，它提供统计建模、数据分析和预测能力，广泛应用于社会、生物、物理、工程、商业等领域，在学术界和工业界的影响力也不小。下 @fig-stan-api 是 Stan 生态中各组件依赖架构图，[math](https://github.com/stan-dev/math) 库是 Stan 框架最核心的组件，它基于 [boost](https://github.com/boostorg/boost) 、[eigen](https://gitlab.com/libeigen/eigen) 、[opencl](https://www.khronos.org/opencl/) 、[sundials](https://github.com/LLNL/sundials) 和 [oneTBB](https://github.com/oneapi-src/oneTBB) 等诸多 C++ 库，提供概率推理、自动微分、矩阵计算、并行计算、GPU 计算和求解代数微分方程等功能。

```{mermaid}
%%| label: fig-stan-api
%%| fig-width: 6.5
%%| fig-cap: Stan、CmdStan 和 CmdStanR 等的依赖关系图

flowchart TB
  boost(boost) --> math(math)
  eigen(eigen) --> math(math)
  opencl(opencl) --> math(math)
  sundials(sundials) --> math(math)
  onetbb(onetbb) --> math(math)
  math(math) --> Stan(Stan)
  Stan(Stan) --> CmdStan(CmdStan)
  Stan(Stan) --> RStan(RStan)
  RStan --> rstanarm(rstanarm)
  RStan --> brms(brms)
  RStan --> prophet(prophet)
  CmdStan --> CmdStanR(CmdStanR)
  CmdStan --> CmdStanPy(CmdStanPy)
  CmdStan --> MathematicaStan(MathematicaStan)
```

CmdStan 是 Stan 的命令行接口，可在 MacOS / Linux 的终端软件，Windows 的命令行窗口或 PowerShell 软件中使用。**CmdStanR、**CmdStanPy 和 MathematicaStan 分别是 CmdStan 的 R 语言、Python 语言和 Mathematica 语言接口。每次当 Stan 发布新版本时，CmdStan 也会随之发布新版，只需指定新的 CmdStan 安装路径，**CmdStanR** 就可以使用上，**CmdStanR** 包与 Stan 是相互独立的更新机制。 **CmdStanR** 负责处理 CmdStan 运行的结果，而编译代码，生成模型和模拟采样等都是由 **CmdStan 完成**。入门 **CmdStanR** 后，可以快速转入对 Stan 底层原理的学习，有利于编码符合实际需要的复杂模型，有利于掌握常用的炼丹技巧，提高科研和工作的效率。

[**rstan**](https://github.com/stan-dev/rstan) 是 Stan 的 R 语言接口，该接口依赖 **Rcpp**、**RcppEigen**、**BH**、**RcppParallel** 和 **StanHeaders** 等 R 包，由于存在众多上游 R 包依赖，**RStan** 的更新通常滞后于 Stan 的更新，而且滞后很多，不利于及时地使用最新的学术研究成果。 因此，相比于 **rstan** 包，**CmdStanR** 更加轻量，可以更快地将 CmdStan 的新功能融入进来，**cmdstanr** 和 CmdStan 是分离的，方便用户升级和维护。

[**rstanarm**](https://github.com/stan-dev/rstanarm) 和 [**brms**](https://github.com/paul-buerkner/brms) 是 **RStan** 的扩展包，各自提供了一套用于表示统计模型的公式语法。它们都支持丰富的统计模型，比如线性模型、广义线性模型、线性混合效应模型、广义线性混合效应模型等。相比于 **rstan**， 它们使用起来更加方便，因为它内置了大量统计模型的 Stan 实现，即将公式语法翻译成 Stan 编码的模型，然后调用 **rstan** 或 **cmdstanr** 翻译成 C++，最后编译成动态链接库。除了依赖 **rstan** 包，**rstanarm** 和 **brms** 还依赖大量其它 R 包，因此，安装、更新都比较麻烦。

顺便一提，类似的用于概率推理和统计分析的框架，还有 Python 社区的 [PyMC3](https://github.com/pymc-devs/pymc3) 和 [TensorFlow Probability](https://www.tensorflow.org/probability)。

## 概率编程语言

Stan 是一门用于贝叶斯推断和优化的概率编程语言。下面以一个简单示例介绍 Stan 的用法，包括 Stan 的基本用法、变量类型、代码结构等，

```{r}
#| echo: false

# 注册 Stan 引擎替换 Quarto 文档中默认的 Stan 块
# 原 Stan 块的编译采用 rstan 包
# eng_cmdstan 不支持传递函数 cmdstan_model 的其他参数选项
knitr::knit_engines$set(stan = cmdstanr::eng_cmdstan)
```

### Stan 的基本用法

考虑一个已知方差的正态分布，设 $-3, -2, -1, 0, 1, 2, 3$ 是取自正态分布 $\mathcal{N}(\mu,1)$ 的一个样本，也是取自该正态分布的一组随机数。现在的问题是估计该正态分布的均值参数 $\mu$ 。Stan 编码的正态分布模型如下：

```{stan output.var="mod_gaussian"}
transformed data {
  vector[7] y = [-3, -2, -1, 0, 1, 2, 3]';
}
parameters {
  real mu;
}
model {
  y ~ normal(mu, 1);
}
```

-   `transformed data` 代码块是一组已知的数据，这部分数据是不需要从外部传递进来的。这个样本是以向量存储的，需要声明向量的长度和类型（默认类型是实数），每一行以分号结尾，这与 C++ 的语法一样。

-   `parameters` 代码块是未知的参数，需要声明各个参数的类型。这里只有一个参数，且只是一个未知的实数，声明类型即可。

-   `model` 代码块是抽样语句表示的模型结构，符号 `~` 表示服从的意思，函数 `y ~ normal(mu, 1)` 是正态分布的抽样语句。

接下来，编译 Stan 代码，准备参数初值，配置采样的参数。首先加载 **cmdstanr** 包，设置 2 条迭代链，给每条链设置相同的参数初始值。代码编译后，生成一个模型对象 `mod_gaussian`，接着，调用方法 `sample()` ，传递迭代初值 `init`，初始化阶段的迭代次数 `iter_warmup` ，采样阶段的迭代次数 `iter_sampling`，采样的链条数 `chains` 及并行时 分配的 CPU 核心数 `parallel_chains` ，随机数种子 `seed` 。

```{r}
#| message: false

library(cmdstanr)
nchains <- 2 # 2 条迭代链
# 给每条链设置相同的参数初始值
inits_data_gaussian <- lapply(1:nchains, function(i) {
  list(
    mu = 1
  )
})

fit_gaussian <- mod_gaussian$sample(
  init = inits_data_gaussian,   # 迭代初值
  iter_warmup = 200,            # 每条链初始化迭代次数
  iter_sampling = 200,          # 每条链采样迭代次数
  chains = nchains,         # 马尔科夫链的数目
  parallel_chains = nchains,# 指定 CPU 核心数，可以给每条链分配一个
  seed = 20232023           # 设置随机数种子，不要使用 set.seed() 函数
)
```

默认情况下，采样过程中会输出一些信息，以上是 2 条链并行采样的过程，给出百分比进度及时间消耗。采样完成后，调用方法 `summary()` 汇总和展示采样结果。

```{r}
fit_gaussian$summary()
```

输出模型中各个参数的后验分布的一些统计量，如均值（mean）、中位数（median）、标准差（sd），0.05 分位点（q5），0.95 分位点（q95）等。此外，还有 `lp__` 后验对数概率密度值，每个模型都会有该值。`summary()` 方法有一些参数可以控制数字的显示方式和精度。下面展示的是保留 4 位有效数字的结果。

```{r}
fit_gaussian$summary(.num_args = list(sigfig = 4, notation = "dec"))
```

接下来，要介绍 Stan 代码中的保留字 target 的含义，因为它在 Stan 代码中很常见，与输出结果中的 `lp__` 一行紧密相关。

-   `lp__` 表示后验概率密度函数的对数。
-   target 累加一些和参数无关的数不影响参数的估计，但影响 `lp__` 的值。
-   抽样语句表示模型会扔掉后验概率密度函数的对数的常数项。

```{r}
#| label: fig-stan-lp
#| fig-cap: lp__ 的后验分布
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 4
#| message: false

library(ggplot2)
library(bayesplot)
mcmc_hist(fit_gaussian$draws("lp__")) +
  theme_classic()
```

为此，不妨在之前的 Stan 代码的基础上添加两行，新的 Stan 代码如下：

```{stan output.var="mod_gaussian_target"}
transformed data {
  vector[7] y = [-3, -2, -1, 0, 1, 2, 3]';
}
parameters {
  real mu;
}
model {
  y ~ normal(mu, 1);
  target += 12345;
  target += mean(exp(y));
}
```

接着，再次编译代码、采样，为了节约篇幅，设置两个参数 `show_messages` 和 `refresh` ，不显示中间过程和采样进度。其它参数设置不变，代码如下：

```{r}
fit_gaussian <- mod_gaussian_target$sample(
  init = inits_data_gaussian,   
  iter_warmup = 200,            
  iter_sampling = 200,          
  chains = nchains,             
  parallel_chains = nchains,      
  show_messages = FALSE,    # 不显示中间过程
  refresh = 0,              # 不显示采样进度
  seed = 20232023           
)
fit_gaussian$summary(.num_args = list(sigfig = 4, notation = "dec"))
```

可以清楚地看到 `lp__` 的值发生了变化，而参数 `mu` 的值没有变化。这是因为抽样语句 `y ~ normal(mu, 1);` 隐含一个 `lp__` ，target 指代 `lp__` 的值，符号 `+=` 表示累加。两次累加后得到 12335.09。

``` stan
model {
  y ~ normal(mu, 1);
  target += 12345;
  target += mean(exp(y));
}
```

```{r}
y <- c(-3, -2, -1, 0, 1, 2, 3)
12345 + mean(exp(y)) - 14.45 
```

下面从概率密度函数出发，用 R 语言来计算逐点对数似然函数值。一般地，不妨设 $x_1,x_2,\cdots,x_n$ 是来自正态总体 $\mathcal{N}(\mu,1)$ 的一个样本。则正态分布的概率密度函数 $f(x)$ 的对数如下：

$$
\log f(x) = \log \frac{1}{\sqrt{2\pi}} - \frac{(x - \mu)^2}{2}
$$

已知参数 $\mu$ 是一个非常接近 0 的数，不妨将 $\mu = 0$ 代入计算。

```{r}
sum(dnorm(x = y, mean = 0, sd = 1, log = TRUE))
```

去掉常数项后，计算概率密度函数值的对数和。

```{r}
# 扔掉常数
f <- function(y, mu) {
  return(-0.5 * (y - mu)^2)
}
sum(f(-3:3, 0))
```

这就比较接近原 `lp__` 的值了，所以，`lp__` 表示后验概率密度函数的对数，扔掉了与参数无关的常数项。若以概率密度函数的对数 `normal_lpdf` 替代抽样语句，则常数项是保留的。`normal_lpdf` 是 Stan 内置的函数，输入值为随机变量的取值 `y` 、位置参数 `mu` 和尺度参数 `sigma`，返回值为 `real` 实数。

`real` **`normal_lpdf`**`(reals y | reals mu, reals sigma)`

```{stan output.var="mod_gaussian_lpdf"}
transformed data {
  vector[7] y = [-3, -2, -1, 0, 1, 2, 3]';
}
parameters {
  real mu;
}
model {
  target += normal_lpdf(y | mu, 1);
}
```

接着，编译上述代码以及重复采样的步骤，参数设置也一样。

```{r}
fit_gaussian <- mod_gaussian_lpdf$sample(
  init = inits_data_gaussian, 
  iter_warmup = 200,            
  iter_sampling = 200,          
  chains = nchains,            
  parallel_chains = nchains,     
  show_messages = FALSE,
  refresh = 0,            
  seed = 20232023
)
fit_gaussian$summary(.num_args = list(sigfig = 4, notation = "dec"))
```

可以看到，此时 `lp__` 的值包含常数项，两种表示方式对参数的计算结果没有影响。

### Stan 的变量类型

变量的声明没有太多的内涵，就是 C++ 和 Stan 定义的语法，比如整型用 `int` 声明。建模过程中，时常需要将 R 语言环境中的数据传递给 Stan 代码编译出来的模型，而 Stan 是基于 C++ 语言，在变量类型方面有继承有发展。下表给出 Stan 与 R 语言中的变量类型对应关系。值得注意， R 语言的类型检查是不严格的，使用变量也不需要提前声明和初始化。Stan 语言中向量、矩阵的类型都是实数，下标也从 1 开始，元组类型和 R 语言中的列表类似，所有向量默认都是列向量。

| 变量类型 | Stan 语言                   | R 语言                                          |
|---------------|---------------------|------------------------------------|
| 整型     | `int x = 1;`                | `x = 1L`                                        |
| 实数     | `real x = 3.14;`            | `x = 3.14`                                      |
| 向量     | `vector[3] x = [1, 2, 3]';` | `x = c(1L, 2L, 3L)`                             |
| 矩阵     | `matrix[3,1] x;`            | `matrix(data = c(1L, 2L, 3L))`                  |
| 数组     | `array[3] int x;`           | `array(data = c(1L, 2L, 3L), dim = c(3, 1, 1))` |
| 元组     | `tuple(vector[3]) x;`       | `list(x = c(1L, 2L, 3L))`                       |

: Stan 变量类型和 R 语言中的对应 {#tbl-stan-var-dec}

### Stan 的代码结构

``` stan
functions {
  // ... function declarations and definitions ...
}
data {
  // ... declarations ...
}
transformed data {
   // ... declarations ... statements ...
}
parameters {
   // ... declarations ...
}
transformed parameters {
   // ... declarations ... statements ...
}
model {
   // ... declarations ... statements ...
}
generated quantities {
   // ... declarations ... statements ...
}
```

## 广义线性模型 {#sec-generalized-linear-models}

### 生成模拟数据 {#sec-simulate-poisson-data}

先介绍泊松广义线性模型，包括模拟和计算，并和 Stan 实现的结果比较。

泊松广义线性模型如下：

$$
\begin{aligned}
\log(\lambda) &= \beta_0 + \beta_1 x_1 + \beta_2 x_2 \\
Y &\sim \mathrm{Poisson}(u\lambda)
\end{aligned}
$$

设定参数向量 $\beta = (\beta_0, \beta_1, \beta_2) = (0.5, 0.3, 0.2)$，观测变量 $X_1$ 和 $X_2$ 的均值都为 0，协方差矩阵 $\Sigma$ 为

$$
\left[
 \begin{matrix}
   1.0 & 0.8  \\
   0.8 & 1.0 
 \end{matrix}
\right]
$$

模拟观测到的响应变量值和协变量值，添加漂移项

```{r}
set.seed(2023)
n <- 2500 # 样本量
beta <- c(0.5, 0.3, 0.2)
X <- MASS::mvrnorm(n, mu = rep(0, 2), Sigma = matrix(c(1, 0.8, 0.8, 1), 2))
u <- rep(c(2, 4), each = n / 2)
lambda <- u * exp(cbind(1, X) %*% beta)
y <- rpois(n, lambda = lambda)
```

### 拟合泊松模型 {#sec-poisson-model}

拟合泊松回归模型

```{r}
fit_poisson_glm <- glm(y ~ X, family = poisson(link = "log"), offset = log(u))
summary(fit_poisson_glm)
```

```{r}
# 对数似然函数值
log_poisson_lik <- logLik(fit_poisson_glm)
# 计算 AIC AIC(fit_poisson_glm)
-2 * c(log_poisson_lik) + 2 * attr(log_poisson_lik, "df")
```

下面用 Stan 编码泊松回归模型，模型代码如下：

```{verbatim, file="code/poisson_log_glm.stan", lang="stan"}
```

Stan 代码主要分三部分：

1.  数据部分 `data`：声明模型的输入数据，数据类型、大小、约束。

2.  参数部分 `parameters`：类似数据部分，声明模型的参数，参数类型、大小。

3.  模型部分 `model`：指定模型参数的先验分布。

4.  生成量 `generated quantities`：拟合模型获得参数估计值后，计算一些统计量。

下面准备数据

```{r}
nchains <- 4 # 4 条迭代链
# 给每条链设置不同的参数初始值
inits_data <- lapply(1:nchains, function(i) {
  list(
    alpha = runif(1, 0, 1),
    beta = runif(2, 1, 10)
  )
})

# 准备数据
poisson_d <- list(
  n = 2500, # 观测记录的条数
  k = 2, # 协变量个数
  X = X, # N x 2 矩阵
  y = y, # N 向量
  log_offset = log(u)
)
```

编译模型，抽样获取参数的后验分布

```{r}
#| message: false

# 加载 cmdstanr 包
library(cmdstanr)
# 编译模型
mod_poisson <- cmdstan_model(
  stan_file = "code/poisson_log_glm.stan",
  compile = TRUE,
  cpp_options = list(stan_threads = TRUE)
)
# 采样拟合模型
fit_poisson_stan <- mod_poisson$sample(
  data = poisson_d, # 观测数据
  init = inits_data, # 迭代初值
  iter_warmup = 1000, # 每条链预处理迭代次数
  iter_sampling = 2000, # 每条链总迭代次数
  chains = nchains, # 马尔科夫链的数目
  parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个
  threads_per_chain = 1, # 每条链设置一个线程
  show_messages = FALSE, # 不显示迭代的中间过程
  refresh = 0, # 不显示采样的进度
  seed = 20222022 # 设置随机数种子，不要使用 set.seed() 函数
)
# 迭代诊断
fit_poisson_stan$diagnostic_summary()
# 输出结果
fit_poisson_stan$summary(c("alpha", "beta", "lp__"))
```

### 参数后验分布 {#sec-posterior-distribution}

加载 **bayesplot** 包，bayesplot 包提供一系列描述数据分布的绘图函数，比如绘制散点图 `mcmc_scatter()` 。$\beta_1$ 和 $\beta_2$ 的联合分布

```{r}
#| label: fig-stan-scatter
#| fig-cap: $\beta_1$ 和 $\beta_2$ 的联合分布
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 4
#| message: false

library(ggplot2)
library(bayesplot)
mcmc_scatter(fit_poisson_stan$draws(c("beta[1]", "beta[2]"))) +
  theme_classic() +
  labs(x = expression(beta[1]), y = expression(beta[2]))
```

如果提取采样的数据，也可使用 ggplot2 包绘图，不局限于 bayesplot 设定的风格。

```{r}
#| label: fig-density-filled
#| fig-cap: $\beta_1$ 和 $\beta_2$ 的联合分布
#| fig-showtext: true
#| fig-width: 6
#| fig-height: 5

beta_df <- fit_poisson_stan$draws(c("beta[1]", "beta[2]"), format = "draws_df")
ggplot(data = beta_df, aes(x = `beta[1]`, y = `beta[2]`)) +
  geom_density_2d_filled() +
  facet_wrap(~.chain, ncol = 2) +
  theme_classic() +
  labs(x = expression(beta[1]), y = expression(beta[2]))
```

$\beta_1$ 和 $\beta_2$ 的热力图

```{r}
#| label: fig-stan-hex
#| fig-cap: $\beta_1$ 和 $\beta_2$ 的热力图
#| fig-showtext: true
#| fig-width: 5.5
#| fig-height: 4

mcmc_hex(fit_poisson_stan$draws(c("beta[1]", "beta[2]"))) +
  theme_classic() +
  labs(x = expression(beta[1]), y = expression(beta[2]))
```

各个参数的轨迹图

```{r}
#| label: fig-stan-trace
#| fig-cap: 各个参数的轨迹图
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 5

mcmc_trace(fit_poisson_stan$draws(c("beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed, strip.position = "top", ncol = 1
  )
) +
  theme_classic()
```

可以将模型参数的后验分布图展示出来

```{r}
#| label: fig-stan-dens
#| fig-cap: 各个参数的分布图（密度图）
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 5

mcmc_dens(fit_poisson_stan$draws(c("beta[1]", "beta[2]")),
  facet_args = list(
    labeller = ggplot2::label_parsed, strip.position = "top", ncol = 1
  )
) +
  theme_classic()
```

岭线图就是将各个参数的后验分布图放在一起。

```{r}
#| label: fig-stan-ridges
#| fig-cap: 各个参数的分布图（岭线图）
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 4
#| message: false

mcmc_areas_ridges(x = fit_poisson_stan$draws(), pars = c("beta[1]", "beta[2]")) +
  scale_y_discrete(labels = scales::parse_format()) +
  theme_classic()
```

参数的 $\hat{R}$ 潜在尺度收缩因子

```{r}
bayesplot::rhat(fit_poisson_stan, pars = "alpha")
```

后验预测诊断的想法是检查根据拟合模型生成的随机数 $y^{rep}$ 与真实观测数据 $y$ 的接近程度。为直观起见，可以用一系列描述数据分布的图来可视化检验。

y 是真实数据，yrep 是根据贝叶斯拟合模型生成的数据。下图是真实数据的密度图和50组生成数据的密度图。

```{r}
#| label: fig-stan-ppcheck
#| fig-cap: 后验预测诊断图（密度图）
#| fig-showtext: true
#| fig-width: 5
#| fig-height: 4

# 抽取 yrep 数据
yrep <- fit_poisson_stan$draws(variables = "y_rep", format = "draws_matrix")
pp_check(y, yrep = yrep[1:50, ], fun = ppc_dens_overlay) +
  theme_classic()
```

### 模型评估指标 {#sec-model-evaluation}

**loo** 包可以计算 WAIC

```{r}
fit_poisson_waic <- loo::waic(fit_poisson_stan$draws(variables = "log_lik"))
print(fit_poisson_waic)
```

**loo** 包推荐使用 LOO-CV ，它还提供诊断信息、有效样本量和蒙特卡罗估计。

```{r}
fit_poisson_loo <- fit_poisson_stan$loo(variables = "log_lik", cores = 2)
print(fit_poisson_loo)
```

### 可选替代实现 {#sec-bayesian-brms}

对于常见的统计模型，rstanarm 和 **brms** 包都内置了预编译的 Stan 程序，下面用 **brms** 包的函数 `brm()` 拟合带上述漂移项的泊松广义线性模型，参数估计结果和 Base R 函数 `glm()` 的几乎一致，因编译和抽样的过程比较花费时间，速度不及 Base R。

``` r
# brms
dat <- data.frame(y = y, X = X, u = u)
colnames(dat) <- c("y", "x1", "x2", "u")
fit_poisson_brm <- brms::brm(y ~ x1 + x2 + offset(log(u)),
  data = dat, family = poisson(link = "log")
)
fit_poisson_brm
```

```         
 Family: poisson 
  Links: mu = log 
Formula: y ~ x1 + x2 + offset(log(u)) 
   Data: dat (Number of observations: 2500) 
  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
         total post-warmup draws = 4000

Population-Level Effects: 
          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
Intercept     0.49      0.01     0.47     0.51 1.00     2509     2171
x1            0.29      0.01     0.26     0.32 1.00     1771     1645
x2            0.21      0.01     0.19     0.24 1.00     1727     1847

Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS
and Tail_ESS are effective sample size measures, and Rhat is the potential
scale reduction factor on split chains (at convergence, Rhat = 1).
```

调用函数 `brm()` 拟合模型后返回一个 brmsfit 对象 `fit_poisson_brm`，**brms** 包提供很多函数处理该数据对象，比如 `brms::loo()` 计算 LOO-CV

``` r
brms::loo(fit_poisson_brm)
```

```         
Computed from 4000 by 2500 log-likelihood matrix

         Estimate   SE
elpd_loo  -5386.3 37.8
p_loo         2.9  0.1
looic     10772.6 75.5
------
Monte Carlo SE of elpd_loo is 0.0.

All Pareto k estimates are good (k < 0.5).
See help('pareto-k-diagnostic') for details.
```

输出结果中， LOO IC 信息准则 Loo information criterion，looic 指标的作用类似频率派模型中的 AIC 指标，所以也几乎相同的。

``` r
# 后验预测检查
brms::pp_check(fit_poisson_brm)
```

## 选择先验分布 {#sec-choose-prior}

响应变量服从伯努利分布的广义线性模型有 11 个协变量（含截距），实际有用的是 3 个变量，其它变量应该被收缩掉。贝叶斯收缩 （bayesian shrinkage）与变量选择是有关系的，先验分布影响收缩的力度。下面模拟生成 2500 个样本，非 0 的回归系数分别是 $\alpha = 1,\beta_1 = 3,\beta_2 = -2$ 。

```{r}
set.seed(2023)
n <- 2500
k <- 10
X <- matrix(rnorm(n * k), ncol = k)
y <- rbinom(n, size = 1, prob = plogis(1 + 3 * X[, 1] - 2 * X[, 2]))
# 准备数据
mdata <- list(k = k, n = n, y = y, X = X)
```

### 正态先验 {#sec-prior-normal}

```{verbatim, file="code/bernoulli_logit_glm_normal.stan", lang="stan"}
```

```{r}
#| message: false

mod_logit_normal <- cmdstan_model(
  stan_file = "code/bernoulli_logit_glm_normal.stan",
  compile = TRUE, cpp_options = list(stan_threads = TRUE)
)

fit_logit_normal <- mod_logit_normal$sample(
  data = mdata,
  chains = 2,
  parallel_chains = 2,
  iter_warmup = 1000, 
  iter_sampling = 1000, 
  threads_per_chain = 2, 
  seed = 20232023,
  show_messages = FALSE,
  refresh = 0
)

# 输出结果
fit_logit_normal$summary(c("alpha", "beta", "lp__"))
```

### Lasso 先验 {#sec-prior-lasso}

```{verbatim, file="code/bernoulli_logit_glm_lasso.stan", lang="stan"}
```

```{r}
#| message: false
mod_logit_lasso <- cmdstan_model(
  stan_file = "code/bernoulli_logit_glm_lasso.stan",
  compile = TRUE, cpp_options = list(stan_threads = TRUE)
)

fit_logit_lasso <- mod_logit_lasso$sample(
  data = mdata,
  chains = 2,
  parallel_chains = 2,
  iter_warmup = 1000, 
  iter_sampling = 1000, 
  threads_per_chain = 2, 
  seed = 20232023,
  show_messages = FALSE,
  refresh = 0
)

# 输出结果
fit_logit_lasso$summary(c("alpha", "beta", "lambda", "lp__"))
```

计算 LOO-CV 比较正态先验和 Lasso 先验

```{r}
fit_logit_normal_loo <- fit_logit_normal$loo(variables = "log_lik", cores = 2)
print(fit_logit_normal_loo)

fit_logit_lasso_loo <- fit_logit_lasso$loo(variables = "log_lik", cores = 2)
print(fit_logit_lasso_loo)
```

loo 包的函数 `loo_compare()` 比较两个模型

```{r}
loo::loo_compare(list(model0 = fit_logit_normal_loo, 
                      model1 = fit_logit_lasso_loo))
```

输出结果中最好的模型放在第一行。looic 越小越好，所以，Lasso 先验更好。

### Horseshoe 先验 {#sec-prior-horseshoe}

```{r}
#| eval: false

# horseshoe 先验
mod_logit_horseshoe <- cmdstan_model(
  stan_file = "code/bernoulli_logit_glm_horseshoe.stan",
  compile = TRUE, cpp_options = list(stan_threads = TRUE)
)

fit_logit_horseshoe <- mod_logit_horseshoe$sample(
  data = mdata,
  chains = 2,
  parallel_chains = 2,
  iter_warmup = 1000, 
  iter_sampling = 1000, 
  threads_per_chain = 2, 
  seed = 20232023,
  show_messages = FALSE,
  refresh = 0
)

fit_logit_horseshoe$summary(c("alpha", "beta", "lambda", "lp__")) 
```

::: callout-note
brms 包在模型中全局性地使用 horseshoe 先验信息。
:::

### SpikeSlab 先验 {#sec-prior-spikeslab}

## 选择推理算法 {#sec-choose-inference}

开篇提及 Stan 内置了多种推理算法，不同的算法获得的结果是存在差异的。

-   full Bayesian statistical inference with MCMC sampling (NUTS, HMC)
-   approximate Bayesian inference with variational inference (ADVI)
-   penalized maximum likelihood estimation with optimization (L-BFGS)

### 惩罚极大似然算法 {#sec-optimization-algorithms}

L-BFGS 算法拟合模型，速度非常快。

```{r}
# L-BFGS 算法拟合模型
fit_optim_logit <- mod_logit_lasso$optimize(
  data = mdata, # 观测数据
  init = 0,     # 所有参数初值设为 0
  refresh = 0,  # 不显示迭代进程
  algorithm = "lbfgs", # 优化器
  threads = 1,    # 单线程
  seed = 20232023 # 随机数种子
)

fit_optim_logit$summary(c("alpha", "beta", "lambda", "lp__"))
```

### 变分近似推断算法 {#sec-variational-approximation-algorithms}

ADVI 算法拟合模型，可选的优化器有 `meanfield` 和 `fullrank` ，相比于 L-BFGS 稍慢

```{r}
# ADVI 算法拟合模型
fit_advi_logit <- mod_logit_lasso$variational(
  data = mdata, # 观测数据
  init = 0,     # 所有参数初值设为 0
  refresh = 0,  # 不显示迭代进程
  algorithm = "meanfield", # 优化器
  threads = 1,    # 单线程
  seed = 20232023 # 随机数种子
)

fit_advi_logit$summary(c("alpha", "beta", "lambda", "lp__"))
```

### 拉普拉斯近似算法 {#sec-laplace-approximation-algorithms}

CmdStan 已经集成，但 **cmdstanr** 包对该算法的支持还在开发中。

## 习题 {#sec-bayesian-exercises}

1.  分析挑战者号航天飞机 O 型环数据。**DAAG** 包的 orings 数据集记录美国挑战者号航天飞机 O 型环在不同温度下发生 Erosion 腐蚀和 Blowby 串气的失效数量。 @fig-cdplot-orings 展示航天飞机 O 型环在不同温度下失效的分布图（条件密度图）：随着温度升高，O 型环越来越不容易失效。请分别用 Base R 函数 `glm()` 和 **cmdstanr** 包建模分析 O 型环数据。

    ```{r}
    #| label: fig-cdplot-orings
    #| fig-cap: 航天飞机 O 型环在不同温度下失效的条件密度图
    #| fig-showtext: true
    #| fig-width: 6
    #| fig-height: 4
    #| code-fold: true
    #| echo: !expr knitr::is_html_output()

    # data(orings, package = "DAAG")
    orings <- readRDS(file = "data/orings.rds")
    ggplot(orings, aes(x = Temperature, y = after_stat(count))) +
      geom_density(aes(fill = Total > 0), position = "fill", bw = 2) +
      scale_y_continuous(labels = scales::label_percent()) +
      scale_fill_grey(labels = c("TRUE" = "是", "FALSE" = "否")) +
      theme_classic() +
      labs(x = "温度", y = "比例", fill = "失效")
    ```

2.  根据 @sec-nuclear-pollution-concentration 的数据，建立贝叶斯空间广义线性混合模型，用 Stan 预测核辐射强度的分布。
